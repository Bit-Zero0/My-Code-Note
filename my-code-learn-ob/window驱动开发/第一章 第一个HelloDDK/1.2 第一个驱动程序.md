# HelloDDK的头文件
HelloDDK的头文件主要是为了导入驱动程序开发所必需的 ntddk.h 头文件，此头
文件里包含了对 DDK的所有导出函数的声明。

NT式的驱动程序要导入的头文件是ntddk.h ，而WDM式的驱动程序要导入的头文件为 wdm.h


另外，此头文件中定义了几个标签，分别在程序中指明函数和变量分配在分页内存中或非分页内存中(分页和非分页内存的概念将在[第三章] #todo 中讲述)。最后，该头文件给出了此驱动的函数声明。

```c
/************************************************************************
* 文件名称:Driver.h                                                 
* 作    者:张帆
* 完成日期:2007-11-1
*************************************************************************/
#pragma once

#ifdef __cplusplus
extern "C"
{
#endif
#include <ntddk.h>
#ifdef __cplusplus
}
#endif 

#define PAGEDCODE code_seg("PAGE")
#define LOCKEDCODE code_seg()
#define INITCODE code_seg("INIT")

#define PAGEDDATA data_seg("PAGE")
#define LOCKEDDATA data_seg()
#define INITDATA data_seg("INIT")

#define arraysize(p) (sizeof(p)/sizeof((p)[0]))

typedef struct _DEVICE_EXTENSION {
	PDEVICE_OBJECT pDevice;
	UNICODE_STRING ustrDeviceName;	//设备名称
	UNICODE_STRING ustrSymLinkName;	//符号链接名
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

// 函数声明

NTSTATUS CreateDevice (IN PDRIVER_OBJECT pDriverObject);
VOID HelloDDKUnload (IN PDRIVER_OBJECT pDriverObject);
NTSTATUS HelloDDKDispatchRoutine(IN PDEVICE_OBJECT pDevObj,
								 IN PIRP pIrp);
```
- 代码6~15行，包含ddkh头文件，所有的NT式驱动程序都要包含此头文件。因为这里采用的是C++语言编写，如果直接包含ntddk.h，函数的符号表会导入错误所以需要加入extern"C"，这样可以保证符号表正确导入。关于C++编写驱动需要注意的地方，将在第3章进行论述。
- 代码17~23行，定义分页标记、非分页标记和初始化内存块。在Windows驱动程序的开发中，所有程序的函数和变量要被指明被加载到分页内存中还是在非分页内存中。程序代码中加入这里定义的宏，就会被指明函数和变量是位于分页或非分页内存中。另外，有一个特殊的函数DriverEntry需要放在INIT标志的内存中INIT标志指明该函数只是在加载的时候需要载入内存，而当驱动程序成功加载后，该函数可以从内存中卸载掉。
- 代码27~31行，指定一个设备扩展结构体，这种结构体广泛应用于驱动程序中。根据不同驱动程序的需要，它负责补充定义设备的相关信息。
- 代码33-38行是函数的声明。





# HelloDDK的入口函数
和普通的应用程序不同，Windows驱动程序的入口函数不是**main**函数，而是一个叫
做**DriverEntry**的函数，代码将在下面列出。

DriverEnty函数由内核中的I/O管理器负责调用，其函数有两个参数:
>**pDriverObject 和 pRegistryPath**
>- pDriverbject是I/0管理器传递进来的驱动对象
>- pRegistryPath是一个Unicode字符串，指向此驱动负责的注册表

```c 
#include "Driver.h"

/************************************************************************
* 函数名称:DriverEntry
* 功能描述:初始化驱动程序，定位和申请硬件资源，创建内核对象
* 参数列表:
pDriverObject:从I/O管理器中传进来的驱动对象
pRegistryPath:驱动程序在注册表的中的路径
* 返回 值:返回初始化驱动状态
*************************************************************************/
#pragma INITCODE
NTSTATUS DriverEntry(
	IN PDRIVER_OBJECT pDriverObject,
	IN PUNICODE_STRING pRegistryPath)
{
	NTSTATUS status;
	KdPrint(("Enter DriverEntry\n"));

	//注册其他驱动调用函数入口
	pDriverObject->DriverUnload = HelloDDKUnload;
	pDriverObject->MajorFunction[IRP_MJ_CREATE] = HelloDDKDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = HelloDDKDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_WRITE] = HelloDDKDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_READ] = HelloDDKDispatchRoutine;

	//创建驱动设备对象
	status = CreateDevice(pDriverObject);

	KdPrint(("DriverEntry end\n"));
	return status;
}
```

- 代码17行，用`#pragma`指明此函数是加载到INIT内存区域中，即成功卸载后，可以退出内存。
- 代码18行，标志`DriverEnty`函数的开始。注意此处在函数体的前面用`extemn"C"`修饰，这样在编译的时候会编译成`_DriverEntry@8`的符号。如果不加入此修饰符号编译器会自动按照C++的符号名编译，导致错误链接。
- 代码23行，打印一行调试信息。`KdPrint`其实是一个宏在调试版本(Checked版)中，会用`DbgPrint`代替。而在发行版(Free版)中，则不执行任何操作，其功能类似于MFC中的TRACE宏。由于驱动程序是运行在Windows的核心态，没有用户界面，所以查看调试信息有别于Win32程序。关于查看调试信息的讲解将在第3章论述。
- 代码26~30行，驱动程序向Windows的I/O管理器注册一些回调函数。回调函数是由程序员定义的函数，这些函数不是由驱动程序本身负责调用，而是由操作系统负责调用。程序员将这些函数的入口地址告诉操作系统，操作系统会在适当的时候调用这些函数。在这个例子中，这几个回调函数基本是自解释型的，读者可以根据函数名分析出其作用。当驱动被卸载时，调用`HelloDDKUnload`。当驱动程序处理创建、关闭和读写相关的IRP时，调用`HelloDDKDispatchRoutine`(这里只是将处理函数简化为一个函数，实际情况要比这个复杂)。
- 代码第33行，调用`CreateDevice`函数，此函数的解释见下一节。
- 代码第36行，返回`CreateDevice`的执行结果。如果执行正确，驱动将被成功加载。

```c 
/************************************************************************
* 函数名称:CreateDevice
* 功能描述:初始化设备对象
* 参数列表:
pDriverObject:从I/O管理器中传进来的驱动对象
* 返回 值:返回初始化状态
*************************************************************************/
#pragma INITCODE
NTSTATUS CreateDevice(
	IN PDRIVER_OBJECT	pDriverObject)
{
	NTSTATUS status;
	PDEVICE_OBJECT pDevObj;
	PDEVICE_EXTENSION pDevExt;

	//创建设备名称
	UNICODE_STRING devName;
	RtlInitUnicodeString(&devName, L"\\Device\\MyDDKDevice");

	//创建设备
	status = IoCreateDevice(pDriverObject,
		sizeof(DEVICE_EXTENSION),
		&devName,
		FILE_DEVICE_UNKNOWN,
		0, TRUE,
		&pDevObj);
	if (!NT_SUCCESS(status))
		return status;

	pDevObj->Flags |= DO_BUFFERED_IO;
	pDevExt = (PDEVICE_EXTENSION)pDevObj->DeviceExtension;
	pDevExt->pDevice = pDevObj;
	pDevExt->ustrDeviceName = devName;
	//创建符号链接
	UNICODE_STRING symLinkName;
	RtlInitUnicodeString(&symLinkName, L"\\??\\HelloDDK");
	pDevExt->ustrSymLinkName = symLinkName;
	status = IoCreateSymbolicLink(&symLinkName, &devName);
	if (!NT_SUCCESS(status))
	{
		IoDeleteDevice(pDevObj);
		return status;
	}
	return STATUS_SUCCESS;
}

/************************************************************************
* 函数名称:HelloDDKUnload
* 功能描述:负责驱动程序的卸载操作
* 参数列表:
pDriverObject:驱动对象
* 返回 值:返回状态
*************************************************************************/
#pragma PAGEDCODE
VOID HelloDDKUnload(IN PDRIVER_OBJECT pDriverObject)
{
	PDEVICE_OBJECT	pNextObj;
	KdPrint(("Enter DriverUnload\n"));
	pNextObj = pDriverObject->DeviceObject;
	while (pNextObj != NULL)
	{
		PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION)
			pNextObj->DeviceExtension;

		//删除符号链接
		UNICODE_STRING pLinkName = pDevExt->ustrSymLinkName;
		IoDeleteSymbolicLink(&pLinkName);
		pNextObj = pNextObj->NextDevice;
		IoDeleteDevice(pDevExt->pDevice);
	}
}

/************************************************************************
* 函数名称:HelloDDKDispatchRoutine
* 功能描述:对读IRP进行处理
* 参数列表:
pDevObj:功能设备对象
pIrp:从IO请求包
* 返回 值:返回状态
*************************************************************************/
#pragma PAGEDCODE
NTSTATUS HelloDDKDispatchRoutine(IN PDEVICE_OBJECT pDevObj,
	IN PIRP pIrp)
{
	KdPrint(("Enter HelloDDKDispatchRoutine\n"));
	NTSTATUS status = STATUS_SUCCESS;
	// 完成IRP
	pIrp->IoStatus.Status = status;
	pIrp->IoStatus.Information = 0;	// bytes xfered
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	KdPrint(("Leave HelloDDKDispatchRoutine\n"));
	return status;
}
```


```c
```

```JAVA
NTSTATUS HelloDDKDispatchRoutine(IN PDEVICE_OBJECT pDevObj,
	IN PIRP pIrp)
{
	KdPrint(("Enter HelloDDKDispatchRoutine\n"));
	NTSTATUS status = STATUS_SUCCESS;
	// 完成IRP
	pIrp->IoStatus.Status = status;
	pIrp->IoStatus.Information = 0;	// bytes xfered
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	KdPrint(("Leave HelloDDKDispatchRoutine\n"));
	return status;
}
```