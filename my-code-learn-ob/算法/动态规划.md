# 343. 整数拆分
[343. 整数拆分](https://leetcode.cn/problems/integer-break/)
> 1. 确定dp数组（dp table）以及下标的含义
> `dp[i]`：分拆数字i，可以得到的最大乘积为`dp[i]`。
>
>2. 确定递推公式
>可以想 `dp[i]`最大乘积是怎么得到的呢？
>其实可以从1遍历j，然后有两种渠道得到`dp[i]`.
>一个是`j * (i - j)`直接相乘。
>一个是`j * dp[i - j]`，相当于是拆分`(i - j)`，对这个拆分不理解的话，可以回想dp数组的定义。
>
> 3. 初始化
> 这里我只初始化`dp[2] = 1`，从`dp[i]`的定义来说，拆分数字2，得到的最大乘积是1

```cpp
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1 , 0);
        dp[2] = 1;
        for(int i = 3; i <= n ; i++)
        {
            //因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。
            for(int j = 1 ; j <= i/2 ; j++)
            {
                dp[i] = max(dp[i] , max(j*(i-j) , j*dp[i-j]));
            }
        }
        return dp[n];
    }
};
```

# 63. 不同路径 II
[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();

        ////如果在起点或终点出现了障碍，直接返回0
        if(obstacleGrid[m-1][n-1]==1 || obstacleGrid[0][0] == 1) return 0;

        vector<vector<int>> dp(m , vector<int>(n , 0));
        ///但如果(i, 0) 这条边有了障碍之后，障碍之后（包括障碍）都是走不到的位置了，所以障碍之后的dp[i][0]应该还是初始值0。 下标(0, j)的初始化情况同理。
        for(int i = 0 ; i < n && obstacleGrid[0][i] == 0; i++) dp[0][i]= 1;
        for(int j = 0 ; j < m && obstacleGrid[j][0] == 0; j++) dp[j][0] = 1;

        for(int i = 1 ; i < m ; i++)
        {
            for(int j = 1 ; j < n ; j++)
            {
                if(obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i][j-1] + dp[i-1][j];
            }
        } 

        return dp[m-1][n-1];
    }
};
```

# 62. 不同路径
[62. 不同路径](https://leetcode.cn/problems/unique-paths/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/0062.%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE)
```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp( m , vector<int>(n , 0));
        for(int i = 0 ; i < m ; i++) dp[i][0] = 1;
        for(int j = 0 ; j < n ; j++) dp[0][j] = 1;

        for(int i = 1 ; i < m ; i++)
        {
            for(int j = 1 ; j < n ; j++ )
            {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

# 746.使用最小花费爬楼梯
[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1); //到达第i台阶所花费的最少体力为dp[i]。
        // 默认第一步都是不花费体力的
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i < dp.size(); i++)
        {
            dp[i] = min((dp[i-1] + cost[i-1]) , (dp[i-2] + cost[i-2]));
        }

        return dp[cost.size()];
    }
};
```


## 优化空间版
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        // 默认第一步都是不花费体力的
        int dp1 = 0;
        int dp2 = 0;
        for(int i = 2; i <= cost.size(); i++)
        {
            int dpi = min((dp2 + cost[i-1]) , (dp1 + cost[i-2]));
            dp1 = dp2;
            dp2 = dpi;
        }

        return dp2;
    }
};
```


# 70. 爬楼梯
[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if(n <= 2) return n;
        
        int dp[4];
        dp[1] = 1;
        dp[2] = 2;
        int result = 0;
        for(int i = 3 ; i <= n ; i++)
        {
            result = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = result;
        }
        return result;
    }
};
```