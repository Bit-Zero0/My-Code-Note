

# 135. 分发糖果
[135. 分发糖果](https://leetcode.cn/problems/candy/)

[代码随想录 (programmercarl.com)](https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html#%E6%80%9D%E8%B7%AF)

局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果
```cpp
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> candy(ratings.size() , 1);

        for(int i = 1; i < ratings.size(); i++)
        {
            if(ratings[i] > ratings[i-1])
                candy[i] = candy[i-1]+1;
        }
        for(int i = ratings.size() -2 ; i >= 0 ; i--)
        {
            if(ratings[i] > ratings[i+1])
                candy[i] = max(candy[i] , candy[i + 1] + 1);//candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多。
        }

        int result = 0;
        for(int i : candy)
            result+=i;
            
        return result;
    }
};
```


# 134. 加油站
[134. 加油站](https://leetcode.cn/problems/gas-station/)

```cpp
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int start = 0;
        int total = 0;
        int sum = 0;

  
        for(int j = 0 ; j < cost.size() ;j++)
        {
            sum += gas[j] - cost[j]; 
            total += gas[j] - cost[j];
            if(total < 0)  // 当前累加rest[i]和 curSum一旦小于0
            {
                start = j+1;// 起始位置更新为i+1
                total = 0; // curSum从0开始
            }
        }
        if(sum < 0) // 说明怎么走都不可能跑一圈了
            return -1;

        return start;
    }
};
```


# 1005. K 次取反后最大化的数组和
[1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

```cpp
class Solution {
public:
    static bool cmp(int a , int b)
    {
        return abs(a) > abs(b);
    }
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        sort(nums.begin() , nums.end() , cmp); //将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
        for(int i = 0 ; i < nums.size() ; i++)
        {
            if(nums[i] < 0 && k > 0) //从前向后遍历，遇到负数将其变为正数，同时K-
            {
                nums[i] *= -1;
                k--;
            }
        }
        if(k % 2 == 1) //如果K还大于0，那么反复转变数值最小的元素，将K用完
        {
            nums[nums.size()-1] *= -1;
        }

        int result = 0;
        for(int i = 0; i < nums.size() ; i++) // 求数组和
        {
            result += nums[i];
        }

        return result;
    }
};
```

# 45. 跳跃游戏 II
[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if(nums.size() == 1) return 0;

        int nextCover = 0; // 当前覆盖最远距离下标
        int curCover = 0; // 当前覆盖最远距离下标
        int result = 0;   // 记录走的最大步数
        for(int i = 0 ; i < nums.size() ; i++)
        {
            nextCover = max(nextCover , nums[i] + i); // 更新下一步覆盖最远距离下标
            if( i == curCover)
            {
                result++;
                curCover = nextCover; // 更新当前覆盖最远距离下标（相当于加油了）
                if(nextCover >= nums.size()-1) break;// 当前覆盖最远距到达集合终点，不用做ans++操作了，直接结束
            }
        } 
        return result;
    }
};
```

# 55. 跳跃游戏
[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

```cpp
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int cover = 0;
        if(nums.size() == 1) return true;// 只有一个元素，就是能达到
        for(int i = 0 ; i <= cover ; i++) // 注意这里是小于等于cover
        {
            cover = max(cover , nums[i]+i);
            cout << cover << endl;
            if(cover >= nums.size()-1) return true;
        }

        return false;
    }
};
```

# 122. 买卖股票的最佳时机
[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

**局部最优：收集每天的正利润，全局最优：求得最大利润**
```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for(int i = 1 ; i < prices.size() ; i++)
        {
            result += max(prices[i] - prices[i-1] , 0);
        }
        return result;
    }
};
```



# 53. 最大子数组和
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
## 贪心解法
此题局部最优就是从数组中的找到最大值开始累计
```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int count = 0;
        int result = 0;
        for(int i = 0; i < nums.size() ; i++)
        {
            count += nums[i];
            if(count > result) result = count; // 取区间累计的最大值（相当于不断确定最大子序终止位置）
            if(count < 0) count = 0; //// 设置起始位置,  此判断必须放后面, 数字有可能只有一个数, 且可能是负数, 所以要先让result保存结果
        }
        return result;
    }
};
```






# 455. 分发饼干
[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

**小饼干先喂饱小胃口**
```cpp
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin() , g.end());
        sort(s.begin() , s.end());
        int result = 0; // 这是吃饱的孩子数量
        int index = 0;
        for(int i = 0 ; i < s.size() ; i++) 
        {
            if(index < g.size() && g[index] <= s[i])
            {
                result++;
                index++;
            }
        }
        return result;
    }
};
```



# 376.摆动序列
[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)


```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {

        if(nums.size() <= 1) return nums.size();
        int preDiff = 0; // 前一对差值
        int curDiff = 0; // 当前一对差值
        int result = 1; // 记录峰值个数，序列默认序列最右边有一个峰值
        for(int i = 0 ; i < nums.size() -1 ; i++)
        {
            curDiff = nums[i+1] - nums[i];

            // 出现峰值
            if((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0))
            {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
            }
        }
        return result;
    }
};
```