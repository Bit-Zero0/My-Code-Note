
# 快乐数
[202. 快乐数](https://leetcode.cn/problems/happy-number/)

## 解题思路
这题的难点在于跳出死循环, unordered_set是不会存储重复的数据的, 所以我们可以将已经得到的sum加入到unordered_set中 , 在循环中,如果我们再次得到重复的sum, 表示 n 不是快乐数 , 则可以退出循环.

## C++题解
```cpp
class Solution {
public:
    int getSum(int n)
    {
        int sum = 0;
        while(n)
        {
            sum += (n % 10) * (n % 10);
            n /= 10;
        }

        return sum;
    }

    bool isHappy(int n) {
        unordered_set<int> set;
        while(1)
        {
            int sum = getSum(n);
            if(sum == 1)
                return true;
            
            if(set.find(sum) != set.end())
            {
                return false;
            }
            else
            {
                set.insert(sum);
            }
            n = sum;
        } 
    }
};
```


# 242. 有效的字母异位词
[242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)

## 解题思路
因为本题中只使用小写字母 , 所以使用哈希的思路,将26个字母映射到数组中, 字母每出现一次则被映射到的位置 `++` ,  在与另一个数组进行比对时,该数组映射的相对位置 `--` . 最后若数组中所有元素都是 0 ,则是异位词 true , 反之不为异位词 false


## C++题解
```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for(int i = 0 ; i < s.size() ; i++)//先将s映射到数组中
        {
            record[s[i] - 'a']++;
        }

        for(int i = 0 ; i < t.size() ; i++) 
        {
            record[t[i] -'a']--;
        }

        for(int i = 0 ; i < 26 ; i++)
        {
            if(record[i] != 0)
                return false;
        }

        return true;
    }
};
```



# 349. 两个数组的交集
 [349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)

## 解题思路
使用unordered_set来进行解决.

- 使用unordered_set定义一个`result_set`来装 交集结果.
- 使用unordered_set定义一个`nums_set`来将`nums1`中的数据导入其中,`nums_set`是会进行 去重操作 的.
- 使用 `nums2`中的元素 与`nums_set`中的元素进行对比 , 将找到的交集的插入到`result_set`中.
- 最后使用`result_set` 初始化一个vector 进行提交即可

## C++题解
```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set;
        unordered_set<int> nums_set(nums1.begin() , nums1.end());
        for(int i = 0 ; i < nums2.size() ; i++)
        {
            if(nums_set.find(nums2[i]) != nums_set.end())
            {
                result_set.insert(nums2[i]);
            }
        }
        vector<int> result(result_set.begin() , result_set.end());
        return result;
    }
};
```