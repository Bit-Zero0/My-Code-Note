
# 106.从中序与后序遍历序列构造二叉树
[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## 解题思路
- 第一步：如果数组大小为零的话，说明是空节点了。

- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。

- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点

- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）

- 第五步：切割后序数组，切成后序左数组和后序右数组

- 第六步：递归处理左区间和右区间


```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder , vector<int>& postorder)
    {
        // 第一步: 如果数组大小为零的话，说明是空节点了。
        if(postorder.size() == 0) return nullptr;

        // 第二步：后序遍历数组最后一个元素，就是当前的中间节点
        int rootValue = postorder[postorder.size() -1];
        TreeNode* root = new TreeNode(rootValue);

        // 处理叶子节点
        if(postorder.size() == 1) return root;

        // 第三步：找到中序遍历的切割点
        int delimitIndex = 0;
        for(;delimitIndex < postorder.size(); delimitIndex++)
        {
            if(inorder[delimitIndex] == rootValue) break;
        }

        // 第四步：切割中序数组，得到 中序左数组和中序右数组
        vector<int> leftIn = vector(inorder.begin() , inorder.begin() + delimitIndex);// 左闭右开区间：[0, delimiterIndex)
        vector<int> rightIn = vector(inorder.begin() + delimitIndex + 1 , inorder.end());// [delimiterIndex + 1, end)

        // 第五步：切割后序数组，得到 后序左数组和后序右数组 , 这里有个重点,就是中序数组大小一定是和后序数组的大小相同的（这是必然）。
        postorder.resize(postorder.size() - 1); // postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了

        vector<int> leftPost = vector(postorder.begin() , postorder.begin() + leftIn.size()); // 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
        vector<int> rightPost = vector(postorder.begin() + leftIn.size() , postorder.end());// [leftInorder.size(), end)

        // 第六步: 递归处理左区间和右区间
        root->left = traversal(leftIn , leftPost);
        root->right = traversal(rightIn , rightPost);

        return root; 
    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size() == 0 || postorder.size() == 0) return nullptr;
        return traversal(inorder , postorder);
    }
};
```

# 112. 路径总和
[112. 路径总和](https://leetcode.cn/problems/path-sum/)

## 递归法
```cpp
class Solution {
public:
    bool traversal(TreeNode* cur , int count)
    {
        if(!cur->left && !cur->right && count==0) return true;// 遇到叶子节点，并且计数为0
        if(!cur->left && !cur->right && count!=0) return false;  // 遇到叶子节点直接返回

        if(cur->left) 
            if (traversal(cur->left , count - cur->left->val)) return true; //要对后续的递归进行判断, 有符合的路径就返回true
        if(cur->right) 
            if(traversal(cur->right , count - cur->right->val)) return true; //要对后续的递归进行判断, 有符合的路径就返回true

        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        return traversal(root , targetSum - root->val);
    }
};
```

## 迭代法
```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        stack<pair<TreeNode* , int>> st; // // 此时栈里要放的是pair<节点指针，路径数值>
        st.push({root , root->val});
        while(!st.empty())
        {
            pair<TreeNode* , int> cur = st.top();
            st.pop();

             // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if(!cur.first->left && !cur.first->right && targetSum == cur.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if(cur.first->right) st.push({cur.first->right , cur.second + cur.first->right->val});

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if(cur.first->left) st.push({cur.first->left , cur.second + cur.first->left->val});
        }
        return false;
    }
};
```


# 513. 找树左下角的值
[513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

## 递归法
```cpp
class Solution {
public:
    int maxDepth = INT_MIN;   // 全局变量 记录最大深度
    int result;       // 全局变量 最大深度最左节点的数值

    void traversal(TreeNode* cur , int depth)
    {
        if(cur->left == nullptr && cur->right == nullptr) 
        {
            if(depth > maxDepth)
            {
                maxDepth = depth; // 更新最大深度
                result = cur->val; // 最大深度最左面的数值
            }
            return;
        }
        if(cur ->left)
            traversal(cur->left , depth+1);

        if(cur->right)
            traversal(cur->right , depth+1);
    }

    int findBottomLeftValue(TreeNode* root) {
        if(root == nullptr) return 0;
        traversal(root , 0);
        return result;
    }
};
```


## 迭代法
```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> queue;
        queue.push(root);
        int result = 0;
        while(!queue.empty())
        {
            int size = queue.size();
            for(int i = 0 ; i < size ; i++)
            {
                TreeNode* cur = queue.front();
                queue.pop();
                
                if( i == 0) result =  cur->val; // 记录最后一行第一个元素

                if(cur->left) queue.push(cur->left);
                if(cur->right) queue.push(cur->right);
            }
        }
        return result;
    }
};
```


# 404. 左叶子之和
[404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

## 递归法
```cpp
 //采用后续遍历
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        TreeNode* cur = root;
        if(cur == nullptr) return 0;
        if(cur->left == nullptr && cur->right==nullptr) return 0;
        
        int leftCount = sumOfLeftLeaves(cur->left);
        if(cur->left != nullptr && cur->left->left == nullptr && cur->left->right == nullptr) // 左子树就是一个左叶子的情况
            leftCount = cur->left->val;

        int rightCount = sumOfLeftLeaves(cur->right);
        int sum = leftCount +rightCount;
        return sum;
    }
};
```

## 迭代法
```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        
        stack<TreeNode*> st;
        int result = 0; //存放结果

        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            st.pop();
            if(cur->left != nullptr && cur->left->left == nullptr &&cur->left->right == nullptr)
                result += cur->left->val;
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }

        return result;
    }
};
```

# 257. 二叉树的所有路径
[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

## 递归法
```cpp
class Solution {
public:

    // 使用前序遍历法 + 回溯
    void traversal(TreeNode* root , vector<int>& path , vector<string>& result)
    {
        //这里必须要先保存数据, 因为最后一个节点也要加入到path中
        path.push_back(root->val);
        
        if(root->left == nullptr && root->right == nullptr)
        {

            //将路径转化为题目所需的格式 , 如: "1->2->5"
            string sPath;
            for(int i = 0; i < path.size() - 1 ; i++)
            {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }

        if(root->left) // 左
        {
            traversal(root->left , path , result);
            path.pop_back(); // 回溯
        }
        if(root->right) // 中
        {
            traversal(root->right , path , result);
            path.pop_back(); //回溯
        }
    }

     
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if(root == nullptr) return result;
        traversal(root , path , result);
        return result;
    }
};
```

### 精简版
这涉及到C++的值传递和引用传递的区别 #todo
 ```cpp
 class Solution {
public:

    // 使用前序遍历法 + 回溯
    void traversal(TreeNode* root , string path , vector<string>& result)
    {
        //这里必须要先保存数据, 因为最后一个节点也要加入到path中
        path += to_string(root->val);

        if(root->left == nullptr && root->right == nullptr)
        {
            result.push_back(path);
            return;
        }

        if(root->left)  traversal(root->left , path + "->" , result);

        if(root->right) traversal(root->right , path + "->" , result);
    }

     
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        string path;
        if(root == nullptr) return result;
        traversal(root , path , result);
        return result;
    }
};
```


## 迭代法
```cpp
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt; // 保存树的遍历节点
        stack<string> pathSt; // 保存遍历路径的节点
        vector<string> result; // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while(!treeSt.empty())
        {
            TreeNode* cur = treeSt.top(); // 中 ;取出节点
            treeSt.pop();
            string path = pathSt.top(); // 取出该节点对应的路径
            pathSt.pop();
             if(cur->left == nullptr && cur->right == nullptr) //遇到叶子节点
             {
                 result.push_back(path);
             }

             if(cur->right)
             {
                 treeSt.push(cur->right);
                 pathSt.push(path + "->"  + to_string(cur->right->val));
             }
             if(cur->left)
             {
                 treeSt.push(cur->left);
                 pathSt.push(path + "->"  + to_string(cur->left->val));
             }
        } 
        return result;
    }
};
```

# 110. 平衡二叉树

## 递归法
[110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)
```cpp
class Solution {
public:
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }

        //// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
        int leftHeight = getHeight(node->left);// 左
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);// 右
        if (rightHeight == -1) return -1;
        
        int result;
        if (abs(leftHeight - rightHeight) > 1) {  // 中
            result = -1;
        } else {
            result = 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度
        }

        return result;

    }

    bool isBalanced(TreeNode* root) {
        int result = getHeight(root);
        if(result == -1) return false;
        return true;
    }
};
```


## 迭代法
```cpp
class Solution {
public:
    int getHeight(TreeNode* node) {
        int result = 0 ; 
        int depth = 0;
        stack<TreeNode*> st;
        if(node == nullptr)return 0;
        st.push(node);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            if(cur != nullptr)
            {
                // st.pop();
                // st.push(node);
                st.push(nullptr);
                depth++;
                if(cur->right) st.push(cur->right);
                if(cur->left) st.push(cur->left);
            }
            else
            {
                st.pop();
                //node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result :depth;
        }
        return result;

    }

    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if(root == nullptr) return true;
        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top(); // 中
            st.pop();
            if(abs(getHeight(cur->left) - getHeight(cur->right)) > 1)
            {
                return false;
            }
            if(cur->right) st.push(cur->right); // 右(空节点不入栈)
            if(cur->left) st.push(cur->left); // 左(空节点不入栈)
        }
        return true;
    }
};
```


# 222.完全二叉树的节点个数
 [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

## 递归法
```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int leftCnt = countNodes(root->left);
        int rightCnt = countNodes(root->right);
        
        return leftCnt+ rightCnt +1;

    }
};
```



## 迭代法
使用层序遍历的方法来做
```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> queue;
        int result = 0;
        queue.push(root);
        while(!queue.empty())
        {
            int size = queue.size();
            for(int i = 0 ; i < size ; i++)
            {
                TreeNode* node = queue.front();
                queue.pop();
                result++;
                if(node->left) queue.push(node->left);
                if(node->right) queue.push(node->right);
            }
        }
        return result;
    }
};
```




# 111.二叉树的最小深度
[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)


## 递归法
```cpp
class Solution {
public:
    int getMinDepth(TreeNode* node)
    {
        if(node == nullptr) return 0;
        int leftDepth = getMinDepth(node->left);
        int rightDepth = getMinDepth(node->right);

        // 当一个右子树为空，左不为空，这时并不是最低点
        if(node->left != nullptr && node->right == nullptr)
        {
            return leftDepth + 1 ;
        }
        // 当一个左子树为空，右不为空，这时并不是最低点
        if(node->left == nullptr && node->right != nullptr)
        {
            return rightDepth + 1 ;
        }

        return 1 + min(leftDepth , rightDepth);
    }

    int minDepth(TreeNode* root) {
        return getMinDepth(root);
    }
};
```

## 迭代法
```cpp
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        queue<TreeNode*> queue;
        int depth = 0;
        queue.push(root);
        while(!queue.empty())
        {
            int size = queue.size();
            depth++;
            for(int i = 0 ; i < size ; i++)
            {
                TreeNode* node = queue.front();
                queue.pop();
                if(node->left) queue.push(node->left);
                if(node->right) queue.push(node->right);
                if(node->left == nullptr && node->right== nullptr) return depth;
            }
        } 
        return depth;
    }
};
```

# 104.二叉树的最大深度
[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

## 递归法
```cpp
class Solution {
public:

    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0; 

        return 1 + max(maxDepth(root->left) , maxDepth(root->right)); //1 是根节点的; 1 + 最深的子树的高
    }
};
```

## 前序回溯法
```cpp
class Solution {
public:
    int result;

    void getMaxDepth(TreeNode* node , int depth){

        result = depth > result ? depth: result;

        if(node->left == nullptr && node->right==nullptr) return ;

        if (node->left) { // 左
            depth++;    // 深度+1
            getdepth(node->left, depth);
            depth--;    // 回溯，深度-1
        }
        if (node->right) { // 右
            depth++;    // 深度+1
            getdepth(node->right, depth);
            depth--;    // 回溯，深度-1
        }

        return ;
    }

    int maxDepth(TreeNode* root) { 
        if(root == nullptr) return 0;
        result = 0;
        getMaxDepth(root , 1); // 因为有根 , 所以初始高度就是1
        return result;
    }
};
```


# 101.对称二叉树
[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

## 递归法
```cpp
class Solution {
public:
    bool compare(TreeNode* left , TreeNode* right)
    {
        // 首先排除空节点的情况
        if(left == nullptr && right != nullptr) return false;
        else if(left != nullptr && right == nullptr) return false;
        else if(left == nullptr && right == nullptr) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if(left->val != right->val) return false;

        // 左子树：左、 右子树：右
        // 左子树：右、 右子树：左
        // 左子树：中、 右子树：中（逻辑处理）
        return compare(left->left , right->right) && compare(right->left , left->right);
    }
    bool isSymmetric(TreeNode* root) {
        return compare(root->left , root->right);
    }
};
```

## 迭代法
使用队列对节点进行判断
```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == nullptr) return true;
        queue<TreeNode*> queue;
        queue.push(root->left);
        queue.push(root->right);

        while(!queue.empty())
        {
            TreeNode* leftNode = queue.front();
            queue.pop();
            TreeNode* rightNode = queue.front();
            queue.pop();

            // 左节点为空、右节点也为空，此时说明是对称的
            if(leftNode == nullptr && rightNode == nullptr) continue;

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if(leftNode == nullptr || rightNode == nullptr || (leftNode->val != rightNode->val))
                return false;

            queue.push(leftNode->left);
            queue.push(rightNode->right);
            queue.push(leftNode->right);
            queue.push(rightNode->left);
        }
    
        return true;
    }
};
```


# 226.翻转二叉树
[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

## 递归法
```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;

        swap(root->left , root->right);
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

## 迭代法
使用栈来进行对节点进行管理
```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;

        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            st.pop();
            swap(cur->left , cur->right);
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
        return root;
    }
};
```



# 102.二叉树的层序遍历
 [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        if(root == nullptr ) return result;

        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty())
        {
            vector<int> vec;
            int size = que.size();

            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0 ; i < size ; i++)
            {
                TreeNode* cur = que.front();
                que.pop();
                vec.push_back(cur->val);
                if(cur->left) que.push(cur->left);
                if(cur->right) que.push(cur->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```


# 144.二叉树前序遍历
[144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
## 递归解题
```cpp
class Solution {
public:
    void traversal(TreeNode* root , vector<int>& result )
    {
        if(root == nullptr) return;
        result.push_back(root->val);
        traversal(root->left , result);
        traversal(root->right , result);
    } 
    
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root , result);
        return result;
    }
};
```


## 非递归解题
迭代法主要使用 栈 进行解题,在根节点出栈后,先入右孩子 ,再入左孩子 , 这样就能根据栈的特性先出左孩子,在出右孩子
```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        if(root ==  nullptr) return result;
        stack<TreeNode*> st;
               
        st.push(root); // 入根节点
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            result.push_back(cur->val); 
            st.pop(); //出根节点
            if(cur->right)st.push(cur->right);// 右（空节点不入栈）
            if(cur->left)st.push(cur->left); // 左（空节点不入栈）
        }
        return result;   
    }
};
```





# 94.二叉树中序遍历
[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

## 递归解题
```cpp
class Solution {
public:
    void traversal(TreeNode* root , vector<int>& result)
    {
        if(root == nullptr) return;
        traversal(root->left , result);
        result.push_back(root->val);
        traversal(root->right , result);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root , result);
        return result;
    }
};
```



## 非递归解题
为了解释清楚，我说明一下 刚刚在迭代的过程中，其实我们有两个操作：

1.  **处理：将元素放进result数组中**
2.  **访问：遍历节点**

分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        
        while(cur != nullptr || !st.empty())
        {
            if(cur != nullptr)
            {
                st.push(cur);
                cur = cur->left;
            }
            else
            {
                cur = st.top();
                st.pop();
                result.push_back(cur->val);
                cur = cur->right;
            }
        }
        return result;
    }
};
```




# 145.二叉树后序遍历
[145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/)

## 递归解题
```cpp
class Solution {
public:
    void traversal(TreeNode* root , vector<int>& result)
    {
        if(root == nullptr) return ;
        traversal(root->left , result);
        traversal(root->right , result);
        result.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        traversal(root , result);
        return result;
    }
};
```


## 非递归解题
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        if(root == nullptr) return result;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            result.push_back(cur->val);
            st.pop();
            if(cur->left) st.push(cur->left);
            if(cur->right) st.push(cur->right);
        }
        reverse(result.begin() , result.end());
        return result;
    }
};
```


# 二叉树遍历统一迭代法

## 中序遍历
```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        stack<TreeNode*> st;

        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            if(cur != nullptr)
            {
                st.pop();
                if(cur->right) st.push(cur->right);

                st.push(cur);
                st.push(nullptr);

                if(cur->left) st.push(cur->left);
            }
            else
            {   
                st.pop();
                cur = st.top();
                result.push_back(cur->val);
                st.pop();
            }
        }
        return result;
    }
};

```

## 前序遍历
迭代法前序遍历代码如下： (**注意此时我们和中序遍历相比仅仅改变了两行代码的顺序**)
```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        stack<TreeNode*> st;

        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            if(cur != nullptr)
            {
                st.pop();
                if(cur->right) st.push(cur->right);

                if(cur->left) st.push(cur->left);
                
                st.push(cur);
                st.push(nullptr);

            }
            else
            {   
                st.pop();
                cur = st.top();
                result.push_back(cur->val);
                st.pop();
            }
        }
        return result;
        
    }
};
```


## 后序遍历
后续遍历代码如下： (**注意此时我们和中序遍历相比仅仅改变了两行代码的顺序**)
```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        if (root == nullptr) return result;
        stack<TreeNode*> st;

        st.push(root);
        while(!st.empty())
        {
            TreeNode* cur = st.top();
            if(cur != nullptr)
            {
                st.pop();

                st.push(cur);
                st.push(nullptr);
                if(cur->right) st.push(cur->right);

                if(cur->left) st.push(cur->left);

            }
            else
            {   
                st.pop();
                cur = st.top();
                result.push_back(cur->val);
                st.pop();
            }
        }
        return result;
    }
};
```



