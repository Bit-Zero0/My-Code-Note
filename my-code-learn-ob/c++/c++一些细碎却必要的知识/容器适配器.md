# 什么是容器适配器
**适配器是一种设计模式**(设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结)，==该种模式是将一个类的接口转换成客户希望的另外一个接口==。
![[Pasted image 20220528204744.png]]



# STL标准库中stack和queue的底层结构
虽然`stack`和`queue`中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为==**容器适配器**==，这是因为`stack`和队列只是对其他容器的接口进行了包装，STL中`stack`和`queue`默认使用`deque`，比如：
>![[Pasted image 20220528204922.png]]
>![[Pasted image 20220528204942.png]]
>![[Pasted image 20220528204953.png]]

# deque介绍

## deque的原理
>==**deque(双端队列)**==：是一种双开口的"连续"空间的数据结构，双开口的含义是：可以在头尾两端进行插入和删除操作，且时间复杂度为O(1)，与vector比较，头插效率高，不需要搬移元素；与list比较，空间利用率比较高。
>![[Pasted image 20220528210047.png]]
>**deque并不是真正连续的空间，而是由一段段连续的小空间拼接而成的**，实际deque类似于一个动态的二维数组，其底层结构如下图所示：
>![[Pasted image 20220528210155.png]]
>**双端队列底层是一段假象的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，落在了deque的迭代器身上**，因此deque的迭代器设计就比较复杂，如下图所示：
>![[Pasted image 20220528210252.png]]
>
>那deque是如何借助其迭代器维护其假想连续的结构呢？
>![[Pasted image 20220528210321.png]]

## deque 的缺陷
==**与vector比较**==，deque的优势是：==头部插入和删除==时，**不需要搬移元素，效率特别高**，而且在扩容时，也不需要搬移大量的元素，因此其效率是必vector高的。

==**与list比较**==，其底层是连续空间，**空间利用率比较高**，不需要存储额外字段。

但是，==**deque有一个致命缺陷**==：**不适合遍历，因为在遍历时，deque的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下**，而序列式场景中，可能需要经常遍历。

因此在==实际中，需要线性结构时，大多数情况下优先考虑 `vector` 和`list`,==**因为deque适合头尾插入删除，但是中间插入删除、和随机访问效率都差强人意。所以要高频随机访问还得是vector,要任意位置插入删除，还得是Iist**==。

`deque`的应用并不多，而目前能看到的一个应用就是，STL用其作为`stack`和`queue`的底层数据结构。
![[Pasted image 20220528211359.png]]


## 为什么选择deque作为stack和queue的底层默认容器

`stack`是一种后进先出的特殊线性数据结构，因此只要具有`push_back()`和`pop_back()`操作的线性结构，都可以作为`stack`的底层容器，比如`vector`和`list`都可以；`queue`是先进先出的特殊线性数据结构，只要具有

`push_back`和`pop_front`操作的线性结构，都可以作为`queue`的底层容器，比如`list`。但是STL中对`stack`和`queue`默认选择`deque`作为其底层容器，主要是因为：
	1. stack和queue不需要遍历(因此stack和queue没有迭代器)，只需要在固定的一端或者两端进行操作。
	2.  在stack中元素增长时，deque比vector的效率高(扩容时不需要搬移大量数据)；queue中的元素增长时，deque不仅效率高，而且内存使用率高。

结合了deque的优点，而完美的避开了其缺陷。

![[Pasted image 20220528211346.png]]
