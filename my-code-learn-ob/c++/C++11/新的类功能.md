[[c++默认成员函数]]
原来C++类中，有6个默认成员函数：
1. 构造函数
2. 析构函数
3. 拷贝构造函数
4. 拷贝赋值重载
5. 取地址重载
6. const 取地址重载
最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。 

C++11 新增了两个：移动构造函数和移动赋值运算符重载。

针对移动构造函数和移动赋值运算符重载有一些需要注意的点如下：
- 如果你**没有自己实现移动构造函数**，且没有实现**析构函数、拷贝构造、拷贝赋值重载**中的**任意一个**。那么编译器会==自动生成一个**默认移动构造**==。**默认生成的移动构造函数，对于==内置类型成员==会执行逐成员按==字节拷贝(浅拷贝)==**，**==自定义类型成员==，则需要看这个成员==是否实现移动构造==，如果实现了就调用移动构造，==没有实现就调用拷贝构造**==。
- 如果你==没有自己实现移动赋值重载函数==，**且没有实现析构函数、拷贝构造、拷贝赋值重载中的任意一个**，那么**编译器会自动生成一个默认移动赋值**。**默认生成的移动构造函数，对于内置类型成员会执行逐成员按==字节拷贝(浅拷贝)==，==自定义类型成员==，则需要看这个成员==是否实现移动赋值==，如果实现了就调用移动赋堂，==没有实现就调用拷贝赋值==**。(默认移动赋值跟上面移动构造完全关似)
- 如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值.。


以下代码在vs2013中不能体现，vs2013没有很好支持这个特性，在vs2019下才能演示体现上面 
的特性。需要一份我们自己写的string。
```cpp
class Person
{
public:
	Person(const char* name = "", int age = 0)
		:_name(name)
		, _age(age)
	{}
	Person(const Person& p)
		:_name(p._name)
		,_age(p._age)
	{}

	Person& operator=(const Person& p)
	{
		if(this != &p)
		{
			_name = p._name;
			_age = p._age;
		}
		return *this;
	}
	~Person()
	{}

private:
	bit::string _name;
	int _age;
};
int main()
{
	Person s1;
	Person s2 = s1;
	Person s3 = std::move(s1);
	Person s4;
	//s4 = std::move(s2);

	return 0;
}
```

# 类成员变量初始化
C++11允许在类定义时给==成员变量**初始缺省值**==，默认生成构造函数会使用这些缺省值初始化，这 
个我们在雷和对象默认就讲了，这里就不再细讲了。
```cpp
class Person
{
private:
	bit::string _name; 
	int _age = 0;//这不是初始化，而是缺省值。当对象已经创建，但是没有对该值进行初始化的时候，就会采用此缺省值

public:
	//......
};
```


# 强制生成默认函数的关键字default:
C++11可以让你更好的控制要使用的默认函数。假设你要使用某个默认的函数，但是因为一些原因这个函数没有默认生成。
比如：我们提供了拷贝构造，就不会生成移动构造了，那么我们可以 
使用[[默认成员函数控制#显式缺省函数|default]]关键字显示指定移动构造生成。


# 禁止生成默认函数的关键字delete:
如果能想要限制某些默认函数的生成，在C++98中，是该函数设置成private，并且只声明补丁已，这样只要其他人想要调用就会报错。在C++11中更简单，只需在该函数声明加上[[默认成员函数控制#删除默认函数|=delete]]即可，该语法指示编译器不生成对应函数的默认版本，称 [[默认成员函数控制#删除默认函数|=delete]]修饰的函数为**删除函数**。


# 继承和多态中的ﬁnal与override关键字
![[多态#override 和 final]]

