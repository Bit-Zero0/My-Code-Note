在C++中对于**空类编译器会生成一些默认的成员函数**，比如:**构造函数、拷贝构造函数、运算符重载、析构函数和&和const&的重载、移动构造、移动拷贝构造等函数。如果在类中显式定义了，编译器将不会重新生成默认版本**。有时候这样的规则可能被忘记，最常见的是声明了带参数的构造函数，必要时则需要定义不带参数的版本以实例化无参的对象。而且**有时编译器会生成，有时又不生成，容易造成混乱，于是C++11让程序员可以控制是否需要编译器生成**。

# 显式缺省函数
**在C++11中，可以在默认函数定义或者声明时加上`=default`，从而显式的指示编译器生成该函数的默认版本，用`=default`修饰的函数称为==显式缺省函数==。**
```cpp
class A 
{ 
public:
	A(int a): _a(a) 
	{}
	// 显式缺省构造函数，由编译器生成 
	A() = default;
	
	// 在类中声明，在类外定义时让编译器生成默认赋值运算符重载 
	A& operator=(const A& a);
	
private: 
	int _a;
};

A& A::operator=(const A& a) = default; 
int main()
{
	A a1(10); 
	A a2;
	a2 = a1; 
	return 0;
}
```

# 删除默认函数
如果能想要限制某些默认函数的生成，**在C++98中，是该函数设置成private**，并且不给定义，这样只要其他人想要调用就会报错。**在C++11中更简单，只需在该函数声明加上`=delete`即可，该语法指示编译器不生成对应函数的默认版本，称`=delete`修饰的函数为==删除函数==**。
```cpp
class A 
{ 
public:
	A(int a): _a(a) 
    {}
    
	// 禁止编译器生成默认的拷贝构造函数以及赋值运算符重载 
	A(const A&) = delete;
	A& operator(const A&) = delete; 
	
private:
	int _a; 
};
int main() 
{
	A a1(10);
	// 编译失败，因为该类没有拷贝构造函数 
	
	//A a2(a1);
	// 编译失败，因为该类没有赋值运算符重载 
	A a3(20);
	a3 = a2; 
	return 0;
}
```
注意：避免删除函数和[[explicit 关键字|explicit]]一起使用。


