
# 表的增删查改
其实就是四个操作：
- CRUD : Create(创建), Retrieve(读取)，Update(更新)，Delete（删除）

## create
语法：
```sql
INSERT [INTO] table_name 
	[(column [, column] ...)]
	VALUES (value_list) [, (value_list)] ... 
	
value_list: value, [, value] ...
```

案例：
```sql
-- 创建一张学生表
CREATE TABLE students (
   id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, 
   sn INT NOT NULL UNIQUE COMMENT '学号',
   name VARCHAR(20) NOT NULL, 
   qq VARCHAR(20)
);
```

### 单行数据 + 全列插入
插入两条记录，**value_list 数量必须和定义表的列的数量及顺序一致**.

注意，这里在插入的时候，也可以不用指定id(当然，那时候就需要明确插入数据到那些列了)，那么mysql会使用默认的值进行自增
```sql
-- 插入两条记录，value_list 数量必须和定义表的列的数量及顺序一致
-- 注意，这里在插入的时候，也可以不用指定id(当然，那时候就需要明确插入数据到那些列了)，那么mysql会使用默认的值进行自增。
INSERT INTO students VALUES (100, 10000, '唐三藏', NULL); 
Query OK, 1 row affected (0.02 sec)

INSERT INTO students VALUES (101, 10001, '孙悟空', '11111'); 
Query OK, 1 row affected (0.02 sec)

-- 查看插入结果
SELECT * FROM students;
+-----+-------+-----------+-------+ 
| id  | sn    | name      | qq    | 
+-----+-------+-----------+-------+ 
| 100 | 10000 | 唐三藏     | NULL | 
| 101 | 10001 | 孙悟空     | 11111 | 
+-----+-------+-----------+-------+
2 rows in set (0.00 sec)
```

### 多行数据 + 指定列插入
```sql
-- 插入两条记录，value_list 数量必须和指定列数量及顺序一致
INSERT INTO students (id, sn, name) VALUES 
(102, 20001, '曹孟德'),
(103, 20002, '孙仲谋');
Query OK, 2 rows affected (0.02 sec) 
Records: 2  Duplicates: 0  Warnings: 0

-- 查看插入结果
SELECT * FROM students;
+-----+-------+-----------+-------+ 
| id  | sn    | name      | qq    | 
+-----+-------+-----------+-------+ 
| 100 | 10000 | 唐三藏     | NULL | 
| 101 | 10001 | 孙悟空     | 11111 | 
| 102 | 20001 | 曹孟德     | NULL | 
| 103 | 20002 | 孙仲谋     | NULL | 
+-----+-------+-----------+-------+
4 rows in set (0.00 sec)
```

### 插入否则更新
由于 **主键** 或者 **唯一键** ==对应的值已经存在而导致插入失败==。
```sql
-- 主键冲突
INSERT INTO students (id, sn, name) VALUES (100, 10010, '唐大师'); 
ERROR 1062 (23000): Duplicate entry '100' for key 'PRIMARY'
-- 唯一键冲突
INSERT INTO students (sn, name) VALUES (20001, '曹阿瞒'); 
ERROR 1062 (23000): Duplicate entry '20001' for key 'sn'
```

可以选择性的进行**同步更新操作  语法**：
```sql
INSERT ... ON DUPLICATE KEY UPDATE 
	column = value [, column = value] ...
```

```sql
INSERT INTO students (id, sn, name) VALUES (100, 10010, '唐大师') 
ON DUPLICATE KEY UPDATE sn = 10010, name = '唐大师';
Query OK, 2 rows affected (0.47 sec)
-- 0 row affected: 表中有冲突数据，但冲突数据的值和 update 的值相等
-- 1 row affected:      表中没有冲突数据，数据被插入
-- 2 row affected:      表中有冲突数据，并且数据已经被更新

-- 通过    MySQL 函数获取受到影响的数据行数 
SELECT ROW_COUNT();
+-------------+ 
| ROW_COUNT() | 
+-------------+ 
|     2       | 
+-------------+
1 row in set (0.00 sec)
-- ON DUPLICATE KEY 当发生重复key的时候
```

### 替换
- 主键    或者    唯一键    **没有冲突**，则**直接插入**； 
- 主键    或者    唯一键    **如果冲突**，则**删除后再插入**
```sql
-- 主键    或者    唯一键    没有冲突，则直接插入； 
-- 主键    或者    唯一键    如果冲突，则删除后再插入

REPLACE INTO students (sn, name) VALUES (20001, '曹阿瞒'); 
Query OK, 2 rows affected (0.00 sec)

-- 1 row affected:      表中没有冲突数据，数据被插入
-- 2 row affected:      表中有冲突数据，删除后重新插入
```


## retrieve 
语法：
```spl
SELECT
	[DISTINCT] {* | {column [, column] ...} 
	[FROM table_name]
	[WHERE ...]
	[ORDER BY column [ASC | DESC], ...] 
	LIMIT ...
```

案例：
```sql
-- 创建表结构
CREATE TABLE exam_result (
id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, 
name VARCHAR(20) NOT NULL COMMENT '同学姓名', 
chinese float DEFAULT 0.0 COMMENT '语文成绩', 
math float DEFAULT 0.0 COMMENT '数学成绩', 
english float DEFAULT 0.0 COMMENT '英语成绩'
);

-- 插入测试数据
INSERT INTO exam_result (name, chinese, math, english) VALUES 
('唐三藏', 67, 98, 56),
('孙悟空', 87, 78, 77), 
('猪悟能', 88, 98, 90), 
('曹孟德', 82, 84, 67), 
('刘玄德', 55, 85, 45), 
('孙权', 70, 73, 78), 
('宋公明', 75, 65, 30);
Query OK, 7 rows affected (0.00 sec) 
Records: 7  Duplicates: 0  Warnings: 0
```