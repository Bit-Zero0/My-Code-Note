# 网络IO
当两个主机进行交互时，各自的传输层都有各自的接受缓冲区和发送缓冲区，而数据不是随时都有的，而是当另一端发送到自己的接收缓冲区后，应用层才能向下到传输层的接收缓冲区中读取数据。
所以 `IO==等待数据+拷贝数据`

>==那要怎样提高IO的效率呢？==
>- 改变等待数据的方式
>- 减少等待的时间比重

# 五种IO模型
>例子：有五个人去钓鱼，分别是，张三， 李四，王五，赵六， 田七
>
>**张三**：专心的人，一心一意守着鱼竿。
>**李四**：三心二意的人，虽然守着鱼竿，但时不时的却做其他事。
>**王五**：聪明人，在鱼竿上放好铃铛，铃铛响时则专心钓鱼，不响时则进行其他活动。
>**赵六**：有钱人，在湖边放了很多鱼竿，哪个鱼竿钩住鱼则进行钓鱼
>**田七**：大老板 ， 他不想钓鱼，只想吃鱼，让手下来钓鱼，钓满一桶后手下打电话通知他来取。

==张三就是 **阻塞等待(BIO)**== ：无论是获取新的连接还是读取指定连接的数据，调用操作系统的函数都是阻塞的，如果要实现服务多个连接，就必须每个连接建立一个线程异步处理，否则，当建立起一个连接，但是客户端不发送数据，服务端就会被这个客户端占用，无法接受新的连接。

==李四 是 **非阻塞等待(NIO)**==: 解决了阻塞的问题，程序调用操作系统的函数，如果没有连接或数据，会立即返回，不会阻塞，避免了资源无效浪费。但是，它的问题在于，如果我有1万个连接，每次我需要挨个询问1万次，这个复杂度是O(n)的。每次询问都是一次系统调用，涉及到CPU的用户态内核态切换，成本很高。

==王五 是 **信号驱动**==：[[linux信号]]，等待系统的信号通知，然后进行处理。

==赵六 是 **多路转接**==： IO多路转接能够同时等待多个文件描述符的就绪状态.

==田七 是 **异步**==：由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据).
	-  注意这里的异步不是系统概念的异步，网络的异步和系统的异步不是一个概念。
	- 网络异步就是这在乎结果，不参与过程

## 阻塞等待(BIO)
阻塞IO: 在内核将数据准备好之前, 系统调用会一直等待. 所有的套接字, 默认都是阻塞方式.
![[Pasted image 20221106230003.png]]

## 非阻塞等待(NIO)
如果内核还未将数据准备好, 系统调用仍然会直接返回, 并且返回`EWOULDBLOCK`错误码.

**非阻塞IO往往需要程序员循环的方式反复尝试读写文件描述符**, 这个过程称为==**轮询**==. 这对CPU来说是较大的浪费, 一般只有特定场景下才使用.
![[Pasted image 20221106230130.png]]


## 信号驱动IO
信号驱动IO: 内核将数据准备好的时候, 使用**SIGIO**信号()通知应用程序进行IO操作.
![[Pasted image 20221106230242.png]]


## 多路转接IO
IO多路转接: 虽然从流程图上看起来和阻塞IO类似. 实际上最核心在于IO多路转接能够同时等待多个文件描述符的就绪状态.
![[Pasted image 20221106231024.png]]



## 异步IO
异步IO: 由内核在数据拷贝完成时, 通知应用程序(而信号驱动是告诉应用程序何时可以开始拷贝数据).
![[Pasted image 20221106231107.png]]

## 小结
任何IO过程中, 都包含两个步骤. **第一是等待, 第二是拷贝**. 而且在实际的应用场景中, 等待消耗的时间往 
往都远远高于拷贝的时间. 让IO更高效, 最核心的办法就是让等待的时间尽量少.