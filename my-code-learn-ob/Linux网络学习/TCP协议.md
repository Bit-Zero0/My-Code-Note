# TCP基本认识
## 什么是 TCP ？
TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。
![[Pasted image 20221029170648.png]]
-   **面向连接**：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；
-   **可靠的**：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；
-   **字节流**：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。


## TCP 头格式有哪些？
标注颜色的表示与本文关联比较大的字段
![[Pasted image 20221029170109.png]]

**序列号**：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。**用来解决网络包乱序问题。**

**确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

**控制位：**
-  _URG_: 紧急指针是否有效
-   _ACK_：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
-  _PSH_: 提示接收端应用程序立刻从TCP缓冲区把数据读走
-   _RST_：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
-   _SYN_：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
-   _FIN_：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。

**窗口大小(16位)**：用来做流量控制

**校验和(16位)**: 发送端填充, CRC校验. 接收端校验不通过, 则认为数据有问题. 此处的检验和不光包含TCP首部, 也 
包含TCP数据部分.

**紧急指针(16位)**: 标识哪部分数据是紧急数据;

**40字节头部选项**: 暂时忽略;

## 为什么需要 TCP 协议？ TCP 工作在哪一层？
`IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。
![[Pasted image 20221029170528.png]]
如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 `TCP` 协议来负责。

因为 TCP 是一个工作在**传输层**的**可靠**数据传输的服务，它能确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**

注意：[[UDP协议]] 也在传输层

## 什么是TCP连接
简单来说就是，**用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。**
![[Pasted image 20221029170949.png]]
所以我们可以知道，建立一个 TCP 连接是需要客户端与服务端端达成上述三个信息的共识。
-   **Socket**：由 IP 地址和端口号组成
-   **序列号**：用来解决乱序问题等
-   **窗口大小**：用来做流量控制

# TCP连接建立
## TCP 三次握手过程是怎样的？
TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：
![[Pasted image 20221030131453.png]]

-   一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
![[Pasted image 20221030131525.png]]
-   客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1` ，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

![[Pasted image 20221030131635.png]]
-   服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。

![[Pasted image 20221030131828.png]]
-   客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。

-   服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。


从上面的过程可以发现**第三次握手是可以携带数据的，前两次握手是不可以携带数据的**，这也是面试常问的题。

一旦完成三次握手，双方都处于 `ESTABLISHED` 状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

**但是！！握手丢失了会发生什么？**

## 为什么是三次握手？不是两次、四次？

相信大家比较常回答的是：“因为三次握手才能保证双方具有接收和发送的能力。”

这回答是没问题，但这回答是片面的，并没有说出主要的原因。

在前面我们知道了什么是 **TCP 连接**：

-   用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括**Socket、序列号和窗口大小**称为连接。

所以，重要的是**为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接。**

接下来，以三个方面分析三次握手的原因：
-   三次握手才可以阻止重复历史连接的初始化（主要原因）
-   三次握手才可以同步双方的初始序列号
-   三次握手才可以避免资源浪费

### 原因一：避免历史连接
我们来看看 RFC 793 指出的 TCP 连接使用三次握手的**首要原因**：
简单来说，三次握手的**首要原因是为了防止旧的重复连接初始化造成混乱。**
>我们考虑一个场景，客户端先发送了 `SYN`（seq = 90） 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，又重新向服务端建立连接，发送了 SYN（seq = 100） 报文（**注意！不是重传 SYN，重传的 SYN 的序列号是一样的**）。

看看三次握手是如何阻止历史连接的：
![[Pasted image 20221030135813.png]]

客户端连续发送多次 `SYN` （都是同一个四元组）建立连接的报文，在**网络拥堵**情况下：
-   一个「旧 `SYN` 报文」比「最新的 `SYN` 」 报文早到达了服务端，那么此时服务端就会回一个 `SYN + ACK` 报文给客户端，此报文中的确认号是 91（90+1）。
-   客户端收到后，发现自己期望收到的确认号应该是 100+1，而不是 90 + 1，于是就会回 `RST` 报文。
-   服务端收到 `RST` 报文后，就会释放连接。
-   后续最新的 `SYN` 抵达了服务端后，客户端与服务端就可以正常的完成三次握手了。

上述中的「旧 SYN 报文」称为历史连接，TCP 使用三次握手建立连接的**最主要原因就是防止「历史连接」初始化了连接**。


==**如果是两次握手连接，就无法阻止历史连接**，那为什么 TCP 两次握手为什么无法阻止历史连接呢？==
我先直接说结论，主要是因为**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**。
>你想想，在两次握手的情况下，服务端在收到 `SYN` 报文后，就进入 `ESTABLISHED` 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 `ESTABLISHED` 状态，假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回 `RST` 报文来断开连接，而服务端在第一次握手的时候就进入 `ESTABLISHED` 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 `RST` 报文后，才会断开连接。

![[Pasted image 20221030141009.png]]
可以看到，如果采用两次握手建立 TCP 连接的场景下，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，妥妥地浪费了服务端的资源。

因此，**要解决这种现象，最好就是在服务端发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手**。

所以，**TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。**


### 原因二：同步双方初始序列号

TCP 协议的通信双方， 都必须维护一个「**序列号**」， 序列号是可靠传输的一个关键因素，它的作用：
-   接收方可以去除重复的数据；
-   接收方可以根据数据包的序列号按序接收；
-   可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收，那当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**

![[Pasted image 20221030141303.png]]
四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

### 原因三：避免资源浪费
如果只有「两次握手」，当客户端发送的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端每收到一个 `SYN` 就只能先主动建立一个连接**，这会造成什么情况呢？

如果客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会**建立多个冗余的无效链接，造成不必要的资源浪费。**
![[Pasted image 20221030141823.png]]
即两次握手会造成消息滞留情况下，服务端重复接受无用的连接请求 `SYN` 报文，而造成重复分配资源。

>TIP
>很多人问，两次握手不是也可以根据上下文信息丢弃 syn 历史报文吗？
>我这里两次握手是假设「由于没有第三次握手，服务端不清楚客户端是否收到了自己发送的建立连接的 `ACK` 确认报文，所以每收到一个 `SYN` 就只能先主动建立一个连接」这个场景。
>当然你要实现成类似三次握手那样，根据上下文丢弃 syn 历史报文也是可以的，两次握手没有具体的实现，怎么假设都行。

### 小结
TCP 建立连接时，通过三次握手**能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号**。序列号能够保证数据包不重复、不丢弃和按序传输。

不使用「两次握手」和「四次握手」的原因：

-   「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
-   「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。


## 第一次握手丢失了，会发生什么？
当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「**超时重传**」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。

不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。

当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？

在 Linux 里，客户端的 SYN 报文**最大重传次数**由 `tcp_syn_retries`内核参数控制，这个参数是可以自定义的，默认值一般是 5。
```
# cat /proc/sys/net/ipv4/tcp_syn_retries
5
```

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，**每次超时的时间是上一次的 2 倍**。

当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。

所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。

举个例子，假设` tcp_syn_retries` 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：
![[Pasted image 20221030134009.png]]
>具体过程：
> 当客户端超时重传 3 次 SYN 报文后，由于 `tcp_syn_retries` 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。



## 第二次握手丢失了，会发生什么？
当服务端收到客户端的第一次握手后，就会回 `SYN-ACK` 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。

第二次握手的 `SYN-ACK` 报文其实有两个目的 ：
-   第二次握手里的 `ACK`， 是对第一次握手的确认报文；
-   第二次握手里的 `SYN`，是服务端发起建立 TCP 连接的报文；

所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？

因为第二次握手报文里是包含对客户端的第一次握手的` ACK` 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 `SYN` 报文（第一次握手）丢失了，于是**客户端就会触发超时重传机制，重传 `SYN` 报文**。

然后，因为第二次握手中包含服务端的 `SYN` 报文，所以当客户端收到后，需要给服务端发送 `ACK` 确认报文（第三次握手），服务端才会认为该 `SYN` 报文被客户端收到了。

那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是**服务端这边会触发超时重传机制，重传 `SYN-ACK` 报文**。

在 Linux 下，`SYN-ACK` 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 **5**。
```
# cat /proc/sys/net/ipv4/tcp_synack_retries
5
```

因此，当第二次握手丢失了，客户端和服务端都会重传：
-   客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 `tcp_syn_retries`内核参数决定；
-   服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 `tcp_synack_retries` 内核参数决定。

举个例子，假设`tcp_syn_retries` 参数值为 **1**，`tcp_synack_retries` 参数值为 **2**，那么当第二次握手一直丢失时，发生的过程如下图：
![[Pasted image 20221030134727.png]]
具体过程：
-   当客户端超时重传 1 次 `SYN` 报文后，由于 `tcp_syn_retries` 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（`SYN-ACK` 报文），那么客户端就会断开连接。
-   当服务端超时重传 2 次 `SYN-ACK` 报文后，由于 `tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（`ACK` 报文），那么服务端就会断开连接。

## 第三次握手丢失了，会发生什么？
客户端收到服务端的 `SYN-ACK` 报文后，就会给服务端回一个 `ACK` 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。

因为这个第三次握手的 `ACK` 是对第二次握手的 `SYN` 的确认报文，所以当第三次握手丢失了，如果**服务端那一方迟迟收不到这个确认报文，就会触发==超时重传机制==**，重传 `SYN-ACK` 报文，直到收到第三次握手，或者达到最大重传次数。

注意，**ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文**。

举个例子，假设` tcp_synack_retries` 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：
![[Pasted image 20221030132734.png]]
具体过程：
-   当服务端超时重传 2 次` SYN-ACK` 报文后，由于 `tcp_synack_retries` 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（`ACK` 报文），那么服务端就会断开连接。



# TCP连接断开
天下没有不散的宴席，对于 TCP 连接也是这样， TCP 断开连接是通过**四次挥手**方式。

双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：
![[Pasted image 20221030142856.png]]
![[Pasted image 20221030143016.png]]
-   客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
-   服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
-   客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
-   等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
-   客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
-   服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
-   客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。

你可以看到，每个方向都需要**一个 FIN 和一个 ACK**，因此通常被称为**四次挥手**。

这里一点需要注意是：**主动关闭连接的，才有 TIME_WAIT 状态。**


# 为什么挥手需要四次？
再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。

-   关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
-   服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。





