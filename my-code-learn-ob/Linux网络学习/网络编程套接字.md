# 预备知识
## 理解源IP地址和目的IP地址
源IP地址就是 : 从哪来
目的IP地址就是: 到哪去

## 网络通信的本质
本质上，所有的网络通信，站在普通人的角度，都是人和人之间通信（小白)
技术人员的视角，我们学到的网络通信，==本质是:是**进程间通信**==! !

如：抖音的app客户端(进程) <->抖音服务器(进程)

要进行通信，本质要求：
1. 先找到目标主机
2. 在找到该主机上的服务(进程)


进程具有独立性，进程间通信的前提工作:先得让不同的进程，看到同一份资源!
而这同一份资源，就是 ==**网络**==


# 端口号
我们通过IP找到了目标主机，但是我们怎么找到相应的进程呢？
所以就出现了==**端口号**==，


>端口号(port):==**唯一的标识一台机器上的唯一的一个进程**==!!

我们可以通过端口号找到目标进程，就可以借此进行通信。
![[Pasted image 20221019213353.png]]

==**一个进程可以绑定多个端口号; 但是一个端口号不能被多个进程绑定**==;

## PID   vs   port
既然网络通信的本质就是 进程通信，为什么不使用 PID 而是port 呢？

其实PID就相当于我们现实中的身份证，而在学校中也使用身份证号作为我们的学号时，如果有一天我们的身份证号发生了改变，学校则需要重新对我们的数据进行更改，那样的效率太低下了，所以使用了解耦的方式，由学校自主定制学号(port)，就可以避免了以上的问题。
所以使用port的优势大于PID。


## 认识TCP协议
此处我们先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识; 后面我们再详细讨论TCP的一些细节问题.
- 传输层协议 
- 有连接 
- 可靠传输 
- 面向字节流

## 认识UDP协议
此处我们也是对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识; 后面再详细讨论.
- 传输层协议 
- 无连接 
- 不可靠传输 
- 面向数据报


# 网络字节序
我们已经知道,内存中的多字节数据相对于**内存地址**有**大端**和**小端**之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分,==网络数据流同样有**大端小端**之分== . 那么如何定义网络数据流的地址呢?
- 发送主机通常将发送缓冲区中的数据==按内存地址**从低到高的顺序**发出==;
- 接收主机把从网络上**接到的字节依次保存在接收缓冲区**中,也是==按**内存地址从低到高**的顺序保存==; 
- 因此,**网络数据流的地址**应这样**规定**:==**先发出的数据是低地址,后发出的数据是高地址**==.
- **TCP/IP协议规定**,==网络数据流应采用**大端字节序**,即**低地址高字节**.==
- 不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据; 
- 如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;

![[Pasted image 20221019224406.png]]

为使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。
![[Pasted image 20221019223248.png]]
- 这些函数名很好记,`h`表示`host` , `n`表示`network`, `l` 表示`32位`长整数,`s`表示`16`位短整数。
- 例如`htonl`表示**将32位的长整数从主机字节序转换为网络字节序**,例如将IP地址转换后准备发送。 
- 如果主机是**小端字节序**,这些函数将参数**做相应的大小端转换**然后返回;
- 如果主机是**大端字节序**,这些  **函数不做转换**,将参数原封不动地返回。


# socket编程结构
## socket常见API
``` cpp
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器) 
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr *address, socklen_t address_len);

// 开始监听socket (TCP, 服务器)
int listen(int socket, int backlog); 

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```


## sockaddr结构
socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、IPv6,以及后面要讲的UNIX Domain Socket. 然而, 各种网络协议的地址格式并不相同.
![[Pasted image 20221019223756.png]]
![[Pasted image 20221020121853.png]]
- IPv4和IPv6的地址格式定义在`<netinet/in.h>`中,IPv4地址用`sockaddr_in`结构体表示,包括**16位地址类型**, **16位端口号**和**32位IP地址**.
- IPv4、IPv6地址类型分别定义为常数`AF_INET`、`AF_INET6`. 这样,只要取得某种`sockaddr`结构体的首地址, 不需要知道具体是哪种类型的`sockaddr`结构体,就可以根据地址类型字段确定结构体中的内容. 
- socket API可以都用`struct sockaddr *`类型表示, 在使用的时候需要强制转化成`sockaddr_in`; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数;
- **IPv6**把**IP地址由32位增加到128位**，从而能够支持更大的地址空间


==**sockaddr结构**==
![[Pasted image 20221020122757.png]]
`sockaddr` 结构用于存储参与（IP）Windows/linux套接字通信的计算机上的一个internet协议（IP）地址。为了统一地址结构的表示方法 ，统一接口函数，使得不同的地址结构可以被`bind()`、`connect()`、`recvfrom()`、`sendto()`等函数调用。
但一般的编程中并不直接对此数据结构进行操作，而使用另一个与之等价的数据结构`sockaddr_in`。这是由于Microsoft TCP/IP套接字开发人员的工具箱仅支持internet地址字段，而实际填充字段的每一部分则遵循`sockaddr_in`数据结构，**两者大小都是16字节，所以二者之间可以进行切换**。


## sockaddr_in 结构
![[Pasted image 20221020122640.png]]

### in_addr结构
![[Pasted image 20221020134040.png]]
`in_addr`用来表示一个IPv4的IP地址. 其实就是一个`32位的整数`;


# socket编程接口
## socket()
![[Pasted image 20221020124234.png]]

>参数解析：
>- ==domain== ：**协议域** ， 对于IPv4, 参数指定为AF_INET。
>	- 这些就是可选参数![[Pasted image 20221020124523.png]]
>- ==type== ：**socket的类型**，流格式套接字(SOCK_STREAM)、数据报格式套接字(SOCK_DGRAM)。
>	- **SOCK_STREAM**    提供有序、可靠、双向、基于连接的字节流。可以支持带外数据传输机制（全双工，类似于管道）`TCP`
>	- **SOCK_DGRAM**  支持数据报（固定最大长度的无连接、不可靠消息）。`UDP`
>- ==protocol== ：**协议**，，当protocol为0时，会自动选择type类型对应的默认协议。
>- ==返回值== ：如果成功的话,就像`open()`一样返回一个[[Linux IO操作#文件描述符 `fd`|文件描述符]]，调用出错则返回`-1`.

## bind()
**介绍：** 服务器程序所**监听的网络地址**和**端口号**通常是**固定不变**的,客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接; 服务器需要调用`bind`绑定一个固定的网络地址和端口号,`bind`函数的功能就是**将参数sockfd和addr绑定在一起**。
![[Pasted image 20221020125259.png]]

>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==addr==：sockaddr结构体
>- ==addrlen==：`struct sockaddr *`是一个通用指针类型,addr参数实际上可以接受多种协议的sockaddr结构体,而它们的长度各不相同,所以需要第三个参数addrlen指定结构体的长度
>- ==返回值==： `bind()`成功返回0,失败返回-1

## recvfrom()
从socket 中接收消息。
![[Pasted image 20221020130239.png]]
>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==buf==：接收数据的容器。
>- ==len==：接收数据容器的大小。
>- ==src_addr==：sockaddr结构体
>- ==addrlen==：`struct sockaddr *`是一个通用指针类型,addr参数实际上可以接受多种协议的sockaddr结构体,而它们的长度各不相同,所以需要第三个参数addrlen指定结构体的长度
>- ==返回值==： 失败返回-1,并带回错误码。

## sendto()
发送消息到socket中
![[Pasted image 20221020130012.png]]
>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==buf==：接收数据的容器。
>- ==len==：接收数据容器的大小。
>- ==dest_addr==：sockaddr结构体
>- ==addrlen==：
>- ==返回值==： 失败返回-1,并带回错误码。


## listen()
-   将 `sockfd` 所指向的套接字标记为被动套接字，即后续可以通过`accept()` 接受到来的连接请求。
![[Pasted image 20221025210729.png]]
>- ==sockfd==：将 `sockfd` 所指向的套接字标记为被动套接字，即后续可以通过`accept()` 接受到来的连接请求。
>- ==backlog==:  `backlog`参数定义`sockfd`的挂起连接队列可能增长到的最大长度。如果连接请求队列已满时，客户端的请求会收到一个错误。挂起队列的最大长度是backlog+1。
>- ==返回值==：成功返回0；失败返回-1.

## accept()
服务器通过accept系统调用来等待客户端对该套接字的连接。accept只有当有客户程序试图连接到由socket参数指定的套接字时才会返回。
![[Pasted image 20221025211416.png]]
>- ==sockfd== :  从 sockfd 所关联的监听套接字的连接队列中提取第一个连接，并新建一个套接字文件描述符来指向该连接（对端套接字）。
>- ==addr==： 于 `addr` 中返回对端套接字的地址；`addrlen` 传入时指定 `addr` 所指区域的大小，返回时更新为对端套接字的地址大小。
>- ==addrlen==：如果对对端套接字的信息不感兴趣，可将 `addr`, `addrlen` 设为 `NULL` 。
>- ==返回值==：成功时返回新建的套接字文件描述符；失败时返回 -1，并设置 errno 。


## connect()
客户程序通过在一个未命名套接字和服务器监听套接字之间建立连接的函数
![[Pasted image 20221025212302.png]]
>函数参数： 其实和 [[网络编程套接字#bind()|bind()]]的函数参数是一模一样的
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==addr==：sockaddr结构体
>- ==addrlen==：`struct sockaddr *`是一个通用指针类型,addr参数实际上可以接受多种协议的sockaddr结构体,而它们的长度各不相同,所以需要第三个参数addrlen指定结构体的长度
>- ==返回值==： `bind()`成功返回0,失败返回-1

-   如果 `sockfd` 所指套接字的类型为 `SOCK_STREAM` 或 `SOCK_SEQPACKET`，则 `connect()` 的作用是发送一个连接请求到 `addr` 所绑定的套接字；通常只能调用一次 `connect()` 。

## setsockopt()
使用setsockopt()设置socket描述符的  选项SO_REUSEADDR为1, 表示允许创建端口号相同但IP地址不同的多个socket描述符
![[Pasted image 20221102204843.png]]
>  ==sockfd==：标识一个套接口的描述字
>   ==level==：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6
>   ==optname==：需设置的选项，而有部分选项需在listen/connect调用前设置才有效，这部分选项如下：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG、TCP_NODELAY
>   ==optval==：指针，指向存放选项值的缓冲区
>   ==optlen==：optval缓冲区长度

常用的场景选项：
(1)如果在已经处于 ESTABLISHED状态下的socket(一般由端口号和标志符区分）调用close(socket)（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket：
```cpp
int reuse=1;
setsockopt(s,SOL_SOCKET ,SO_REUSEADDR, &reuse,sizeof(int));
```
**注意：必须在调用bind函数之前设置SO_REUSEADDR选项。**

(2)如果要已经处于连接状态的soket在调用close(socket)后强制关闭，不经历TIME_WAIT的过程：
```text
int reuse=0;
setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)& reuse,sizeof(int));
```

在我们的sock.cpp文件中使用



## IP地址转换接口
由于从网络到主机的数据存在**大端小端**、字符字节长度等数据格式的问题，需要将数据转化为特定的格式。这个过程可以根据当前的系统自己实现，当然也可以调用系统提供的**函数接口**。

网络上的数据传输一般是==**大端模式**==（即数据**低字节存在内存高地址**），数据的发送从内存的低地址到高地址，这样在发送的时候会先发数据的高位字节（报头），这样接受端可以快速判断数据的正负和大小。

### 字符类型的转换
需要导入头文件 `#include <arpa/inet.h>`
```cpp
uint32_t htonl(uint32_t hostlong); //将无符号整数hostlong从主机字节顺序转换为网络字节顺序

uint16_t htons(uint16_t hostshort); //将短整数hostshort从主机字节顺序转换为网络字节顺序。

uint32_t ntohl(uint32_t netlong); //无符号整数hostlong   网络——>主机

uint16_t ntohs(uint16_t netshort); //短整数hostshort  网络——>主机
```

### 主机字节序和网络字节序的转换
需要导入头文件 `#include <arpa/inet.h> <sys/socket.h>  <arpa/inet.h>`
```cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>


int inet_aton(const char *cp, struct in_addr *inp); 
//将Internet主机地址cp从IPv4点分十进制形式转换为二进制形式（按网络字节顺序）并存储它位于inp指向的结构中。如果地址有效，inet_aton()返回非零；如果地址无效，则返回零。cp 的地址具有以下形式之一：a.b.c.d、 a.b.c、 a.b、 a


in_addr_t inet_addr(const char *cp);
//函数将Internet主机地址cp从IPv4点分十进制形式转换为网络字节顺序的二进制数据（主机到网络）


in_addr_t inet_network(const char *cp);
//将IPv4点分十进制形式的字符串cp, 转换为适合用作Internet网络地址的主机字节序。成功后，将返回转换后的地址。如果输入无效，则返回-1。

char *inet_ntoa(struct in_addr in);  //线程不安全 推荐inet_ntop，提供缓冲区保存结果、
//将以网络字节顺序形式的Internet主机地址，转换为IPv4点分十进制表示法的字符串。（网络到主机）

in_addr_t inet_lnaof(struct in_addr in);
//返回Internet地址in中的本地网络地址部分。返回的值按主机字节顺序排列。

in_addr_t inet_netof(struct in_addr in);
//返回Internet地址in中的网络号部分。返回的值按主机字节顺序排列。

struct in_addr inet_makeaddr(int net, int host);
//与inet_lnaof和inet_netof相反。将网络编号net与本地主机地址host组合在一起按主机字节顺序创建的网络主机地址，以网络字节序返回

```

# 实现UDP
==**客户端和服务端区别**==
1.  ==客户端==：主动发起请求的一端，也就意味着客户端必须提前知道服务端的地址信息（ip+port）因此厂商服务端地址信息一般固定而且被固定写入客户端程序
2.  ==服务端==：被动接收请求，提供服务的通信端
![[Pasted image 20221021224258.png]]

## UDP套接字注意事项
注意：云服务器，不允许用户直接bind公网IP，另外, 实际正常编写的时候，我们也不会指明IP 

==**server端**==：我们在设置`server.sin_addr.s_addr` 时，需要 `server.sin_addr.s_addr=INADDR_ANY`: 如果你bind的是确定的IP(主机)， 意味着只有发到该IP主机上面的数据才会交给你的网络进程, 但是，一般服务器可能有多张网卡，配置多个IP，我们需要的不是某个IP上面的数据，我们需要的是，所有发送到该主机，发送到该端口的数据！

==**client端**==：客户端不需要[[网络编程套接字#bind()|bind()]]
	-  首先，客户端必须也要有ip和port
	- 但是，客户端不需要显示的bind！一旦显示bind，就必须明确，client要和哪一个port关联
	- client指明的端口号，在client端一定会有吗？？有可能被占用，被占用导致client无法使用
	- server要的是port必须明确，而且不变，但client只要有就行！一般是由OS自动给你bind(),就是client正常发送数据的时候，OS会自动给你bind，采用的是**随机端口**的方式！


## 初步实现UDP(不完善)

==**udp_server.cpp**==
```cpp
#include <iostream>
#include <string>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>//IPv4与IPv6的地址定义在其中
#include <arpa/inet.h>

const uint16_t port = 6666;

int main()
{
    //1. 创建套接字，打开网络文件
    int sock = socket(AF_INET , SOCK_DGRAM ,0 );//使用SOCK_DGRAM是因为我们写的是原始套接字，UDP。
    if (sock < 0)
    {
        std::cerr << "socket create error" << errno << std::endl;
        return 1;
    }

    //2. 给该服务器绑定端口和ip(特殊处理)
    struct sockaddr_in local;
    local.sin_family = AF_INET;
    local.sin_port = htons(port);//此处的端口号，是我们计算机上的变量，是主机序列
    // a. 需要将人识别的点分十进制，字符串风格IP地址，转化成为4字节整数IP
    // b. 也要考虑大小端
    //in_addr_t inet_addr(const char *cp); 能完成上面ab两个工作.需要头文件<netinet/in,h>,<arpa/inet.h>,<sys/socket.h>

    // 坑:
    // 云服务器，不允许用户直接bind公网IP，另外, 实际正常编写的时候，我们也不会指明IP
     //local.sin_addr.s_addr = inet_addr("42.192.83.143"); //点分十进制，字符串风格[0-255].[0-255].[0-255].[0-255]

    // INADDR_ANY: 如果你bind的是确定的IP(主机)， 意味着只有发到该IP主机上面的数据
    // 才会交给你的网络进程, 但是，一般服务器可能有多张网卡，配置多个IP，我们需要的不是
    // 某个IP上面的数据，我们需要的是，所有发送到该主机，发送到该端口的数据！
    local.sin_addr.s_addr = INADDR_ANY;

    if (bind(sock , (struct sockaddr*)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 2;
    }

	//3.提供服务
    bool quit = false;
    #define NUM 1024
    char buffer[NUM];
    while (!quit) //我们需要创建的是长链接服务，必须一种接收数据
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        recvfrom(sock , buffer , sizeof(buffer)-1 ,0 ,(struct sockaddr*)&peer , &len);

        std::cout << "client#" << buffer << std::endl;

        std::string echo_hello = "hello";
        sendto(sock , echo_hello.c_str() , echo_hello.size() , 0 ,(struct sockaddr*)&peer , len );
    }

    return 0;
}
```

==**tcp_client.cpp**==
```cpp
#include <iostream>
#include <string>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

void Usage(std::string proc)
{
    std::cout << "Usage: \n\t" << proc << " server_ip server_port" << std::endl;
}

int main(int argc , char* argv[])
{
    if (argc != 3)
    {
        Usage(argv[0]);
        return 0;
    }

    // 1. 创建套接字，打开网络文件
    int sock = socket(AF_INET , SOCK_DGRAM ,0);
    if(sock < 0)
    {
        std::cerr << "socket error " << errno << std::endl;
        return 1;
    }

	// 你要给谁发？？
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(atoi(argv[2]));
    server.sin_addr.s_addr = inet_addr(argv[1]);

	// 2.使用服务
    while(1)
    {
        std::string message;
        std::cout<< "请输入#";
        std::cin>> message;

        sendto(sock , message.c_str() , message.size() , 0, (struct sockaddr*)&server , sizeof(server));

		//此处tmp就是一个"占位符"
        struct sockaddr_in tmp;
        socklen_t len = sizeof(tmp);
        char buffer[1024];

        recvfrom(sock , buffer , sizeof(buffer) , 0 ,(struct sockaddr*)&tmp , &len);
        std::cout << "server echo# "<< buffer << std::endl;
    }


    return 0;
}
```

![[Pasted image 20221023204003.png]]

## UDP改善版
解决UDP乱码问题，并增加服务器对部分Linux指令的识别。

==**udp_server.cpp**==
```cpp
#include <iostream>
#include <string>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>//IPv4与IPv6的地址定义在其中
#include <arpa/inet.h>

const uint16_t port = 6666;

int main()
{
    //1. 创建套接字，打开网络文件
    int sock = socket(AF_INET , SOCK_DGRAM ,0 );//使用SOCK_DGRAM是因为我们写的是原始套接字，UDP。
    if (sock < 0)
    {
        std::cerr << "socket create error" << errno << std::endl;
        return 1;
    }

    //2. 给该服务器绑定端口和ip(特殊处理)
    struct sockaddr_in local;
    local.sin_family = AF_INET;
    local.sin_port = htons(port);//此处的端口号，是我们计算机上的变量，是主机序列

    local.sin_addr.s_addr = INADDR_ANY;

    if (bind(sock , (struct sockaddr*)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 2;
    }

    bool quit = false;
    #define NUM 1024
    char buffer[NUM];

    while (!quit)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        ssize_t cnt = recvfrom(sock , buffer ,sizeof(buffer)-1 , 0 , (struct sockaddr *)&peer , &len);

        if(cnt > 0)
        {
            buffer[cnt] = 0;
            FILE* fp = popen(buffer , "r");

            std::string echo_hello;
            char line[1024] = {0};
            while(fgets(line , sizeof(line) , fp)!= nullptr)
            {
                echo_hello += line;
            }

            pclose(fp);
            std::cout << "client #" << buffer << std::endl;

            sendto(sock , echo_hello.c_str() , echo_hello.size() , 0 ,(struct sockaddr*)&peer , len );
        }
        else
        {
            std::cout << "recvfrom error" << errno << std::endl;
        }
    }
    return 0;
}
```

==**udp_client.cpp**==
```cpp
#include <iostream>
#include <string>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <arpa/inet.h>

void Usage(std::string proc)
{
    std::cout << "Usage: \n\t" << proc << " server_ip server_port" << std::endl;
}

int main(int argc , char* argv[])
{
    if (argc != 3)
    {
        Usage(argv[0]);
        return 0;
    }

    // 1. 创建套接字，打开网络文件
    int sock = socket(AF_INET , SOCK_DGRAM ,0);
    if(sock < 0)
    {
        std::cerr << "socket error " << errno << std::endl;
        return 1;
    }

    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(atoi(argv[2]));
    server.sin_addr.s_addr = inet_addr(argv[1]);

    while(1)
    {
        std::string message;
        std::cout<< "请输入指令# ";
        char line[1024];
        fgets(line , sizeof(line) , stdin);

        sendto(sock ,line ,sizeof(line) , 0, (struct sockaddr*)&server , sizeof(server));

        struct sockaddr_in tmp;
        socklen_t len = sizeof(tmp);
        char buffer[1024];

        ssize_t cnt =  recvfrom(sock , buffer , sizeof(buffer) , 0 ,(struct sockaddr*)&tmp , &len);
        if(cnt > 0)
        {
            buffer[cnt] = 0;
            std::cout << buffer << std::endl;
        }
        else
        {}
    }


    return 0;
}
```
![[Pasted image 20221024134959.png]]


# 实现TCP套接字

## TCP套接字注意实现
因为tcp是面向连接的, 
	- a.在通信前，需要建连接 
	- b. 然后才能通信

一定有人主动建立(客户端，需要服务)，一定有人被动接受连接(服务器，提供服务)
我们当前写的是一个server, 周而复始的不间断的等待客户到来。
我们要不断的给用户提供一个建立连接的功能。
设置套接字是==**Listen**==状态, 本质是允许用户连接。


## TCP套接字实现（单进程版）
但进程版是只能有一个连接者，所以在现实中不会有人使用。

==**tcp_client.cpp**==
```cpp
#include <iostream>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <cerrno>
#include <cstring>
#include <string>

void Usage(std::string proc )
{
    std::cout << "Usage: " << proc << " server_ip server_port" << std::endl;
}

int main(int argc , char* argv[])
{
    if(argc != 3)
    {
        Usage(argv[0]);
        return 1;
    }

    std::string svr_ip = argv[1];
    uint16_t svr_port = (uint16_t)atoi(argv[2]);

    int sock = socket(AF_INET , SOCK_STREAM , 0);
    if(sock <  0)
    {
        std::cerr << "socket error!" << std::endl;
        return 2;
    }

    struct sockaddr_in server ;
    bzero(&server , sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port =htons(svr_port);
    server.sin_addr.s_addr =  inet_addr(svr_ip.c_str());

    if(connect(sock , (struct sockaddr*)&server , sizeof(server)) < 0)
    {
        std::cout << "connect server failed !" << std::endl;
        return 3;
    }

    std::cout << "connect success!" << std::endl;

    while(true)
    {
        std::cout << "Please Enter# ";
        char buffer[1024];

        fgets(buffer , sizeof(buffer)-1 , stdin);

        write(sock , buffer , sizeof(buffer));
        ssize_t s = read(sock , buffer , sizeof(buffer)-1);

        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "server echo# "<< buffer << std::endl;
        }
    }

    return 0;
}
```


==**tcp_server.cpp**==
```cpp
#include <iostream>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cerrno>
#include <string>
#include <cstring>
#include <sys/types.h>
#include <cstring>
#include <sys/wait.h>
#include <unistd.h>

void Usage(std::string proc)
{
    std::cout << "Usage:" << proc << "port" << std::endl;
}

void ServiceIO(int new_sock)
{
    while(true)
    {
        char buffer[1024];
        memset(buffer , 0  , sizeof(buffer));
        ssize_t s = read(new_sock , buffer , sizeof(buffer));
        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "client#" << buffer << std::endl;

            std::string echo_string = ">>>server<<<";
            echo_string+=buffer;

            write(new_sock , echo_string.c_str() , echo_string.size());
        }
        else if (s == 0)
        {
            std::cout << "client quit ..." << std::endl;
            break;
        }
        else{
            std::cout << "client quit ..." << std::endl;
            break;
        }
    }
}


int main(int argc , char* argv[])
{
    if(argc != 2)
    {
        Usage(argv[0]);
        return 1;
    }

    int listen_sock = socket(AF_INET , SOCK_STREAM , 0);
    if(listen_sock < 0)
    {
        std::cerr << "socket error" << errno << std::endl;
        return 2;
    }

    struct sockaddr_in local;
    memset(&local , 0 , sizeof(local));

    local.sin_port = htons(atoi(argv[1]));
    local.sin_family = AF_INET;
    local.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_sock , (struct sockaddr *)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 3;
    }

    const int back_log = 5;
    if(listen(listen_sock ,back_log) < 0)
    {
        std::cerr << "listen error" << errno << std::endl;
        return 4;
    }

    while(true)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);

        int new_sock = accept(listen_sock ,(struct sockaddr*)&peer , &len);
        if(new_sock < 0)
        {
            continue;
        }

        uint16_t cli_port = ntohs(peer.sin_port);
        std::string cli_ip = inet_ntoa(peer.sin_addr);

        std::cout << "get a new link -> [" << cli_ip << ":" << cli_port << "]#" << new_sock << std::endl;

        ServiceIO(new_sock);
    }
    return 0;
}
```


## TCP套接字实现（多进程版）
==**tcp_server.cpp**==
```cpp
#include <iostream>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <cerrno>
#include <string>
#include <cstring>
#include <sys/types.h>
#include <cstring>
#include <sys/wait.h>
#include <unistd.h>
#include <signal.h>

void Usage(std::string proc)
{
    std::cout << "Usage:" << proc << "port" << std::endl;
}

void ServiceIO(int new_sock)
{
    while(true)
    {
        char buffer[1024];
        memset(buffer , 0  , sizeof(buffer));
        ssize_t s = read(new_sock , buffer , sizeof(buffer));
        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "client#" << buffer << std::endl;

            std::string echo_string = ">>>server<<<";
            echo_string+=buffer;

            write(new_sock , echo_string.c_str() , echo_string.size());
        }
        else if (s == 0)
        {
            std::cout << "client quit ..." << std::endl;
            break;
        }
        else{
            std::cerr << "read error" << std::endl;
            break;
        }
    }
}

int main(int argc , char* argv[])
{
    if(argc != 2)
    {
        Usage(argv[0]);
        return 1;
    }

    int listen_sock = socket(AF_INET , SOCK_STREAM , 0);
    if(listen_sock < 0)
    {
        std::cerr << "socket error" << errno << std::endl;
        return 2;
    }

    struct sockaddr_in local;
    memset(&local , 0 , sizeof(local));
    local.sin_port = htons(atoi(argv[1]));
    local.sin_family = AF_INET;
    local.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_sock , (struct sockaddr *)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 3;
    }


    const int back_log = 5;
    if(listen(listen_sock ,back_log) < 0)
    {
        std::cerr << "listen error" << errno << std::endl;
        return 4;
    }

    //signal(SIGCHLD , SIG_IGN);//在Linux中父进程忽略子进程的SIGCHLD信号，子进程会自动退出释放资源

    while(true)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        int new_sock = accept(listen_sock ,(struct sockaddr*)&peer , &len);
        if(new_sock < 0)
        {
            continue;
        }
        uint16_t cli_port = ntohs(peer.sin_port);
        std::string cli_ip = inet_ntoa(peer.sin_addr);

        std::cout << "get a new link -> [" << cli_ip << ":" << cli_port << "]#" << new_sock << std::endl;

        pid_t id = fork();
        if(id < 0)
            continue;
        else if(id == 0)//曾经被父进程打开的fd，是否会被子进程继承呢? 会的
        {
            close(listen_sock); //无论父子进程中的哪一个，强烈建议关闭掉不需要的fd，此时关闭的是子进程的listen_sock

	        if(fork() > 0) exit(0);//退出的是子进程,使用这段代码就可以不用SIGCHLD了，因为这里退出的是我们创建的子进程

            //向后走的进程，其实是孙子进程
            ServiceIO(new_sock);
            close(new_sock);
            exit(0);
        }
        else
        {
            waitpid(id  , nullptr , 0); //这里等待的时候会不会被阻塞呢？ 不会
            close(new_sock);
        }
    }


    return 0;
}
```

==**tcp_client.cpp**==
```cpp
#include <iostream>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <cerrno>
#include <cstring>
#include <string>


void Usage(std::string proc )
{
    std::cout << "Usage: " << proc << " server_ip server_port" << std::endl;
}

int main(int argc , char* argv[])
{
    if(argc != 3)
    {
        Usage(argv[0]);
        return 1;
    }

    std::string svr_ip = argv[1];
    uint16_t svr_port = (uint16_t)atoi(argv[2]);

    int sock = socket(AF_INET , SOCK_STREAM , 0);
    if(sock <  0)
    {
        std::cerr << "socket error!" << std::endl;
        return 2;
    }

    struct sockaddr_in server ;
    bzero(&server , sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port =htons(svr_port);
    server.sin_addr.s_addr =  inet_addr(svr_ip.c_str());

    if(connect(sock , (struct sockaddr*)&server , sizeof(server)) < 0)
    {
        std::cout << "connect server failed !" << std::endl;
        return 3;
    }

    std::cout << "connect success!" << std::endl;

    while(true)
    {
        std::cout << "Please Enter# ";
        char buffer[1024];

        fgets(buffer , sizeof(buffer)-1 , stdin);

        write(sock , buffer , sizeof(buffer));
        ssize_t s = read(sock , buffer , sizeof(buffer)-1);

        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "server echo# "<< buffer << std::endl;
        }
    }

    return 0;
}
```


## TCP套接字实现（多线程版）
曾经被主线程打开的fd，新线程是否能看到，是否共享？能看到，是共享的

tcp.server.cpp
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <pthread.h>

void Usage(std::string proc)
{
    std::cout << "Usage:" << proc << "port" << std::endl;
}

void ServiceIO(int new_sock)
{
    while(true)
    {
        char buffer[1024];
        memset(buffer , 0  , sizeof(buffer));
        ssize_t s = read(new_sock , buffer , sizeof(buffer));
        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "client#" << buffer << std::endl;

            std::string echo_string = ">>>server<<<";
            echo_string+=buffer;

            write(new_sock , echo_string.c_str() , echo_string.size());
        }
        else if (s == 0)
        {
            std::cout << "client quit ..." << std::endl;
            break;
        }
        else{
            std::cout << "client quit ..." << std::endl;
            break;
        }
    }
}

void *HandlerRequest(void *args)
{
    pthread_detach(pthread_self());
    int sock = *(int *)args;
    delete (int*)args;

    ServiceIO(sock);
    close(sock);
}

int main(int argc , char* argv[])
{
    if(argc != 2)
    {
        Usage(argv[0]);
        return 1;
    }

    int listen_sock = socket(AF_INET , SOCK_STREAM , 0);
    if(listen_sock < 0)
    {
        std::cerr << "socket error" << errno << std::endl;
        return 2;
    }

    struct sockaddr_in local;
    memset(&local , 0 , sizeof(local));
    local.sin_port = htons(atoi(argv[1]));
    local.sin_family = AF_INET;
    local.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_sock , (struct sockaddr *)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 3;
    }


    const int back_log = 5;
    if(listen(listen_sock ,back_log) < 0)
    {
        std::cerr << "listen error" << errno << std::endl;
        return 4;
    }

    signal(SIGCHLD , SIG_IGN);//在Linux中父进程忽略子进程的SIGCHLD信号，子进程会自动退出释放资源

    while(true)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        int new_sock = accept(listen_sock ,(struct sockaddr*)&peer , &len);
        if(new_sock < 0)
        {
            continue;
        }
        uint16_t cli_port = ntohs(peer.sin_port);
        std::string cli_ip = inet_ntoa(peer.sin_addr);

        std::cout << "get a new link -> [" << cli_ip << ":" << cli_port << "]#" << new_sock << std::endl;

       pthread_t tid;
       int* pram = new int(new_sock);
       pthread_create(&tid, nullptr, HandlerRequest, pram);
    }


    return 0;
}
```

==**tcp_client.cpp**==
```cpp
#include <iostream>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <cerrno>
#include <cstring>
#include <string>

void Usage(std::string proc )
{
    std::cout << "Usage: " << proc << " server_ip server_port" << std::endl;
}

int main(int argc , char* argv[])
{
    if(argc != 3)
    {
        Usage(argv[0]);
        return 1;
    }

    std::string svr_ip = argv[1];
    uint16_t svr_port = (uint16_t)atoi(argv[2]);

    int sock = socket(AF_INET , SOCK_STREAM , 0);
    if(sock <  0)
    {
        std::cerr << "socket error!" << std::endl;
        return 2;
    }

    struct sockaddr_in server ;
    bzero(&server , sizeof(server));
    server.sin_family = AF_INET;
    server.sin_port =htons(svr_port);
    server.sin_addr.s_addr =  inet_addr(svr_ip.c_str());

    if(connect(sock , (struct sockaddr*)&server , sizeof(server)) < 0)
    {
        std::cout << "connect server failed !" << std::endl;
        return 3;
    }

    std::cout << "connect success!" << std::endl;

    while(true)
    {
        std::cout << "Please Enter# ";
        char buffer[1024];

        fgets(buffer , sizeof(buffer)-1 , stdin);

        write(sock , buffer , sizeof(buffer));
        ssize_t s = read(sock , buffer , sizeof(buffer)-1);

        if(s > 0)
        {
            buffer[s] = 0;
            std::cout << "server echo# "<< buffer << std::endl;
        }
    }

    return 0;
}
```


## TCP套接字实现(线程池版)
实现的是短链接版本，每个链接者只能发送一次消息。可以加while循环该为长链接。
我们将server端获取数据的工作交给了Task，由Task对消息进行处理。

==**tcp_server.cpp**==
```cpp
#include <iostream>
#include <string>
#include <cstring>
#include <cerrno>
#include <sys/socket.h>
#include <sys/types.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <pthread.h>

#include "thread_pool.hpp"
#include "Task.hpp"

using namespace fmy_task;
using namespace fmy_threadPool;

void Usage(std::string proc)
{
    std::cout << "Usage:" << proc << "port" << std::endl;
}

int main(int argc , char* argv[])
{
    if(argc != 2)
    {
        Usage(argv[0]);
        return 1;
    }

    int listen_sock = socket(AF_INET , SOCK_STREAM , 0);
    if(listen_sock < 0)
    {
        std::cerr << "socket error" << errno << std::endl;
        return 2;
    }

    struct sockaddr_in local;
    memset(&local , 0 , sizeof(local));
    local.sin_port = htons(atoi(argv[1]));
    local.sin_family = AF_INET;
    local.sin_addr.s_addr = INADDR_ANY;

    if(bind(listen_sock , (struct sockaddr *)&local , sizeof(local)) < 0)
    {
        std::cerr << "bind error " << errno << std::endl;
        return 3;
    }


    const int back_log = 5;
    if(listen(listen_sock ,back_log) < 0)
    {
        std::cerr << "listen error" << errno << std::endl;
        return 4;
    }

    signal(SIGCHLD , SIG_IGN);//在Linux中父进程忽略子进程的SIGCHLD信号，子进程会自动退出释放资源

    while(true)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        int new_sock = accept(listen_sock ,(struct sockaddr*)&peer , &len);
        if(new_sock < 0)
        {
            continue;
        }
        uint16_t cli_port = ntohs(peer.sin_port);
        std::string cli_ip = inet_ntoa(peer.sin_addr);

        std::cout << "get a new link -> [" << cli_ip << ":" << cli_port << "]#" << new_sock << std::endl;

        Task t(new_sock);
        ThreadPool<Task>::GetInstance()->PushTask(t);

    }
    return 0;
}
```

==**Task.hpp**==
对数据进行处理
```cpp
#pragma once

#include <iostream>
#include <cstring>
#include <unistd.h>

namespace fmy_task
{
    class Task
    {
    private:
        int _sock;
    public:
        Task() :_sock(-1){}

        Task(int sock) : _sock(sock)
        {}

        int Run() //接收并打印client端发送的信息，实现的是短链接，
        {
            // while(true) //使用while既是长链接
            // {
            char buffer[1024];
            memset(buffer , 0  , sizeof(buffer));
            ssize_t s = read(_sock , buffer , sizeof(buffer));
            if(s > 0)
            {
                buffer[s] = 0;
                std::cout << "client#" << buffer << std::endl;

                std::string echo_string = ">>>server<<<";
                echo_string+=buffer;

                write(_sock , echo_string.c_str() , echo_string.size());
            }
            else if (s == 0)
            {
                std::cout << "client quit ..." << std::endl;
                //break;
            }
            else{
                std::cerr << "read error" << std::endl;
                //break;
            }
            // }

            close(_sock); //用完就关闭，以免一直占用这个fd
        }

        ~Task() {}
    };
}
```

==**thread_pool.hpp**==
线程池文件，使用的是单例模式构建的线程池
```cpp
#pragma once

#include <iostream>
#include <queue>
#include <pthread.h>
#include <unistd.h>
#include <string>

namespace fmy_threadPool
{
    const int g_num = 5;

    template<class T>
    class ThreadPool
    {
    private:
        int _num;
        std::queue<T> _task_queue;

        pthread_mutex_t  _mtx;
        pthread_cond_t _cond;

        static ThreadPool<T>* ins;

    private:
        ThreadPool(int num = g_num)// 构造函数必须得实现，但是必须的私有化
            :_num(num)
        {
            pthread_mutex_init(&_mtx , nullptr);
            pthread_cond_init(&_cond , nullptr);
        }

        ThreadPool(const ThreadPool<T>& tp) = delete;

        ThreadPool<T> &operator=(ThreadPool<T> &tp) = delete;

    public:
        static ThreadPool<T>* GetInstance()
        {
            static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

            if(ins == nullptr)//双判定，减少锁的争用，提高获取单例的效率！
            {
                pthread_mutex_lock(&lock);
                if(ins == nullptr)
                {
                    ins = new ThreadPool<T>();
                    ins->InitThreadPool();
                    std::cout << "首次加载对象"<< std:: endl;
                }

                pthread_mutex_unlock(&lock);
            }
            return ins;
        }

        void Lock()
        {
            pthread_mutex_lock(&_mtx);
        }

        void Unlock()
        {
            pthread_mutex_unlock(&_mtx);
        }

        void Wait()
        {
            pthread_cond_wait(&_cond , &_mtx);
        }

        void WakeUp()
        {
            pthread_cond_signal(&_cond);
        }

        bool IsEmpty()
        {
            return _task_queue.empty();
        }

    public:
        ~ThreadPool()
        {
            pthread_mutex_destroy(&_mtx);
            pthread_cond_destroy(&_cond);
        }

        // 在类中要让线程执行类内成员方法，是不可行的！
        // 必须让线程执行静态方法
        static void *Rountine(void* args)
        {
            pthread_detach(pthread_self());
            ThreadPool<T>* tp = (ThreadPool<T>*)args;

            while(true)
            {
                tp->Lock();
                while(tp->IsEmpty())
                {
                    tp->Wait();
                }

                T t;
                tp->PopTask(&t);
                tp->Unlock();
                t.Run();
            }
        }

        void InitThreadPool()
        {
            pthread_t tid;
            for(int i = 0 ; i < _num; i++)
            {
                pthread_create(&tid , nullptr , Rountine , (void*)this);
            }
        }

        void PushTask(const T& in)
        {
            Lock();
            _task_queue.push(in);

            Unlock();
            WakeUp();
        }

        void PopTask(T* out)
        {
            *out = _task_queue.front();
            _task_queue.pop();
        }


    };

    template <class T>
    ThreadPool<T> *ThreadPool<T>::ins = nullptr;
}
```
此时当连接者退出时，相应的fd也会关闭了
![[Pasted image 20221025204927.png]]



# TCP协议通讯流程
![[Pasted image 20221025214810.png]]

==**服务器初始化:**==
>- 调用`socket()`, 创建文件描述符;
>- 调用`bind()`, 将当前的文件描述符和ip/port绑定在一起; 如果这个端口已经被其他进程占用了, 就会`bind()`失败;
>- 调用`listen()`, 声明当前这个文件描述符作为一个服务器的文件描述符, 为后面的`accept()`做好准备; 
>- 用`accecpt()`, 并阻塞, 等待客户端连接过来;


==**建立连接的过程:**==
>- 调用`socket()`, 创建文件描述符; 
>- 调用`connect()`, 向服务器发起连接请求;
>- `connect()`会发出SYN段并阻塞等待服务器应答; (第一次)
>- 服务器收到客户端的SYN, 会应答一个SYN-ACK段表示"同意建立连接"; (第二次) 
>- 客户端收到SYN-ACK后会从`connect()`返回, 同时应答一个ACK段; (第三次)

这个建立连接的过程, 通常称为  ==三次握手==; 


==**数据传输的过程**==
>- 建立连接后;,TCP协议提供全双工的通信服务;所谓==**全双工**==的意思是,**在同一条连接中,同一时刻,通信双方可以同时写数据**;相对的概念叫做==**半双工**==,**同一条连接在同一时刻,只能由一方来写数据**;
>- 服务器从`accept()`返回后立刻调用`read()`，,读socket就像读管道一样,如果没有数据到达就阻塞等待;
>- 这时客户端调用`write()`发送请求给服务器,服务器收到后从`read()`返回,对客户端的请求进行处理,在此期间客户端调用`read()`阻塞等待服务器的应答;
>- 服务器调用`write()`将处理结果发回给客户端,再次调用`read()`阻塞等待下一条请求;客户端收到后从`read()`返回,发送下一条请求,如此循环下去;


==**断开连接的过程:**==
>- 如果客户端没有更多的请求了, 就调用`close()`关闭连接, 客户端会向服务器发送FIN段(第一次); 
>- 此时服务器收到FIN后, 会回应一个ACK, 同时`read()`会返回0 (第二次);
>- `read()`返回之后, 服务器就知道客户端关闭了连接, 也调用close()关闭连接, 这个时候服务器会向客户端发送一个FIN; (第三次)
>- 客户端收到FIN, 再返回一个ACK给服务器; (第四次)

这个断开连接的过程, 通常称为  ==四次挥手==



# 套接字总结
1. 创建socket的过程，`socket()`,本质是打开文件-- 仅仅有系统相关的内容
2. `bind()`, `struct sockaddr_in -> ip`, `port`，本质是==**ip+port**==和文件信息进行关联
3. `listen()`，本质是设置该socket文件的状态，允许别人来连接我
4. `accept()`，获取新链接到应用层，是以fd为代表的
	- 当有很多个连接连上我们的服务器的时候，OS中会存在大量的连接呢??当然，OS要不要管理这些已经建立好的连接呢??当然。该如何管理呢?﹖先描述，在组织
	- 所谓的”连接“，在OS层面，本质上其实就是一个描述连接的结构体_《文件》
5. `read/write`,本质，就是进行网络通信，但是，-对于用户来讲，相当于我们在进行正常的文件读写
6. `close(fd)`，关闭文件，a．系统层面，释放曾经申请的文件资源，连接资源等。b. 网络层面，通知对方，我的连接已经关闭了!
7. `connect()`，本质是发起链接，在系统层面，就是构建一个请求报文发送过去在网络层面，发起tcp链接的**三次握手**!
8. `close()`, client && server，本质在网络层面，其实就是在进行**四次挥手**!



# 查询网络连接的命令
![[linux常用命令#netstat]]


# 解决TIME_WAIT状态引起的bind失败的方法(作业)
在server的TCP连接没有完全断开之前不允许重新监听, 某些情况下可能是不合理的
- 服务器需要处理非常大量的客户端的连接(每个连接的生存时间可能很短, 但是每秒都有很大数量的客户端来请求).
- 这个时候如果由服务器端主动关闭连接(比如某些客户端不活跃, 就需要被服务器端主动清理掉), 就会产生大量TIME_WAIT连接.
- 由于我们的请求量很大, 就可能导致TIME_WAIT的连接数很多, 每个连接都会占用一个通信五元组(源ip,源端口, 目的ip, 目的端口, 协议). 其中服务器的ip和端口和协议是固定的. 如果新来的客户端连接的ip和端口号和TIME_WAIT占用的链接重复了, 就会出现问题.

使用setsockopt解决 bind error 问题
使用setsockopt()设置socket描述符的  选项SO_REUSEADDR为1, 表示允许创建端口号相同但IP地址不同的多个 
socket描述符
![[Pasted image 20221102213023.png]]

```cpp
#pragma once
#include <iostream>
#include <string>
#include <cstring>
#include <cstdlib>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

using namespace std;
class Sock
{
public:
    static int Socket()
    {
        int sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock < 0)
        {
            cerr << "socket error" << endl;
            exit(2);
        }
        int opt = 1;
        setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));//这里使用了setsockset
        return sock;
    }
    
    static void Bind(int sock, uint16_t port)
    {
        struct sockaddr_in local;
        memset(&local, 0, sizeof(local));
        local.sin_family = AF_INET;
        local.sin_port = htons(port);
        local.sin_addr.s_addr = INADDR_ANY;

        if (bind(sock, (struct sockaddr *)&local, sizeof(local)) < 0)
        {
            cerr << "bind error!" << endl;
            exit(3);
        }
    }

    static void Listen(int sock)
    {
#define NUM 1
        if (listen(sock, NUM) < 0)
        {
            cerr << "listen error !" << endl;
            exit(4);
        }
    }

    static int Accept(int sock)
    {
        struct sockaddr_in peer;
        socklen_t len = sizeof(peer);
        int fd = accept(sock, (struct sockaddr *)&peer, &len);
        if(fd >= 0){
            return fd;
        }
        return -1;
    }

    static void Connect(int sock, std::string ip, uint16_t port)
    {
        struct sockaddr_in server;
        memset(&server, 0, sizeof(server));
        server.sin_family = AF_INET;
        server.sin_port = htons(port);
        server.sin_addr.s_addr = inet_addr(ip.c_str());
        
        if(connect(sock, (struct sockaddr*)&server, sizeof(server)) == 0)
        {
            cout << "Connect Success!" << endl;
        }

        else
        {
            cout << "Connect Failed!" << endl;
            exit(5);
        }
    }
};
```