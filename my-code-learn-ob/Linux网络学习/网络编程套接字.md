# 预备知识
## 理解源IP地址和目的IP地址
源IP地址就是 : 从哪来
目的IP地址就是: 到哪去

## 网络通信的本质
本质上，所有的网络通信，站在普通人的角度，都是人和人之间通信（小白)
技术人员的视角，我们学到的网络通信，==本质是:是**进程间通信**==! !

如：抖音的app客户端(进程) <->抖音服务器(进程)

要进行通信，本质要求：
1. 先找到目标主机
2. 在找到该主机上的服务(进程)


进程具有独立性，进程间通信的前提工作:先得让不同的进程，看到同一份资源!
而这同一份资源，就是 ==**网络**==


# 端口号
我们通过IP找到了目标主机，但是我们怎么找到相应的进程呢？
所以就出现了==**端口号**==，


>端口号(port):==**唯一的标识一台机器上的唯一的一个进程**==!!

我们可以通过端口号找到目标进程，就可以借此进行通信。
![[Pasted image 20221019213353.png]]

==**一个进程可以绑定多个端口号; 但是一个端口号不能被多个进程绑定**==;

## PID   vs   port
既然网络通信的本质就是 进程通信，为什么不使用 PID 而是port 呢？

其实PID就相当于我们现实中的身份证，而在学校中也使用身份证号作为我们的学号时，如果有一天我们的身份证号发生了改变，学校则需要重新对我们的数据进行更改，那样的效率太低下了，所以使用了解耦的方式，由学校自主定制学号(port)，就可以避免了以上的问题。
所以使用port的优势大于PID。


## 认识TCP协议
此处我们先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识; 后面我们再详细讨论TCP的一些细节问题.
- 传输层协议 
- 有连接 
- 可靠传输 
- 面向字节流

## 认识UDP协议
此处我们也是对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识; 后面再详细讨论.
- 传输层协议 
- 无连接 
- 不可靠传输 
- 面向数据报


# 网络字节序
我们已经知道,内存中的多字节数据相对于**内存地址**有**大端**和**小端**之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分,==网络数据流同样有**大端小端**之分== . 那么如何定义网络数据流的地址呢?
- 发送主机通常将发送缓冲区中的数据==按内存地址**从低到高的顺序**发出==;
- 接收主机把从网络上**接到的字节依次保存在接收缓冲区**中,也是==按**内存地址从低到高**的顺序保存==; 
- 因此,**网络数据流的地址**应这样**规定**:==**先发出的数据是低地址,后发出的数据是高地址**==.
- **TCP/IP协议规定**,==网络数据流应采用**大端字节序**,即**低地址高字节**.==
- 不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据; 
- 如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;

![[Pasted image 20221019224406.png]]

为使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。
![[Pasted image 20221019223248.png]]
- 这些函数名很好记,`h`表示`host` , `n`表示`network`, `l` 表示`32位`长整数,`s`表示`16`位短整数。
- 例如`htonl`表示**将32位的长整数从主机字节序转换为网络字节序**,例如将IP地址转换后准备发送。 
- 如果主机是**小端字节序**,这些函数将参数**做相应的大小端转换**然后返回;
- 如果主机是**大端字节序**,这些  **函数不做转换**,将参数原封不动地返回。


# socket编程结构
## socket常见API
``` cpp
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器) 
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr *address, socklen_t address_len);

// 开始监听socket (TCP, 服务器)
int listen(int socket, int backlog); 

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```


## sockaddr结构
socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、IPv6,以及后面要讲的UNIX Domain Socket. 然而, 各种网络协议的地址格式并不相同.
![[Pasted image 20221019223756.png]]
![[Pasted image 20221020121853.png]]
- IPv4和IPv6的地址格式定义在`<netinet/in.h>`中,IPv4地址用`sockaddr_in`结构体表示,包括**16位地址类型**, **16位端口号**和**32位IP地址**.
- IPv4、IPv6地址类型分别定义为常数`AF_INET`、`AF_INET6`. 这样,只要取得某种`sockaddr`结构体的首地址, 不需要知道具体是哪种类型的`sockaddr`结构体,就可以根据地址类型字段确定结构体中的内容. 
- socket API可以都用`struct sockaddr *`类型表示, 在使用的时候需要强制转化成`sockaddr_in`; 这样的好处是程序的通用性, 可以接收IPv4, IPv6, 以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数;
- **IPv6**把**IP地址由32位增加到128位**，从而能够支持更大的地址空间


==**sockaddr结构**==
![[Pasted image 20221020122757.png]]
`sockaddr` 结构用于存储参与（IP）Windows/linux套接字通信的计算机上的一个internet协议（IP）地址。为了统一地址结构的表示方法 ，统一接口函数，使得不同的地址结构可以被`bind()`、`connect()`、`recvfrom()`、`sendto()`等函数调用。
但一般的编程中并不直接对此数据结构进行操作，而使用另一个与之等价的数据结构`sockaddr_in`。这是由于Microsoft TCP/IP套接字开发人员的工具箱仅支持internet地址字段，而实际填充字段的每一部分则遵循`sockaddr_in`数据结构，**两者大小都是16字节，所以二者之间可以进行切换**。


## sockaddr_in 结构
![[Pasted image 20221020122640.png]]

### in_addr结构
![[Pasted image 20221020134040.png]]
`in_addr`用来表示一个IPv4的IP地址. 其实就是一个`32位的整数`;


# socket编程接口
## socket()
![[Pasted image 20221020124234.png]]

>参数解析：
>- ==domain== ：**协议域** ， 对于IPv4, 参数指定为AF_INET。
>	- 这些就是可选参数![[Pasted image 20221020124523.png]]
>- ==type== ：**socket的类型**，流格式套接字(SOCK_STREAM)、数据报格式套接字(SOCK_DGRAM)。
>- ==protocol== ：**协议**，，当protocol为0时，会自动选择type类型对应的默认协议。
>- ==返回值== ：如果成功的话,就像`open()`一样返回一个[[Linux IO操作#文件描述符 `fd`|文件描述符]]，调用出错则返回`-1`.

## bind()
**介绍：** 服务器程序所**监听的网络地址**和**端口号**通常是**固定不变**的,客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接; 服务器需要调用`bind`绑定一个固定的网络地址和端口号,`bind`函数的功能就是**将参数sockfd和addr绑定在一起**。
![[Pasted image 20221020125259.png]]

>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==addr==：sockaddr结构体
>- ==addrlen==：`struct sockaddr *`是一个通用指针类型,addr参数实际上可以接受多种协议的sockaddr结构体,而它们的长度各不相同,所以需要第三个参数addrlen指定结构体的长度
>- ==返回值==： `bind()`成功返回0,失败返回-1

## recvfrom
从socket 中接收消息。
![[Pasted image 20221020130239.png]]
>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==buf==：接收数据的容器。
>- ==len==：接收数据容器的大小。
>- ==src_addr==：sockaddr结构体
>- ==addrlen==：`struct sockaddr *`是一个通用指针类型,addr参数实际上可以接受多种协议的sockaddr结构体,而它们的长度各不相同,所以需要第三个参数addrlen指定结构体的长度
>- ==返回值==： 失败返回-1,并带回错误码。

## sendto()
发送消息到socket中
![[Pasted image 20221020130012.png]]
>函数参数：
>- ==sockfd==：创建的套接字，即socket函数返回的文件描述符，唯一标识一个socket
>- ==buf==：接收数据的容器。
>- ==len==：接收数据容器的大小。
>- ==dest_addr==：sockaddr结构体
>- ==addrlen==：
>- ==返回值==： 失败返回-1,并带回错误码。


## IP地址转换接口
`in_addr_t inet_addr(const char* cp)`         
将字符串点分十进制ip地址转换为整型网络字节序ip地址   `192.168.2.2  ->   0xc0a80202`


`char *inet_ntoa(struct in_addr  in)`            将整型网络字节序ip地址转换为字符串点分十进制ip地址   `in.s_addr=0xc0a80202   ->   192.168.2.2`

# 初步实现UDP(不完善)
```cpp

```