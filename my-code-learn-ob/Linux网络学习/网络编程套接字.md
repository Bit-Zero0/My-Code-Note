# 预备知识
## 理解源IP地址和目的IP地址
源IP地址就是 : 从哪来
目的IP地址就是: 到哪去

## 网络通信的本质
本质上，所有的网络通信，站在普通人的角度，都是人和人之间通信（小白)
技术人员的视角，我们学到的网络通信，==本质是:是**进程间通信**==! !

如：抖音的app客户端(进程) <->抖音服务器(进程)

要进行通信，本质要求：
1. 先找到目标主机
2. 在找到该主机上的服务(进程)


进程具有独立性，进程间通信的前提工作:先得让不同的进程，看到同一份资源!
而这同一份资源，就是 ==**网络**==


# 端口号
我们通过IP找到了目标主机，但是我们怎么找到相应的进程呢？
所以就出现了==**端口号**==，


>端口号(port):==**唯一的标识一台机器上的唯一的一个进程**==!!

我们可以通过端口号找到目标进程，就可以借此进行通信。
![[Pasted image 20221019213353.png]]

==**一个进程可以绑定多个端口号; 但是一个端口号不能被多个进程绑定**==;

## PID   vs   port
既然网络通信的本质就是 进程通信，为什么不使用 PID 而是port 呢？

其实PID就相当于我们现实中的身份证，而在学校中也使用身份证号作为我们的学号时，如果有一天我们的身份证号发生了改变，学校则需要重新对我们的数据进行更改，那样的效率太低下了，所以使用了解耦的方式，由学校自主定制学号(port)，就可以避免了以上的问题。
所以使用port的优势大于PID。


# 认识TCP协议
此处我们先对TCP(Transmission Control Protocol 传输控制协议)有一个直观的认识; 后面我们再详细讨论TCP的一些细节问题.
- 传输层协议 
- 有连接 
- 可靠传输 
- 面向字节流

# 认识UDP协议
此处我们也是对UDP(User Datagram Protocol 用户数据报协议)有一个直观的认识; 后面再详细讨论.
- 传输层协议 
- 无连接 
- 不可靠传输 
- 面向数据报


# 网络字节序
我们已经知道,内存中的多字节数据相对于**内存地址**有**大端**和**小端**之分, 磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分,==网络数据流同样有**大端小端**之分== . 那么如何定义网络数据流的地址呢?
- 发送主机通常将发送缓冲区中的数据==按内存地址**从低到高的顺序**发出==;
- 接收主机把从网络上**接到的字节依次保存在接收缓冲区**中,也是==按**内存地址从低到高**的顺序保存==; 
- 因此,**网络数据流的地址**应这样**规定**:==**先发出的数据是低地址,后发出的数据是高地址**==.
- **TCP/IP协议规定**,==网络数据流应采用**大端字节序**,即**低地址高字节**.==
- 不管这台主机是大端机还是小端机, 都会按照这个TCP/IP规定的网络字节序来发送/接收数据; 
- 如果当前发送主机是小端, 就需要先将数据转成大端; 否则就忽略, 直接发送即可;

![[Pasted image 20221019224406.png]]

为使网络程序具有可移植性,使同样的C代码在大端和小端计算机上编译后都能正常运行,可以调用以下库函数做网络字节序和主机字节序的转换。
![[Pasted image 20221019223248.png]]
- 这些函数名很好记,`h`表示`host` , `n`表示`network`, `l` 表示`32位`长整数,`s`表示`16`位短整数。
- 例如`htonl`表示**将32位的长整数从主机字节序转换为网络字节序**,例如将IP地址转换后准备发送。 
- 如果主机是**小端字节序**,这些函数将参数**做相应的大小端转换**然后返回;
- 如果主机是**大端字节序**,这些  **函数不做转换**,将参数原封不动地返回。


# socket编程接口
## socket常见API
``` cpp
// 创建 socket 文件描述符 (TCP/UDP, 客户端 + 服务器) 
int socket(int domain, int type, int protocol);

// 绑定端口号 (TCP/UDP, 服务器)
int bind(int socket, const struct sockaddr *address, socklen_t address_len);

// 开始监听socket (TCP, 服务器)
int listen(int socket, int backlog); 

// 接收请求 (TCP, 服务器)
int accept(int socket, struct sockaddr* address, socklen_t* address_len);

// 建立连接 (TCP, 客户端)
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```


## sockaddr结构
socket API是一层抽象的网络编程接口,适用于各种底层网络协议,如IPv4、IPv6,以及后面要讲的UNIX Domain Socket. 然而, 各种网络协议的地址格式并不相同.
![[Pasted image 20221019223756.png]]