# IP 基本认识
IP 在 TCP/IP 参考模型中处于第三层，也就是**网络层**。

网络层的主要作用是：**实现主机与主机之间的通信，也叫点对点（end to end）通信。**
![[Pasted image 20221102225411.png]]
> 网络层与数据链路层有什么关系呢？

有的小伙伴分不清 IP（网络层） 和 MAC （数据链路层）之间的区别和关系。

其实很容易区分，在上面我们知道 IP 的作用是主机之间通信用的，而 **MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。**

举个生活的栗子，小林要去一个很远的地方旅行，制定了一个行程表，其间需先后乘坐飞机、地铁、公交车才能抵达目的地，为此小林需要买飞机票，地铁票等。

飞机票和地铁票都是去往特定的地点的，每张票只能够在某一限定区间内移动，此处的「区间内」就如同通信网络中数据链路。

在区间内移动相当于数据链路层，充当区间内两个节点传输的功能，区间内的出发点好比源 MAC 地址，目标地点好比目的 MAC 地址。

整个旅游行程表就相当于网络层，充当远程定位的功能，行程的开始好比源 IP，行程的终点好比目的 IP 地址。
![[Pasted image 20221102225428.png]]
如果小林只有行程表而没有车票，就无法搭乘交通工具到达目的地。相反，如果除了车票而没有行程表，恐怕也很难到达目的地。因为小林不知道该坐什么车，也不知道该在哪里换乘。

因此，只有两者兼备，既有某个区间的车票又有整个旅行的行程表，才能保证到达目的地。与此类似，**计算机网络中也需要「数据链路层」和「网络层」这个分层才能实现向最终目标地址的通信。**

还有重要一点，旅行途中我们虽然不断变化了交通工具，但是旅行行程的起始地址和目的地址始终都没变。

其实，在网络中数据包传输中也是如此，**源IP地址和目标IP地址在传输过程中是不会变化的（前提：没有使用 NAT 网络），只有源 MAC 地址和目标 MAC 一直在变化。**


# IP 地址的基础知识
在 TCP/IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。

IP 地址（IPv4 地址）由 `32` 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。

而人类为了方便记忆采用了**点分十进制**的标记方式，也就是将 32 位 IP 地址以每 8 位为组，共分为 `4` 组，每组以「`.`」隔开，再将每组转换成十进制。
![[Pasted image 20221102225503.png]]

那么，IP 地址最大值也就是
![[Pasted image 20221102225524.png]]

也就说，最大允许 43 亿台计算机连接到网络。

实际上，IP 地址并不是根据主机台数来配置的，而是以网卡。像服务器、路由器等设备都是有 2 个以上的网卡，也就是它们会有 2 个以上的 IP 地址。
因此，让 43 亿台计算机全部连网其实是不可能的，更何况 IP 地址是由「网络标识」和「主机标识」这两个部分组成的，所以实际能够连接到网络的计算机个数更是少了很多。

> 可能有的小伙伴提出了疑问，现在不仅电脑配了 IP， 手机、IPad 等电子设备都配了 IP 呀，照理来说肯定会超过 43 亿啦，那是怎么能够支持这么多 IP 的呢？

因为会根据一种可以更换 IP 地址的技术 `NAT`，使得可连接计算机数超过 43 亿台。 `NAT` 技术后续会进一步讨论和说明。

## IP协议头格式
![[Pasted image 20221103123116.png]]
- ==4位版本号(version)==: 指定IP协议的版本, 对于IPv4来说, 就是4.
- ==4位头部长度(header length)==: IP头部的长度是多少个32bit, 也就是 length * 4 的字节数. 4bit表示最大的数字是15, 因此IP头部最大长度是60字节.
- ==8位服务类型(Type Of Service)==: 3位优先权字段(已经弃用), **4位TOS字段**, 和**1位保留字段(必须置为0)**. ==4位TOS分别表示: **最小延时, 最大吞吐量, 最高可靠性, 最小成本**. 这**四者相互冲突, 只能选择一个**==. 对于ssh/telnet这样的应用程序, 最小延时比较重要; 对于ftp这样的程序, 最大吞吐量比较重要.
- ==16位总长度(total length)==: IP数据报整体占多少个字节. **16位总长度 =4位头部长度 + 数据长度**。IP不是面向字节流的，收到的是一个个数据包，存在粘包问题，需要自己区分边界！TCP是面向字节流的，只考虑字节，区分边界的任务交给应用层来做。
	- 因此，在解包的时候要同时使用4位头部长度 和 16位总长度。先通过4位首部长度去除报头，数据长度 = 16位总长度 -  4位头部长度，然后通过得到的数据长度取出第一个报文的有效载荷。
- ==16位标识(id)==: 唯一的标识主机发送的报文. 如果IP报文在数据链路层被分片了, 那么每一个片里面的这个id都是相同的.
- ==3位标志字段==: **第一位保留**(保留的意思是现在不用, 但是还没想好说不定以后要用到). **第二位置为1表示禁止分片**, 这时候如果报文长度超过MTU, IP模块就会丢弃报文. **第三位表示"更多分片"**, 如果分片了的话,最后一个分片置为1, 其他是0. 类似于一个结束标记.
- ==13位分片偏移(framegament oﬀset)==: **是分片相对于原始IP报文开始处的偏移. 其实就是在表示当前分片在原报文中处在哪个位置. 实际偏移的字节数是这个值 * 8 得到的**. 因此, 除了最后一个报文之外, 其他报文的长度必须是8的整数倍(否则报文就不连续了).
- ==8位生存时间(Time To Live, **TTL**)==: **数据报到达目的地的最大报文跳数. 一般是64. 每次经过一个路由, TTL-= 1, 一直减到0还没到达, 那么就丢弃了. 这个字段主要是用来防止出现路由循环**
- ==8位协议==: 表示上层协议的类型;如：UDP 或 TCP
- ==16位头部校验和==: 使用CRC进行校验, 来鉴别头部是否损坏. 
- ==32位源地址和32位目标地址==: 表示发送端和接收端.
- ==选项字段(不定长, 最多40字节)==: 略


## IP 地址的分类
IP地址分为两个部分, **网络号**和**主机号**
- 网络号: 保证相互连接的两个网段具有不同的标识;
- 主机号: 同一网段内, 主机之间具有相同的网络号, 但是必须有不同的主机号;
![[Pasted image 20221103125336.png]]
- 不同的子网其实就是把网络号相同的主机放到一起.
- 如果在子网中新增一台主机, 则这台主机的网络号和这个子网的网络号一致, 但是主机号必须不能和子网中的其他主机重复.

通过合理设置主机号和网络号, 就可以保证在相互连接的网络中, 每台主机的IP地址都不相同. 

>==那么问题来了, 手动管理子网内的IP, 是一个相当麻烦的事情.==
>有一种技术叫做**DHCP**, 能够**自动的给子网内新增主机节点分配IP地址**, 避免了手动管理IP的不便. 
>一般的路由器都带有DHCP功能. 因此路由器也可以看做一个DHCP服务器.

过去曾经提出一种划分网络号和主机号的方案, 把所有IP 地址分为五类, 如下图所示(该图出  自[TCP/IP])。
IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。
![[Pasted image 20221102225611.png]]
上图中黄色部分为分类号，用以区分 IP 地址类别。

> 什么是 A、B、C 类地址？

其中对于 A、B、C 类主要分为两个部分，分别是**网络号和主机号**。这很好理解，好比小林是 A 小区 1 栋 101 号，你是 B 小区 1 栋 101 号。

我们可以用下面这个表格， 就能很清楚的知道 A、B、C 分类对应的地址范围、最大主机个数。
![[Pasted image 20221102225621.png]]

> A、B、C 分类地址最大主机个数是如何计算的呢？

最大主机个数，就是要看主机号的位数，如 C 类地址的主机号占 8 位，那么 C 类地址的最大主机个数：
![[Pasted image 20221102225638.png]]
为什么要减 2 呢？
因为在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。
![[Pasted image 20221102225654.png]]
-   主机号全为 1 指定某个网络下的所有主机，用于广播
-   主机号全为 0 指定某个网络

因此，在分配过程中，应该去掉这两种情况。

> 广播地址用于什么？

广播地址用于在**同一个链路中相互连接的主机之间发送数据包**。

学校班级中就有广播的例子，在准备上课的时候，通常班长会喊：“上课， 全体起立！”，班里的同学听到这句话是不是全部都站起来了？这个句话就有广播的含义。

当主机号全为 1 时，就表示该网络的广播地址。例如把 `172.20.0.0/16` 用二进制表示如下：

10101100.00010100.00000000.00000000

将这个地址的**主机部分全部改为 1**，则形成广播地址：

10101100.00010100.`11111111.11111111`

再将这个地址用十进制表示，则为 `172.20.255.255`。

广播地址可以分为本地广播和直接广播两种。

-   **在本网络内广播的叫做本地广播**。例如网络地址为 192.168.0.0/24 的情况下，广播地址是 192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。
-   **在不同网络之间的广播叫做直接广播**。例如网络地址为 192.168.0.0/24 的主机向 192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。
![[Pasted image 20221102225709.png]]


> 什么是 D、E 类地址？

而 D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于**多播**，E 类是预留的分类，暂时未使用。
![[Pasted image 20221102225725.png]]

> 多播地址用于什么？

多播用于**将包发送给特定组内的所有主机。**

还是举班级的栗子，老师说：“最后一排的同学，上来做这道数学题。”，老师指定的是最后一排的同学，也就是多播的含义了。

由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。
![[Pasted image 20221102225739.png]]
多播使用的 D 类地址，其前四位是 `1110` 就表示是多播地址，而剩下的 28 位是多播的组编号。

从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围，其划分为以下三类：

-   224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。
-   224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。
-   239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。

> IP 分类的优点

不管是路由器还是主机解析到一个 IP 地址时候，我们判断其 IP 地址的首位是否为 0，为 0 则为 A 类地址，那么就能很快的找出网络地址和主机地址。

其余分类判断方式参考如下图：
![[Pasted image 20221102225831.png]]
所以，这种分类地址的优点就是**简单明了、选路（基于网络地址）简单**。

> IP 分类的缺点

==**缺点一**==
**同一网络下没有地址层次**，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就**缺少地址的灵活性**。


==**缺点二**==
A、B、C类有个尴尬处境，就是**不能很好的与现实网络匹配**。

-   C 类地址能包含的最大主机数量实在太少了，只有 254 个，估计一个网吧都不够用。
-   而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。

这两个缺点，都可以在 `CIDR` 无分类地址解决。

### 无分类地址 CIDR
正因为 IP 分类存在许多缺点，所以后面提出了**无分类地址**的方案，即 `CIDR`。

这种方式不再有分类地址的概念，32 比特的 IP 地址被划分为两部分，前面是**网络号**，后面是**主机号**。

> 怎么划分网络号和主机号的呢？
表示形式 `a.b.c.d/x`，其中 `/x` 表示前 x 位属于**网络号**， x 的范围是 `0 ~ 32`，这就使得 IP 地址更加具有灵活性。

比如 10.100.122.2/24，这种地址表示形式就是 CIDR，/24 表示前 24 位是网络号，剩余的 8 位是主机号。
![[Pasted image 20221103130214.png]]
还有另一种划分网络号与主机号形式，那就是**子网掩码**，掩码的意思就是掩盖掉主机号，剩余的就是网络号。

**将子网掩码和 IP 地址按位计算 AND，就可得到网络号。**
![[Pasted image 20221103130325.png]]

> ==为什么要分离网络号和主机号？==
>因为两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。

路由器寻址工作中，也就是通过这样的方式来找到对应的网络号的，进而把数据包转发给对应的网络内。
![[Pasted image 20221103130342.png]]

> ==怎么进行子网划分？==
>在上面我们知道可以通过子网掩码划分出网络号和主机号，那实际上子网掩码还有一个作用，那就是**划分子网**。

**子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址**。形式如下：
![[Pasted image 20221103130518.png]]
-   未做子网划分的 ip 地址：网络地址＋主机地址
-   做子网划分后的 ip 地址：网络地址＋（子网网络地址＋子网主机地址）

假设对 C 类地址进行子网划分，网络地址 192.168.1.0，使用子网掩码 255.255.255.192 对其进行子网划分。

C 类地址中前 24 位是网络号，最后 8 位是主机号，根据子网掩码可知**从 8 位主机号中借用 2 位作为子网号**。
![[Pasted image 20221103130540.png]]
由于子网网络地址被划分成 2 位，那么子网地址就有 4 个，分别是 00、01、10、11，具体划分如下图：
![[Pasted image 20221103130555.png]]
划分后的 4 个子网如下表格：
![[Pasted image 20221103130613.png]]


### 公有 IP 地址与私有 IP 地址
在 A、B、C 分类地址，实际上有分公有 IP 地址和私有 IP 地址。
![[Pasted image 20221103130740.png]]

平时我们办公室、家里、学校用的 IP 地址，一般都是私有 IP 地址。因为这些地址允许组织内部的 IT 人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有 IP 地址和我学校的可以是一样的。

就像每个小区都有自己的楼编号和门牌号，你小区家可以叫 1 栋 101 号，我小区家也可以叫 1 栋 101，没有任何问题。但一旦出了小区，就需要带上中山路 666 号（公网 IP 地址），是国家统一分配的，不能两个小区都叫中山路 666。

所以，公有 IP 地址是有个组织统一分配的，假设你要开一个博客网站，那么你就需要去申请购买一个公有 IP，这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一。
![[Pasted image 20221103130752.png]]

> 公有 IP 地址由谁管理呢？
私有 IP 地址通常是内部的 IT 人员管理，公有 IP 地址是由 `ICANN` 组织管理，中文叫「互联网名称与数字地址分配机构」。

IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。
![[Pasted image 20221103130840.png]]
-   ARIN 北美地区
-   LACNIC 拉丁美洲和一些加勒比群岛
-   RIPE NCC 欧洲、中东和中亚
-   AfriNIC 非洲地区
-   APNIC 亚太地区

其中，在中国是由 **CNNIC** 的机构进行管理，它是中国国内唯一指定的全局 IP 地址管理的组织。

## IP 地址与路由控制
IP地址的**网络地址**这一部分是用于进行路由控制。

路由控制表中记录着网络地址与下一步应该发送至路由器的地址。在主机和路由器上都会有各自的路由器控制表。

在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有**相同网络地址**的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择相同位数最多的网络地址，也就是最长匹配。

下面以下图的网络链路作为例子说明：
![[Pasted image 20221103131021.png]]
1.  主机 A 要发送一个 IP 包，其源地址是 `10.1.1.30` 和目标地址是 `10.1.2.10`，由于没有在主机 A 的路由表找到与目标地址 `10.1.2.10` 相同的网络地址，于是包被转发到默认路由（路由器 `1` ）
2.  路由器 `1` 收到 IP 包后，也在路由器 `1` 的路由表匹配与目标地址相同的网络地址记录，发现匹配到了，于是就把 IP 数据包转发到了 `10.1.0.2` 这台路由器 `2`
3.  路由器 `2` 收到后，同样对比自身的路由表，发现匹配到了，于是把 IP 包从路由器 `2` 的 `10.1.2.1` 这个接口出去，最终经过交换机把 IP 数据包转发到了目标主机

> 环回地址是不会流向网络

环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。

计算机使用一个特殊的 IP 地址 **127.0.0.1 作为环回地址**。与该地址具有相同意义的是一个叫做 `localhost` 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。

## IP 分片与重组
每种数据链路的最大传输单元 `MTU` 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是 1500 字节等。

每种数据链路的 MTU 之所以不同，是因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。

其中，我们最常见数据链路是以太网，它的 MTU 是 `1500` 字节。

那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。

经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。

假设发送方发送一个 4000 字节的大数据报，若要传输在以太网链路，则需要把数据报分片成 3 个小数据报进行传输，再交由接收方重组成大数据报。
![[Pasted image 20221103131049.png]]
在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 TCP 引入了 `MSS` 也就是在 TCP 层进行分片不由 IP 层分片，那么对于 UDP 我们尽量不要发送一个大于 `MTU` 的数据报文。



# IP协议相关技术
## ARP
学习之前最好看一下[[网络基础2#以太网帧格式]];

**ARP不是一个单纯的数据链路层的协议, 而是一个介于数据链路层和网络层之间的协议;**

在传输一个 IP 数据报的时候，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。然而，网络层的下一层是数据链路层，所以我们还要知道「下一跳」的 MAC 地址。

由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 **ARP 协议**，求得下一跳的 MAC 地址。

> 那么 ARP 又是如何知道对方 MAC 地址的呢？
简单地说，ARP 是借助 **ARP 请求与 ARP 响应**两种类型的包确定 MAC 地址的。
![[Pasted image 20221103131304.png]]
-   主机会通过**广播发送 ARP 请求**，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。
-   当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 **ARP 响应包**返回给主机。

操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。

不过，MAC 地址的缓存是有一定期限的，超过这个期限，缓存的内容将被清除。

> RARP 协议你知道是什么吗？

ARP 协议是已知 IP 地址求 MAC 地址，那 RARP 协议正好相反，它是**已知 MAC 地址求 IP 地址**。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。

通常这需要架设一台 `RARP` 服务器，在这个服务器上注册设备的 MAC 地址及其 IP 地址。然后再将这个设备接入到网络，接着：

-   该设备会发送一条「我的 MAC 地址是XXXX，请告诉我，我的IP地址应该是什么」的请求信息。
-   RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备，IP地址为 XXXX」的信息给这个设备。

最后，设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址。
![[Pasted image 20221103131319.png]]

###  ARP协议的作用
**ARP协议建立了主机 IP地址  和 MAC地址  的映射关系**.
>- 在网络通讯时,源主机的应用程序知道目的主机的IP地址和端口号,却不知道目的主机的硬件地址; 
>- 数据包首先是被网卡接收到再去处理上层协议的,如果接收到的数据包的硬件地址与本机不符,则直接丢弃;
>- 因此在通讯前必须获得目的主机的硬件地址;

![[Pasted image 20221103132335.png]]
- 源主机发出**ARP请求**,询问“IP地址是`192.168.0.1`的主机的硬件地址是多少”, 并将这个请求广播到本地网段(以太网帧首部的硬件地址填`FF:FF:FF:FF:FF:FF`表示广播);
- 目的主机接收到广播的ARP请求,发现其中的IP地址与本机相符,则发送一个ARP应答数据包给源主机,将自己的硬件地址填写在应答包中;
- 每台主机都维护一个ARP缓存表,可以用`arp -a`命令查看。缓存表中的表项有过期时间(一般为20分钟),如果20分钟内没有再次使用某个表项,则该表项失效,下次还要发ARP请求来获得目的主机的硬件地址
![[Pasted image 20221103132420.png]]

想一想,为什么要有缓存表? 为什么表项要有过期时间而不是一直有效? 

再想一想, 结合我们刚才讲的工作流程, ARP的数据报应该是一个什么样的格式?

### ARP数据报的格式
![[Pasted image 20221103132502.png]]
- 注意到**源MAC地址**、**目的MAC地址**在以太网首部和`ARP`请求中各出现一次,对于链路层为以太网的情况是多余的,但如果链路层是其它类型的网络则有可能是必要的。
- ==硬件类型==指链路层网络类型,**1**为以太网; 
- ==协议类型==指要转换的地址类型,`0x0800`为**IP地址**; 
- 硬件地址长度对于以太网地址为6字节; 
- 协议地址长度对于和IP地址为4字节;
- ==op字段为**1**表示ARP请求,op字段为**2**表示ARP应答==。


### ARP数据包的发送过程
主机A  想要获得 主机B 的MAC地址
A 发送 ARP请求 给 B
A发送的 ARP请求协议报格式如下
![[Pasted image 20221105220607.png]]

当B收到ARP协议报后，首要关注的是op字段，先看op字段是分析ARP协议报是请求还是响应，之后查看该协议报的目的IP是否是本机，不是本机则丢弃该报文，是本机则填写本机的MAC地址。
![[Pasted image 20221105220409.png]]

此时 A收到报文后，首要关注的也是op ， 随后查看目的IP地址是否是自己，是则解包提取出主机B的mAC，此时就知道了B的MAC地址了。


## DNS
我们在上网的时候，通常使用的方式是域名，而不是 IP 地址，因为域名方便人类记忆。

那么实现这一技术的就是 **DNS 域名解析**，DNS 可以将域名网址自动转换为具体的 IP 地址。

> 域名的层级关系
DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。

毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。

所以域名的层级关系类似一个树状结构：
-   根 DNS 服务器
-   顶级域 DNS 服务器（com）
-   权威 DNS 服务器（server.com）
![[Pasted image 20221105221037.png]]
根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。

因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

> 域名解析的工作流程

浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 `hosts`，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：
1.  客户端首先会发出一个 DNS 请求，问 `www.server.com` 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。
2.  本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 `www.server.com`，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 `www.server.com` 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3.  根 DNS 收到来自本地 DNS 的请求后，发现后置是`.com`，说：“`www.server.com` 这个域名归 .com 区域管理”，我给你 `.com` 顶级域名服务器地址给你，你去问问它吧。”
4.  本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 `www.server.com` 的 IP 地址吗？”
5.  顶级域名服务器说：“我给你负责 `www.server.com` 区域的权威 DNS 服务器的地址，你去问它应该能问到”。
6.  本地 DNS 于是转向问权威 DNS 服务器：“老三，`www.server.com`对应的IP是啥呀？” `server.com` 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。
7.  权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8.  本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。
![[Pasted image 20221105221224.png]]
DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，**只指路不带路**。


## ICMP
CMP协议是一个  网络层协议
一个新搭建好的网络, 往往需要先进行一个简单的测试, 来验证网络是否畅通; 但是IP协议并不提供可靠传输. 如果丢包了, IP协议并不能通知传输层是否丢包以及丢包的原因.

### ICMP功能
- 确认IP包是否成功到达目标地址. 
- 通知在发送过程中IP包被丢弃的原因.
- ICMP也是基于IP协议工作的. 但是它并不是传输层的功能, 因此人们仍然把它归结为网络层协议; 
- ICMP只能搭配IPv4使用. 如果是IPv6的情况下, 需要是用ICMPv6;

![[Pasted image 20221105224634.png]]
如上图例子，主机 `A` 向主机 `B` 发送了数据包，由于某种原因，途中的路由器 `2` 未能发现主机 `B` 的存在，这时，路由器 `2` 就会向主机 `A` 发送一个 `ICMP` 目标不可达数据包，说明发往主机 `B` 的包未能成功。

ICMP 的这种通知消息会使用 `IP` 进行发送 。

因此，从路由器 `2` 返回的 ICMP 包会按照往常的路由控制先经过路由器 `1` 再转发给主机 `A` 。收到该 ICMP 包的主机 `A` 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因。
![[Pasted image 20221105225147.png]]


### ICMP 类型
ICMP 大致可以分为两大类：
-   一类是用于诊断的查询消息，也就是「**查询报文类型**」
-   另一类是通知出错原因的错误消息，也就是「**差错报文类型**」


### ping命令
查询报文类型的使用

![[Pasted image 20221105225626.png]]
- 注意, 此处 ping 的是域名, 而不是url! 一个域名可以通过DNS解析成IP地址.
- ping命令不光能验证网络的连通性, 同时也会统计响应时间和TTL(IP包中的Time To Live, 生存周期). 
- ping命令会先发送一个 ICMP Echo Request给对端;
- 对端接收到之后, 会返回一个ICMP Echo Reply;

![[Pasted image 20221105225709.png]]


#### 一个值得注意的坑
有些面试官可能会问: telnet是23端口, ssh是22端口, 那么ping是什么端口? 
千万注意!!! 这是面试官的圈套

> ping命令基于ICMP, 是在网络层. 而端口号, 是传输层的内容. 在ICMP中根本就不关注端口号这样的信息.


### traceroute命令
也是基于ICMP协议实现, 能够打印出可执行程序主机, 一直到目标主机之前经历多少路由器.

![[Pasted image 20221105225917.png]]


## NAT
之前我们讨论了, IPv4协议中, IP地址数量不充足的问题
NAT技术当前解决IP地址不够用的主要手段, 是路由器的一个重要功能;
>- NAT能够将私有IP对外通信时转为全局IP. 也就是就是一种将私有IP和全局IP相互转化的技术方法: 
>- 很多学校, 家庭, 公司内部采用每个终端设置私有IP, 而在路由器或必要的服务器上设置全局IP; 
>- 全局IP要求唯一, 但是私有IP不需要; 在不同的局域网中出现相同的私有IP是完全不影响的;

IPv4 的地址是非常紧缺的，在前面我们也提到可以通过无分类地址来减缓 IPv4 地址耗尽的速度，但是互联网的用户增速是非常惊人的，所以 IPv4 地址依然有被耗尽的危险。

于是，提出了一种**网络地址转换 NAT** 的方法，再次缓解了 IPv4 地址耗尽的问题。

简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。
![[Pasted image 20221105230131.png]]
> 那不是 N 个私有 IP 地址，你就要 N 个公有 IP 地址？这怎么就缓解了 IPv4 地址耗尽的问题？这不瞎扯吗？

确实是，普通的 NAT 转换没什么意义。

由于绝大多数的网络应用都是使用传输层协议 TCP 或 UDP 来传输数据的。

因此，可以把 IP 地址 + 端口号一起进行转换。

这样，就用一个全球 IP 地址就可以了，这种转换技术就叫**网络地址与端口转换 NAPT。**

很抽象？来，看下面的图解就能瞬间明白了。
![[Pasted image 20221105230352.png]]
图中有两个客户端 192.168.1.10 和 192.168.1.11 同时与服务器 183.232.231.172 进行通信，并且这两个客户端的本地端口都是 1025。

此时，**两个私有 IP 地址都转换 IP 地址为公有地址 120.229.175.121，但是以不同的端口号作为区分。**

于是，生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。

这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。

### 三种方式下IP转化过程
NAT服务器有两个网卡，一个连接内部网络，一个连接外部网络，只有在内部网络访问外部网络时，会进行地址转换。在NAT服务器内部有一张NAT转换表，里面存储着个IP地址之间的对应信息。

#### （1）静态转换
>1. 首先，当内网终端要访问外网服务器时，会先将请求发送给NAT服务器；
>2. NAT服务器接收到请求后，根据接收到的数据包检查NAT表；
>3. 如果已为该地址配置了静态地址转换，NAT服务器就使用对应的公网IP地址转发数据包，否则，NAT服务器不对地址进行转换，直接将数据包丢弃；
>4. Internet主机接收到请求之后，会将应答信息返回给端口NAT服务器；
>5. 当NAT服务器接收到来自Internet上的主机返回的数据包后，检查静态NAT表。如果NAT表中存在匹配的映射项，则将目标地址转换为相应的内网IP，并将数据包转发给内网主机。如果不存在匹配映射项，则将数据包丢弃；

#### （2）动态转换
>动态转换的过程和静态转换差不多，只是其转换成对应的合法公有IP地址是不确定的，也就是随机分配的；

#### （3）端口多路复用
>1. 当内网主机需要与Internet建立连接时，首先将请求发送到端口NAT服务器。NAT服务器接收到请求后，根据接收到的数据包，检查端口NAT映射表；如果还没有为该内网主机建立地址转换映射项，则NAT服务器会创建一个会话，并给该会话分配一个端口。之后将源地址及端口改为企业公网IP地址及相应的端口，发送数据包到Internet主机上；
>2. Internet主机接收到信息后，将应答信息返回给端口NAT服务器；
>3. 当端口NAT服务器接收到应答信息后，检查端口NAT映射表。如果端口NAT表存在匹配的映射项，则将目标地址及端口转换为对应的内网IP及端口，将数据包转发给内网主机。如果不存在匹配映射项，就将数据包丢弃；


### NAT 那么牛逼，难道就没缺点了吗？
当然有缺陷，肯定没有十全十美的方案。

由于 NAT/NAPT 都依赖于自己的转换表，因此会有以下的问题：
-   外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。
-   转换表的生成与转换操作都会产生性能开销。
-   通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。


### 如何解决 NAT 潜在的问题呢？
解决的方法主要有两种方法。

#### 第一种就是改用 IPv6
IPv6 可用范围非常大，以至于每台设备都可以配置一个公有 IP 地址，就不搞那么多花里胡哨的地址转换了，但是 IPv6 普及速度还需要一些时间。

#### 第二种 NAT 穿透技术
NAT 穿越技术拥有这样的功能，它能够让网络应用程序主动发现自己位于 NAT 设备之后，并且会主动获得 NAT 设备的公有 IP，并为自己建立端口映射条目，注意这些都是 NAT设备后的应用程序自动完成的。

也就是说，在 NAT 穿透技术中，NAT设备后的应用程序处于主动地位，它已经明确地知道 NAT 设备要修改它外发的数据包，于是它主动配合 NAT 设备的操作，主动地建立好映射，这样就不像以前由 NAT 设备来建立映射了。

说人话，就是客户端主动从 NAT 设备获取公有 IP 地址，然后自己建立端口映射条目，然后用这个条目对外通信，就不需要 NAT 设备来进行转换了。

### NAT和代理服务器
#### 代理服务器
#####  代理服务器简介
>代理服务器是一种特殊的网络服务，允许一个网络终端（一般为客户端）与另一个网络终端（一般为服务器）进行非直接的连接。一些网关，路由器具备网络代理功能。

##### 代理服务器工作原理
>1. 客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。
>2. 在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接返回缓存了的资源。
>3. 一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。

##### 代理服务器的分类
==**HTTP代理：**==
www连接请求或在浏览网页上下载数据均采用HTTP代理，其通常绑定在代理服务器的80、3128和8080等端口上。

==**socks代理：**==
采用socks协议的代理服务器就是socks服务器。socks 不要求应用程序遵循特定的操作系统平台，socks 代理与应用层代理、HTTP层代理不同，socks 代理只是简单地传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。所以，socks代理比其他应用层代理要快得多。它通常绑定在代理服务器的1080端口上。

==**VPN代理：**==
指在共用网络上建立专用网络的技术。称为虚拟网主要是因为整个VPN网络的任意两个结点之间的连接并没有传统专网建设所需的点到点的物理链路，而是架构在公用网络服务商ISP所提供的网络平台之上的逻辑网络。
用户的数据是通过ISP在公共网络（Internet）中建立的逻辑隧道（Tunnel），即点到点的虚拟专线进行传输的。通过相应的加密和认证技术来保证用户内部网络数据在公网上安全传输，从而真正实现网络数据

==**FTP代理：**==
能够代理客户机上的FTP软件访问FTP服务器

==**POP3代理：**==
代理客户机上的邮件软件用POP3方式收发邮件


#### NAT技术和代理服务器的区别
**（1） 在工作层面上讲**：
NAT技术工作在网络层，在此方式下，客户端只需设置自己的网关就可以使用。代理服务器工作在应用层，需要为每个协议指定代理服务器。

**（2）在应用层面上讲**：
NAT技术是网络基础设备之一，解决的是IP不足的问题；代理服务器则具体到了应用层上的协议，会增加一些额外的管理功能和缓冲功能；

**（3）在使用范围上讲**：
NAT做局域网的出口部署，而代理服务器则可以应用于局域网，广域网，也可以跨网。

**（4）在工作方式上讲**：
NAT大多数情况下，仅修改数据包中的地址和端口，后记录对应关系后把数据转发出去，而代理服务器会先分析数据包的内容，弄清楚要做什么，后以自己的身份来“代理”完成这个请求，并将结果发送回客户端；

注：NAT == 货运码头，管你是啥货，只管发就是了；
代理服务器 == 代理商，先要看你买啥,清楚了后再帮你买,可能直接从库房中提货,也可能去其它地方调货,也有可能不代理你要买的货；

#### 各自的优缺点
**服务器端**
NAT技术适用于中小访问量的情形，请求速度快，资源占用少。
代理服务器耗费资源较多一些。

**客户端**
NAT设置简单，无需客户端软件。
代理服务器会根据每一种应用设置代理服务器。需要安装客户端软件，比较复杂，且不一定支持所有的应用。如VPN客户端登录过多，代理服务器就无法代理应用。

# 设计的专业名词
## TTL
数据报到达目的地的最大报文跳数. 一般是64. 每次经过一个路由, TTL-= 1, 一直减到0还没到达, 那么就丢弃了. 主要是用来防止出现路由循环

## MTU
**MTU相当于发快递时对包裹尺寸的限制**. 这个限制是不同的数据链路对应的物理层, 产生的限制.
- 以太网帧中的数据长度规定最小46字节,最大1500字节,ARP数据包的长度不够46字节,要在后面补填充位;
- 最大值1500称为以太网的最大传输单元(MTU),**不同的网络类型有不同的MTU**;

### MTU对IP协议的影响
由于数据链路层**MTU**的限制, 对于较大的IP数据包要进行分包.
- 将较大的IP包分成多个小包, 并给每个小包打上标签; 
- 每个小包IP协议头的 16位标识(id) 都是相同的;每个小包的IP协议头的3位标志字段中, 第2位置为0, 表示允许分片, 第3位来表示结束标记(当前是否是最后一个小包, 是的话置为1, 否则置为0);
- 到达对端时再将这些小包, 会按顺序重组, 拼装到一起返回给传输层;
- 一旦这些小包中任意一个小包丢失, 接收端的重组就会失败. 但是IP层不会负责重新传输数据;

![[Pasted image 20221103133043.png]]

![[Pasted image 20221103133159.png]]


### MTU对UDP协议的影响
让我们回顾一下UDP协议:
- 一旦UDP携带的数据超过1472(1500 - 20(IP首部) - 8(UDP首部)), 那么就会在网络层分成多个IP数据报. 
- 这多个IP数据报有任意一个丢失, 都会引起接收端网络层重组失败. 那么这就意味着, 如果UDP数据报在网络层被分片, 整个数据被丢失的概率就大大增加了.


### MTU对于TCP协议的影响
让我们再回顾一下TCP协议:
- TCP的一个数据报也不能无限大, 还是受制于MTU. TCP的单个数据报的最大消息长度, 称为MSS(Max Segment Size);
- TCP在建立连接的过程中, 通信双方会进行MSS协商.
- 最理想的情况下, MSS的值正好是在IP不会被分片处理的最大长度(这个长度仍然是受制于数据链路层的MTU).
- 双方在发送SYN的时候会在TCP头部写入自己能支持的MSS值. 
- 然后双方得知对方的MSS值之后, 选择较小的作为最终MSS. 
- MSS的值就是在TCP首部的40字节变长选项中(kind=2);

MSS和MTU的关系
![[Pasted image 20221103135812.png]]

### 查看硬件地址和MTU
![[Pasted image 20221103135841.png]]
使用ifconﬁg命令, 即可查看ip地址, mac地址, 和MTU;



## MSS 
TCP的单个数据报的最大消息长度, 称为MSS(Max Segment Size);



