
# 概念
基于**现有的数据**，计算出来的==**新属性**==。 **依赖**的数据变化，**自动**重新计算。


# 语法
1. 声明在 **computed 配置项**中，一个计算属性对应一个函数
2. 使用起来和普通属性一样使用  `{{ 计算属性名}}`


# 注意
1. computed配置项和data配置项是**同级**的
2. computed中的计算属性**虽然是函数的写法**，但他**依然是个属性**
3. computed中的计算属性**不能**和data中的属性**同名**
4. 使用computed中的计算属性和使用data中的属性是一样的用法
5. computed中计算属性内部的**this**依然**指向的是Vue实例**


# 案例
比如我们可以使用计算属性实现下面这个业务场景
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SIYuan/20230822163435.png)

```html
<!--CSS样式-->
  <style>
    table {
      border: 1px solid #000;
      text-align: center;
      width: 240px;
    }
    th,td {
      border: 1px solid #000;
    }
    h3 {
      position: relative;
    }
  </style>



<!--html主体-->
<div id="app">
    <h3>小黑的礼物清单</h3>
    <table>
      <tr>
        <th>名字</th>
        <th>数量</th>
      </tr>
      <tr v-for="(item, index) in list" :key="item.id">
        <td>{{ item.name }}</td>
        <td>{{ item.num }}个</td>
      </tr>
    </table>

    <!-- 目标：统计求和，求得礼物总数 -->
    <p>礼物总数：{{ totalCount }} 个</p>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: '#app',
      data: {
        // 现有的数据
        list: [
          { id: 1, name: '篮球', num: 1 },
          { id: 2, name: '玩具', num: 2 },
          { id: 3, name: '铅笔', num: 5 },
        ]
      },
      computed: {
        totalCount () {
          // 基于现有的数据，编写求值逻辑
          // 计算属性函数内部，可以直接通过 this 访问到 app 实例
          // console.log(this.list)

          // 需求：对 this.list 数组里面的 num 进行求和 → reduce
          let total = this.list.reduce((sum, item) => sum + item.num, 0)
          return total
        }
      }
    })
  </script>

```
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SIYuan/20230822163755.png)


# computed计算属性 VS methods方法

## computed计算属性
==作用==：封装了一段对于**数据**的处理，求得一个**结果**

==语法==：
1. 写在computed配置项中
2. 作为属性，直接使用
   - js中使用计算属性： `this.计算属性`
   - 模板中使用计算属性：`{{计算属性}}`



## methods计算属性
==作用==：给Vue实例提供一个**方法**，调用以**处理业务逻辑**。

==语法==：
1. 写在methods配置项中
2. 作为方法调用
   - js中调用：`this.方法名()`
   - 模板中调用 `{{方法名()}}`  或者 `@事件名=“方法名”`



# 计算属性的优势
1. ==**缓存特性**==（提升性能）
   - 计算属性会对计算出来的结果缓存，再次使用直接读取缓存，依赖项变化了，会自动重新计算 → 并再次缓存
2. methods没有缓存特性


# 计算属性的完整写法
**==既然计算属性也是属性，能访问，应该也能修改了？==**
1. 计算属性**默认的简写**，只能读取访问 **，不能 "修改"**
2. 如果要 "修改",  就需要写计算属性的完整写法

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SIYuan/20230822164316.png)
>computed 的完整写法是有 `get()` 和 `set()` 的, 而我们用的默认写法, 只有`get()`

## 示例代码
这是一个改名案例, 当我们点击按钮"改名卡"时, 更改我们计算好的数据
```html
<div id="app">
    姓：<input type="text" v-model="firstName"> +
    名：<input type="text" v-model="lastName"> =
    <span>{{ fullName }}</span><br><br>
    
    <button @click="changeName">改名卡</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <script>
    const app = new Vue({
      el: '#app',
      data: {
        firstName: '刘',
        lastName: '备',
      },
      methods: {
        changeName () {
          this.fullName = '黄忠'
        }
      },
      computed: {
        // 简写 → 获取，没有配置设置的逻辑
        // fullName () {
        //   return this.firstName + this.lastName
        // }

        // 完整写法 → 获取 + 设置
        fullName: {
          // (1) 当fullName计算属性，被获取求值时，执行get（有缓存，优先读缓存）
          //     会将返回值作为，求值的结果
          get () {
            return this.firstName + this.lastName
          },
          
          // (2) 当fullName计算属性，被修改赋值时，执行set
          //     修改的值，传递给set方法的形参
          set (value) {
            // console.log(value.slice(0, 1))          
            // console.log(value.slice(1))         
            this.firstName = value.slice(0, 1)
            this.lastName = value.slice(1)
          }
        }
      }
    })
  </script>
```
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SIYuan/20230822165017.png)
