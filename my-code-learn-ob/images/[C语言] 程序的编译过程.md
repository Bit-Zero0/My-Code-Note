# [C语言] 程序的编译过程

![image-20220224145055627](https://gitee.com/fengalex0/picgo-image/raw/master/202202241450719.png)





## 一、编译环境

编译环境分为两部分：1.**编译**，2.**链接**

其中编译又分为三个部分：预编译--->编译--->汇编

![image-20220224145154567](C:\Users\31533\Desktop\202202241451630.png)



### 1. 编译

有三个步骤 ： 预编译--->编译--->汇编

#### 1.1 预编译

展开包含的头文件

删除注释

替换我们定义的#define符号



#### 1.2 编译

将C代码转化为汇编代码

- 语法分析

- 词法分析

- 语义分析

- 符号汇总：将全局函数和库函数收集汇总起来





#### 1.3 汇编

将汇编代码转化为二进制指令（机器语言）

形成符号表：对应全局函数和库函数的地址将其符号表的形式保存。





### 2. 链接

- 合并段表：我的生成的每个`.obj`文件中会分成许多段，每个段都有自己的功能，多个`.obj`文件合并时，合并的段的段功能相同的段。
- 符号表的合并和重定位：将多个`.obj` 文件的符号表合并，如果出现相同的符号，则将符号的地址定位到有效的地址上。



**多个目标文件进行链接的时候，会通过符号表查看来自外部的符号是否真实存在。**





## 二、运行环境

1. 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。

2. 程序的执行便开始。接着便调用main函数。
3. 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。
4. 终止程序。正常终止main函数；也有可能是意外终止（比如停电）。





## 三、预处理详解

### 1. 预定义符号

```c
__FILE__      //进行编译的源文件
__LINE__     //文件当前的行号
__DATE__    //文件被编译的日期
__TIME__    //文件被编译的时间
__STDC__    //如果编译器遵循ANSI C，其值为1，否则未定义。vs2019未遵循，所以无法使用
```



以上既然是预编译的源文件的符号，所以我们都可以将其打印出来

```c
#include <stdio.h>

int main() 
{
	printf("%s\n", __FILE__);
	printf("%d\n", __LINE__);
	printf("%s\n", __DATE__);
	printf("%s\n", __TIME__);

	return 0;
}
```

这就是正在编译的源文件的信息

![image-20220224125116196](https://gitee.com/fengalex0/picgo-image/raw/master/202202241251225.png)



可以用来记录日志

```c
int main()
{
	int i = 0; 
	FILE* pf = fopen("log.txt", "w");
	if (pf == NULL)
	{
		//...
		return 1;
	}
	for (i = 0; i < 10; i++)
	{
		fprintf(pf,"%s %s %s %d %d\n", __DATE__, __TIME__, __FILE__, __LINE__, i);
	}
	fclose(pf);
	pf = NULL;
	return 0;
}
```

![image-20220224125848624](https://gitee.com/fengalex0/picgo-image/raw/master/202202241258658.png)





### 2. #define

`#define`我们在之前的项目练习中用的非常之多，本次为详细解析



在程序中扩展`#define`定义符号和宏时，需要涉及几个步骤。

1. 在调用宏时，首先对参数进行检查，看看是否包含任何由`#define`定义的符号。如果是，它们首先

被替换。

2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换。

3. 最后，再次对结果文件进行扫描，看看它是否包含任何由`#define`定义的符号。如果是，就重复上

述处理过程。

**注意：**

1. 宏参数和`#define` 定义中可以出现其他`#define`定义的符号。但是对于宏，不能出现递归。

2. 当预处理器搜索`#define`定义的符号的时候，字符串常量的内容并不被搜索。



```c
#define MAX 1000
#define reg register          //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;)     //用更形象的符号来替换一种实现
#define CASE break;case        //在写case语句的时候自动把 break写上。
// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
                          date:%s\ttime:%s\n" ,\
                          __FILE__,__LINE__ , \
                          __DATE__,__TIME__ )  
```

注意！！定义的符号后面千万不能加  `;` ,因为在预处理阶段，会把 `;` 看作为一个整体。





```c
#define DOUBLE(x) x+x

int main()
{
	printf("%d\n", 10 * DOUBLE(3));//33 , 因为在预处理时发生了替换，变成了 10*3+3 ，所以等于33；
	printf("%d\n", 10 * 3+3);//33
	return 0;
}
```

![image-20220224132201351](https://gitee.com/fengalex0/picgo-image/raw/master/202202241322375.png)

正确写法

```c
#define DOUBLE(x) ((x)+(x))  //这样才能保证宏的优先级

int main()
{
	printf("%d\n", 10 * DOUBLE(3));
	printf("%d\n", 10 * 3+3);
	return 0;
}
```

![image-20220224132337093](https://gitee.com/fengalex0/picgo-image/raw/master/202202241323113.png)





#### 2.1 **#**和**##**

> 如何把参数插入到字符串中？

先看这段代码

```c
int main()
{
    char* p = "hello ""world\n";
    printf("hello" " world\n");
    printf("%s", p);
    return 0;
}
```

打印的结果都是： `hello world`

![image-20220224134037189](https://gitee.com/fengalex0/picgo-image/raw/master/202202241340210.png)



使用 `#` ，**把一个宏参数变成对应的字符串**

我们如果将字符串中的 “the value of  **<u>*X*</u>**  is %d”中的 **X**变为我想要的字符呢。

```c
#define PRINT(n) printf("the value of " #n "is %d\n",n)  //注意：此处使用了 #n

int main()
{
	int a = 10;
	int b = 20;
	printf("the value of " "a" "is %d\n", a);
	PRINT(a);

	printf("the value of " "b" "is %d\n", b);
	PRINT(b);

	return 0; 
}
```

![image-20220224135645871](https://gitee.com/fengalex0/picgo-image/raw/master/202202241356895.png)

`#n`就等于了我们使用的`"a"`或`"b"`了





**## 的作用**

> \##可以把位于它两边的符号合成一个符号。
>
> 它允许宏定义从分离的文本片段创建标识符。

```c
#define CAT(class,num) class##num

int main()
{
    int class =104;
    printf("%d\n",CAT(104,1000));
	return 0;
}
```

![image-20220224140427322](https://gitee.com/fengalex0/picgo-image/raw/master/202202241404346.png)



#### 2.2 **带副作用的宏参数**

当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能

出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。

```c
x+1;//不带副作用
x++;//带有副作用
```



```c
#define MAX(x,y) ((x)>(y) ? (x) :(y))

int main()
{
	int a = 3;
	int b = 5;
	int m = MAX(a++, b++);

	printf("%d\n", m);
	printf("a=%d,b=%d\n", a, b);
	return 0;
}
```

![image-20220224142120189](https://gitee.com/fengalex0/picgo-image/raw/master/202202241421213.png)

因为宏是直接替换过去的，所以也会改变原有值，稍不注意就会影响到程序，所以尽量不要在宏中使用 `++` 操作符。



#### 2.3 **宏和函数对比**

宏通常被应用于执行简单的运算。

比如找出两数中的较大值：

```c
#define MAX(a, b) ((a)>(b)?(a):(b))
```



**原因**有二：

> 1. 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。**所以宏比函数在程序的规模和速度方面更胜一筹**。
> 2. 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于>来比较的类型。**宏是类型无关的**。



**宏的缺点：**当然和函数相比宏也有劣势的地方：

> 1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。
>
> 2. 宏是没法调试的。
>
> 3. 宏由于类型无关，也就不够严谨。
>
> 4. 宏可能会带来运算符优先级的问题，导致程容易出现错。

| 属性             | **#define定义宏**                                            | **函数**                                                     |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 代码长度         | 每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长 | 函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码 |
| 执行速度         | 更快                                                         | 存在函数的调用和返回的额外开销，所以相对慢一些               |
| 操作符优先级     | 宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号。 | 函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测。 |
| 带有副作用的参数 | 参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果 | 函数参数只在传参的时候求值一次，结果更容易控制。             |
| 参数类型         | 宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用于任何参数类型。 | 函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的 |
| 调试             | 宏是不方便调试的                                             | 函数是可以逐语句调试的                                       |
| 递归             | 宏是不能递归的                                               | 函数是可以递归的                                             |

