 我们之前学习的程序在没有跳转语句的情况下，都是由上至下沿着一条路径依次执行。现在想要设计一个程序，可以同时有多条执行路径同时执行。比如，`一边游戏，一边qq聊天，一边听歌`，怎么设计？

要解决上述问题，需要使用`多进程`或者`多线程`来解决。

# 相关概念

## 程序、进程与线程
* **程序（program）**：为完成特定任务，用某种语言编写的`一组指令的集合`。即指`一段静态的代码`，静态对象。

* **进程（process）**：程序的一次执行过程，或是正在内存中运行的应用程序。如：运行中的QQ，运行中的网易音乐播放器。
	* 每个进程都有一个独立的内存空间，系统运行一个程序即是一个进程从创建、运行到消亡的过程。（生命周期）
	* 程序是静态的，进程是动态的
	* 进程作为`操作系统调度和分配资源的最小单位`（亦是系统运行程序的基本单位），系统在运行时会为每个进程分配不同的内存区域。
	* 现代的操作系统，大都是支持多进程的，支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。
* **线程（thread）**：进程可进一步细化为线程，是程序内部的`一条执行路径`。一个进程中至少有一个线程。
	- 一个进程同一时间若`并行`执行多个线程，就是支持多线程的。
	- ![image-20220331233204504.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/image-20220331233204504.png)
	-   线程作为`CPU调度和执行的最小单位`。
	-   一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来`安全的隐患`。
	-   下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。
	-   线程作为`CPU调度和执行的最小单位`。
	-   一个进程中的多个线程共享相同的内存单元，它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来`安全的隐患`。
	-   下图中，红框的蓝色区域为线程独享，黄色区域为线程共享。
	- ![image-20220514175737426.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/image-20220514175737426.png)
注意：
>不同的进程之间是不共享内存的。
>进程之间的数据交换和通信的成本很高。

## 为啥要有线程
==**首先, "并发编程" 成为 "刚需"**.==
	- 单核 CPU 的发展遇到了瓶颈. 要想提高算力, 就需要多核 CPU. 而并发编程能更充分利用多核 CPU资源.
	- 有些任务场景需要 "等待 IO", 为了让等待 IO 的时间能够去做一些其他的工作, 也需要用到并发编程.

==**其次, 虽然多进程也能实现 并发编程, 但是线程比进程更轻量.**==
	- 创建线程比创建进程更快.
	- 销毁线程比销毁进程更快.
	- 调度线程比调度进程更快.


## 进程和线程的区别
- 进程是包含线程的. 每个进程至少有一个线程存在，即主线程。
- 进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.
>比如之前的多进程例子中，每个客户来银行办理各自的业务，但他们之间的票据肯定是不想让别人知道的，否则钱不就被其他人取走了么。而上面我们的公司业务中，张三、李四、王五虽然是不同的执行流，但因为办理的都是一家公司的业务，所以票据是共享着的。这个就是多线程和多进程的最大区别。

**提醒**: ==**进程**是系统分配资源的最小单位，**线程**是系统调度的最小单位。==


## 线程调度
**分时调度**
    所有线程`轮流使用` CPU 的使用权，并且平均分配每个线程占用 CPU 的时间。
    
**抢占式调度**
    让`优先级高`的线程以`较大的概率`优先使用 CPU。如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。

## 多线程程序的优点
**背景：** 以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？

**多线程程序的优点：**
1.  提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2.  提高计算机系统CPU的利用率
3.  改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改


## 并行与并发
**并行（parallel）**：指两个或多个事件在`同一时刻`发生（同时发生）。指在同一时刻，有`多条指令`在`多个CPU`上`同时`执行。比如：多个人同时做不同的事。


**并发（concurrency）**：指两个或多个事件在`同一个时间段内`发生。即在一段时间内，有`多条指令`在`单个CPU`上`快速轮换、交替`执行，使得在宏观上具有多个进程同时执行的效果。


>在操作系统中，启动了多个程序，`并发`指的是在一段时间内宏观上有多个程序同时运行，这在单核 CPU 系统中，每一时刻只能有一个程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。
>
>而在多核 CPU 系统中，则这些可以`并发`执行的程序便可以分配到多个CPU上，实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，`并行`处理的程序越多，能大大的提高电脑运行的效率。


# 创建和启动线程
-   Java语言的JVM允许程序运行多个线程，使用`java.lang.Thread`类代表**线程**，所有的线程对象都必须是Thread类或其子类的实例。
-   Thread类的特性
    -   每个线程都是通过某个特定Thread对象的`run()`方法来完成操作的，因此把`run()`方法体称为`线程执行体`。
    -   通过该Thread对象的`start()`方法来启动这个线程，而非直接调用`run()`
    -   要想实现多线程，必须在主线程中创建新的线程对象。

创建线程,主要有四种写法: 
- 继承Thread类
- 实现Runnable接口
- 匿名内部类创建 Thread 子类对象
- 匿名内部类创建 Runnable 子类对象
- lambda 表达式创建 Runnable 子类对象(最常用)


## 继承Thread类
Java通过继承Thread类来**创建**并**启动多线程**的步骤如下：
1.  定义Thread类的子类，并重写该类的`run()`方法，该`run()`方法的方法体就代表了线程需要完成的任务
2.  创建Thread子类的实例，即创建了线程对象
3.  调用线程对象的`start()`方法来启动该线程
```java
class MyThread extends Thread {  
    //定义指定线程名称的构造方法  
    public MyThread(String name) {  
        //调用父类的String参数的构造方法，指定线程的名称  
        super(name);  
    }  
    
    //重写run方法，完成该线程执行的逻辑  
    @Override  
    public void run() {  
        for (int i = 0; i < 10; i++) {  
            System.out.println(getName()+"：正在执行！"+i);  
        }  
    }  
}  
  
public class ThreadDemo1 {  
    public static void main(String[] args) {  
        //创建自定义线程对象1  
        MyThread mt1 = new MyThread("子线程1");  
        //开启子线程1  
        //开启子线程1  
        mt1.start();  
  
        //创建自定义线程对象2  
        MyThread mt2 = new MyThread("子线程2");  
        //开启子线程2  
        mt2.start();  
  
        //在主方法中执行for循环  
        for (int i = 0; i < 10; i++) {  
            System.out.println("main线程！"+i);  
        }  
    }  
}
```

>注意：
>1.  如果自己手动调用`run()`方法，那么就只是普通方法，没有启动多线程模式。
>2.  `run()`方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。
>3.  想要启动多线程，必须调用`start()`方法。 
>4.  一个线程对象只能调用一次`start()`方法启动，如果重复调用了，则将抛出以上的异常“`IllegalThreadStateException`”。

## 实现 Runnable 接口
Java有单继承的限制，当我们无法继承Thread类时，那么该如何做呢？
>在核心类库中提供了Runnable接口，我们可以实现Runnable接口，重写`run()`方法，然后再通过Thread类的对象代理启动和执行我们的线程体`run()`方法

步骤如下：
1.  定义Runnable接口的实现类，并重写该接口的`run()`方法，该`run()`方法的方法体同样是该线程的线程执行体。
2.  创建Runnable实现类的实例，并以此实例作为Thread的target参数来创建Thread对象，该Thread对象才是真正 的线程对象。
3.  调用线程对象的`start()`方法，启动线程。调用Runnable接口实现类的`run()`方法。
```java
class MyThread implements Runnable {  
    @Override  
    public void run() {  
        for (int i = 0; i < 20; i++) {  
            System.out.println(Thread.currentThread().getName() + " " + i);  
        }  
    }  
}  
  
public class ThreadDemo2 {  
    public static void main(String[] args) {  
        Thread t = new Thread(new MyThread());  
        t.start();  
    }  
}
```
通过实现Runnable接口，使得该类有了多线程类的特征。所有的分线程要执行的代码都在run方法里面。

在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。

实际上，所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是继承Thread类还是实现 Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。

说明：Runnable对象仅仅作为Thread对象的target，Runnable实现类里包含的run()方法仅作为线程执行体。 而实际的线程对象依然是Thread实例，只是该Thread线程负责执行其target的run()方法。

## 匿名内部类创建 Thread 子类对象
```java
public class ThreadDemo {  
    public static void main(String[] args) {  
        Thread t = new Thread() {  
            @Override  
            public void run() {  
                System.out.println("使用匿名内部类创建Thread子类对象");  
            }  
        };  
        t.start();  
    }  
}
```


## 匿名内部类创建 Runnable 子类对象
```java
public class ThreadDemo {  
    public static void main(String[] args) {  
        Thread t = new Thread(new Runnable() {  
            @Override  
            public void run() {  
                System.out.println("使用匿名类创建 Runnable 子类对象");  
            }  
        });  
        t.start();  
    }  
}
```


## lambda 表达式创建 Runnable 子类对象
```java
public class ThreadDemo2 {  
    public static void main(String[] args) {  
        Thread t = new Thread(()-> {  
            System.out.println("使用lambda创建 Thread 子类对像");  
        });  
  
        t.start();  
    }  
}
```

# Thread  类的常用方法
## 构造器
-   `public Thread()` :分配一个新的线程对象。

-   `public Thread(String name)` :分配一个指定名字的新的线程对象。

-   `public Thread(Runnable target)` :指定创建线程的目标对象，它实现了Runnable接口中的run方法

-   `public Thread(Runnable target,String name)` :分配一个带有指定目标新的线程对象并指定名字。

## 常用方法系列1
-   `public void run()` :此线程要执行的任务在此处定义代码。

-   `public void start()` :导致此线程开始执行; Java虚拟机调用此线程的run方法。

-   `public String getName()` :获取当前线程名称。

-   `public void setName(String name)`：设置该线程名称。

-   `public static Thread currentThread() `:返回对当前正在执行的线程对象的引用。在Thread子类中就是this，通常用于主线程和Runnable实现类

-   `public static void sleep(long millis)` :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。

-   `public static void yield()`：yield只是让当前线程暂停一下，让系统的线程调度器重新调度一次，希望优先级与当前线程相同或更高的其他线程能够获得执行机会，但是这个不能保证，完全有可能的情况是，当某个线程调用了yield方法暂停之后，线程调度器又将其调度出来重新执行。
    

## 常用方法系列2
-   `public final boolean isAlive()`：测试线程是否处于活动状态。如果线程已经启动且尚未终止，则为活动状态。

-   `void join()` ：等待该线程终止。
	- `void join(long millis)` ：等待该线程终止的时间最长为 millis 毫秒。如果millis时间到，将不再等待。
	- `void join(long millis, int nanos)` ：等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。

-   `public final void stop()`：`已过时`，不建议使用。强行结束一个线程的执行，直接进入死亡状态。run()即刻停止，可能会导致一些清理性的工作得不到完成，如文件，数据库等的关闭。同时，会立即释放该线程所持有的所有的锁，导致数据得不到同步的处理，出现数据不一致的问题。

-   `void suspend() / void resume()` : 这两个操作就好比播放器的暂停和恢复。二者必须成对出现，否则非常容易发生死锁。suspend()调用会导致线程暂停，但不会释放任何锁资源，导致其它线程都无法访问被它占用的锁，直到调用resume()。`已过时`，不建议使用。
    

## 常用方法系列3
每个线程都有一定的优先级，同优先级线程组成先进先出队列（先到先服务），使用分时调度策略。优先级高的线程采用抢占式策略，获得较多的执行机会。每个线程默认的优先级都与创建它的父线程具有相同的优先级。

-   **Thread类的三个优先级常量**：
    -   `MAX_PRIORITY`（10）：最高优先级
    -   `MIN_PRIORITY` （1）：最低优先级
    -   `NORM_PRIORITY` （5）：普通优先级，默认情况下main线程具有普通优先级。
        

-   `public final int getPriority()` ：返回线程优先级
    
-   `public final void setPriority(int newPriority)` ：改变线程的优先级，范围在[1,10]之间。


练习：获取main线程对象的名称和优先级。

声明一个匿名内部类继承Thread类，重写run方法，在run方法中获取线程名称和优先级。设置该线程优先级为最高优先级并启动该线程。


## 练习
```java
public class ThreadDemo2 {  
    public static void main(String[] args) {  
        Thread thread = new Thread(()-> {  
            for (int i = 0; i < 10; i++) {  
  
                try {  
                    System.out.println(Thread.currentThread().getName() + " 活着的");  
  
                    Thread.sleep(1000);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        });  
        System.out.println(Thread.currentThread().getName()  
                + ": ID: " + thread.getId());  
        System.out.println(Thread.currentThread().getName()  
                + ": 名称: " + thread.getName());  
        System.out.println(Thread.currentThread().getName()  
                + ": 状态: " + thread.getState());  
        System.out.println(Thread.currentThread().getName()  
                + ": 优先级: " + thread.getPriority());  
        System.out.println(Thread.currentThread().getName()  
                + ": 后台线程: " + thread.isDaemon());  
        System.out.println(Thread.currentThread().getName()  
                + ": 活着: " + thread.isAlive());  
        System.out.println(Thread.currentThread().getName()  
                + ": 被中断: " + thread.isInterrupted());  
  
        thread.start();  
        while (thread.isAlive()) {}  
        System.out.println(Thread.currentThread().getName()  
                + ": 状态: " + thread.getState());  
    }  
}
```

## 守护线程 (后台线程)
有一种线程，它是在**后台运行**的，它的任务是为其他线程提供服务的，这种线程被称为“守护线程”。JVM的垃圾回收线程就是典型的守护线程。

守护线程有个特点，就是如果所有非守护线程都死亡，那么守护线程自动死亡。形象理解：`兔死狗烹`，`鸟尽弓藏`

调用`setDaemon(true)`方法可将指定线程设置为守护线程。必须在线程启动之前设置，否则会报`IllegalThreadStateException`异常。

调用`isDaemon()`可以判断线程是否是守护线程。
```java
public class TestThread {
	public static void main(String[] args) {
		MyDaemon m = new MyDaemon();
		m.setDaemon(true);
		m.start();

		for (int i = 1; i <= 100; i++) {
			System.out.println("main:" + i);
		}
	}
}

class MyDaemon extends Thread {
	public void run() {
		while (true) {
			System.out.println("我一直守护者你...");
			try {
				Thread.sleep(1);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}
}
```


# 线程的状态
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508113720.png)

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508130719.png)
>刚把李四、王五找来，还是给他们在安排任务，没让他们行动起来，就是 `NEW` 状态；
>
>当李四、王五开始去窗口排队，等待服务，就进入到 `RUNNABLE` 状态。该状态并不表示已经被银行工作人员开始接待，排在队伍中也是属于该状态，即可被服务的状态，是否开始服务，则看调度器的调度;
>
>当李四、王五因为一些事情需要去忙，例如需要填写信息、回家取证件、发呆一会等等时，进入`BLOCKED` 、`WATING` 、`TIMED_WAITING` 状态，至于这些状态的细分，我们以后再详解；
>
>如果李四、王五已经忙完，为 `TERMINATED` 状态。
>所以，之前我们学过的 isAlive() 方法，可以认为是处于不是 `NEW` 和 `TERMINATED` 的状态都是活着的。

在java.lang.Thread.State的枚举类中这样定义：

```java
public enum State {  
    NEW,  
    RUNNABLE,  
    BLOCKED,  
    WAITING,  
    TIMED_WAITING,  
    TERMINATED;  
}
```

-   `NEW（新建）`：线程刚被创建，但是并未启动。还没调用start方法。
    
-   `RUNNABLE（可运行）`：这里没有区分就绪和运行状态。因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。
    
-   `Teminated（被终止）`：表明此线程已经结束生命周期，终止运行。
    
-   重点说明，根据Thread.State的定义，**阻塞状态分为三种**：`BLOCKED`、`WAITING`、`TIMED_WAITING`。
    
    -   `BLOCKED（锁阻塞）`：在API中的介绍为：一个正在阻塞、等待一个监视器锁（锁对象）的线程处于这一状态。只有获得锁对象的线程才能有执行机会。
        -   比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。
            
    -   `TIMED_WAITING（计时等待）`：在API中的介绍为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。
        -   当前线程执行过程中遇到Thread类的`sleep`或`join`，Object类的`wait`，LockSupport类的`park`方法，并且在调用这些方法时，`设置了时间`，那么当前线程会进入TIMED_WAITING，直到时间到，或被中断。
            
    -   `WAITING（无限等待）`：在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。
        -   当前线程执行过程中遇到遇到Object类的`wait`，Thread类的`join`，LockSupport类的`park`方法，并且在调用这些方法时，`没有指定时间`，那么当前线程会进入WAITING状态，直到被唤醒。
            -   通过Object类的`wait()`进入WAITING状态的要有Object的`notify()/notifyAll()`唤醒；
            -   通过Condition的`await`进入WAITING状态的要有Condition的`signal()`方法唤醒；
            -   通过LockSupport类的park方法进入WAITING状态的要有LockSupport类的unpark方法唤醒
            -   通过Thread类的`join()`进入WAITING状态，只有调用`join()`方法的线程对象结束才能让当前线程恢复；


说明：当从WAITING或TIMED_WAITING恢复到Runnable状态时，如果发现当前线程没有得到监视器锁，那么会立刻转入BLOCKED状态。
![image-20220524203355448.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/image-20220524203355448.png)

## 案例观察

### 观察 1 : 关注 NEW 、RUNNABLE 、TERMINATED 状态的转换
使用 `isAlive()` 方法判定线程的存活状态.
```java
public class ThreadStatus {  
    public static void main(String[] args) {  
        Thread t  = new Thread(()->{  
            for (int i = 0; i < 1000_0000; i++) {  
  
            }  
        } , "zhangsan");  
  
        System.out.println(t.getName() + ": " + t.getState());  
  
        t.start();  
  
        while(t.isAlive()){  
            System.out.println(t.getName() + ": " + t.getState());  
        }  
  
        System.out.println(t.getName()+ ": " + t.getState());  
  
    }  
}
```


### 观察 2: 关注 WAITING 、BLOCKED 、TIMED_WAITING 状态的转换
```java
public class ThreadStatus {  
    public static void main(String[] args) {  
        Object object = new Object();  
  
        Thread t1  = new Thread(()->{  
            synchronized (object){  
                while(true){  
                    try {  
                        Thread.sleep(1000);  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
            }  
        } , "zhangsan");  
        t1.start();  
  
        Thread t2 = new Thread(()->{  
           synchronized (object){  
               System.out.println("hhhhh");  
           }  
        } , "lisi");  
        t2.start();  
    }  
}
```
使用 jconsole工具 可以看到 t1 的状态是 `TIMED_WAITING` , t2 的状态是 `BLOCKED`

修改上面的代码, 把 t1 中的 sleep 换成 wait
```java
public static void main(String[] args) {  
        final Object object = new Object();  
        Thread t1 = new Thread(new Runnable() {  
            @Override  
            public void run() {  
                synchronized (object) {  
                    try {  
						// [修改这里就可以了!!!!!]  
						// Thread.sleep(1000);  
                        object.wait();  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
            }  
        }, "t1");  
    }
```
使用 jconsole 可以看到 t1 的状态是 `WAITING`

### 总结
- `BLOCKED` 表示等待获取锁, `WAITING` 和 `TIMED_WAITING` 表示等待其他线程发来通知.
- `TIMED_WAITING` 线程在等待唤醒，但设置了时限; `WAITING` 线程在无限等待唤醒


# 线程安全
当我们使用多个线程访问**同一资源**（可以是同一个变量、同一个文件、同一条记录等）的时候，若多个线程`只有读操作`，那么不会发生线程安全问题。但是如果多个线程中对资源有`读和写`的操作，就容易出现线程安全问题。
![image-20220401233218326.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/image-20220401233218326.png)


## 同一个资源问题和线程安全问题
**案例：**
>火车站要卖票，我们模拟火车站的卖票过程。因为疫情期间，本次列车的座位共100个（即，**只能出售100张火车票**）。我们来模拟车站的售票窗口，实现多个窗口同时售票的过程。注意：不能出现错票、重票。

### 局部变量不能共享
```java
class Window extends Thread {
    public void run() {
        int ticket = 100;
        while (ticket > 0) {
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo1 {
    public static void main(String[] args) {
        Window w1 = new Window();
        Window w2 = new Window();
        Window w3 = new Window();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```
**结果：** 发现卖出300张票。

**问题：** 局部变量是每次调用方法都是独立的，那么每个线程的run()的ticket是独立的，不是共享数据。


### 不同对象的实例变量不共享
```java
class TicketWindow extends Thread {
    private int ticket = 100;

    public void run() {
        while (ticket > 0) {
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo2 {
    public static void main(String[] args) {
        TicketWindow w1 = new TicketWindow();
        TicketWindow w2 = new TicketWindow();
        TicketWindow w3 = new TicketWindow();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```
**结果**：发现卖出300张票。

**问题**：不同的实例对象的实例变量是独立的。


### 静态变量是共享的
```java
class TicketSaleThread extends Thread {
    private static int ticket = 100;

    public void run() {
        while (ticket > 0) {
            try {
                Thread.sleep(10);//加入这个，使得问题暴露的更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo3 {
    public static void main(String[] args) {
        TicketSaleThread t1 = new TicketSaleThread();
        TicketSaleThread t2 = new TicketSaleThread();
        TicketSaleThread t3 = new TicketSaleThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

运行结果:
```
窗口1卖出一张票，票号:100
窗口2卖出一张票，票号:100
窗口3卖出一张票，票号:100
窗口2卖出一张票，票号:97
窗口1卖出一张票，票号:97
窗口3卖出一张票，票号:95
窗口2卖出一张票，票号:94
窗口3卖出一张票，票号:93
窗口2卖出一张票，票号:93
窗口1卖出一张票，票号:93
窗口3卖出一张票，票号:90
窗口2卖出一张票，票号:90
窗口1卖出一张票，票号:88
窗口3卖出一张票，票号:87
窗口2卖出一张票，票号:86
窗口1卖出一张票，票号:86
窗口2卖出一张票，票号:84
窗口3卖出一张票，票号:83
窗口1卖出一张票，票号:83
窗口3卖出一张票，票号:81
窗口1卖出一张票，票号:80
窗口2卖出一张票，票号:80
窗口1卖出一张票，票号:78
窗口2卖出一张票，票号:77
窗口3卖出一张票，票号:77
窗口2卖出一张票，票号:75
窗口3卖出一张票，票号:74
窗口1卖出一张票，票号:74
窗口3卖出一张票，票号:72
窗口1卖出一张票，票号:71
窗口2卖出一张票，票号:71
窗口1卖出一张票，票号:69
窗口3卖出一张票，票号:68
窗口2卖出一张票，票号:68
窗口3卖出一张票，票号:66
窗口2卖出一张票，票号:65
窗口1卖出一张票，票号:65
窗口2卖出一张票，票号:63
窗口3卖出一张票，票号:62
窗口1卖出一张票，票号:62
窗口3卖出一张票，票号:60
窗口1卖出一张票，票号:59
窗口2卖出一张票，票号:59
窗口1卖出一张票，票号:57
窗口3卖出一张票，票号:56
窗口2卖出一张票，票号:56
窗口1卖出一张票，票号:54
窗口2卖出一张票，票号:54
窗口3卖出一张票，票号:54
窗口2卖出一张票，票号:51
窗口1卖出一张票，票号:51
窗口3卖出一张票，票号:49
窗口2卖出一张票，票号:48
窗口1卖出一张票，票号:47
窗口3卖出一张票，票号:47
窗口1卖出一张票，票号:45
窗口2卖出一张票，票号:44
窗口3卖出一张票，票号:44
窗口2卖出一张票，票号:42
窗口1卖出一张票，票号:41
窗口3卖出一张票，票号:41
窗口1卖出一张票，票号:39
窗口3卖出一张票，票号:38
窗口2卖出一张票，票号:38
窗口3卖出一张票，票号:36
窗口1卖出一张票，票号:35
窗口2卖出一张票，票号:35
窗口1卖出一张票，票号:33
窗口3卖出一张票，票号:32
窗口2卖出一张票，票号:32
窗口3卖出一张票，票号:30
窗口2卖出一张票，票号:29
窗口1卖出一张票，票号:29
窗口2卖出一张票，票号:27
窗口1卖出一张票，票号:26
窗口3卖出一张票，票号:26
窗口1卖出一张票，票号:24
窗口3卖出一张票，票号:23
窗口2卖出一张票，票号:23
窗口3卖出一张票，票号:21
窗口1卖出一张票，票号:20
窗口2卖出一张票，票号:20
窗口1卖出一张票，票号:18
窗口3卖出一张票，票号:17
窗口2卖出一张票，票号:17
窗口3卖出一张票，票号:15
窗口1卖出一张票，票号:14
窗口2卖出一张票，票号:14
窗口1卖出一张票，票号:12
窗口2卖出一张票，票号:11
窗口3卖出一张票，票号:11
窗口2卖出一张票，票号:9
窗口3卖出一张票，票号:8
窗口1卖出一张票，票号:8
窗口3卖出一张票，票号:6
窗口1卖出一张票，票号:5
窗口2卖出一张票，票号:5
窗口1卖出一张票，票号:3
窗口3卖出一张票，票号:2
窗口2卖出一张票，票号:2
窗口3卖出一张票，票号:0
窗口1卖出一张票，票号:-1
```
**结果**：发现卖出近100张票。

问题1：但是有重复票或负数票问题。
>原因：线程安全问题

问题2：如果要考虑有两场电影，各卖100张票等
>原因：TicketThread类的静态变量，是所有TicketThread类的对象共享


### 同一个对象的实例变量共享
示例代码：**多个Thread线程使用同一个Runnable对象**
```java
class TicketSaleRunnable implements Runnable {
    private int ticket = 100;

    public void run() {
        while (ticket > 0) {
            try {
                Thread.sleep(10);//加入这个，使得问题暴露的更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}

public class SaleTicketDemo4 {
    public static void main(String[] args) {
        TicketSaleRunnable tr = new TicketSaleRunnable();
        Thread t1 = new Thread(tr, "窗口一");
        Thread t2 = new Thread(tr, "窗口二");
        Thread t3 = new Thread(tr, "窗口三");

        t1.start();
        t2.start();
        t3.start();
    }
}
```
结果：发现卖出近100张票。

问题：但是有重复票或负数票问题。
>原因：线程安全问题



### 抽取资源类，共享同一个资源对象
```java
//1、编写资源类
class Ticket {
    private int ticket = 100;

    public void sale() {
        if (ticket > 0) {
            try {
                Thread.sleep(10);//加入这个，使得问题暴露的更明显
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        } else {
            throw new RuntimeException("没有票了");
        }
    }

    public int getTicket() {
        return ticket;
    }
}

public class SaleTicketDemo5 {
    public static void main(String[] args) {
        //2、创建资源对象
        Ticket ticket = new Ticket();

        //3、启动多个线程操作资源类的对象
        Thread t1 = new Thread("窗口一") {
            public void run() {
                while (true) {
                    ticket.sale();
                }
            }
        };
        Thread t2 = new Thread("窗口二") {
            public void run() {
                while (true) {
                    ticket.sale();
                }
            }
        };
        Thread t3 = new Thread(new Runnable() {
            public void run() {
                ticket.sale();
            }
        }, "窗口三");


        t1.start();
        t2.start();
        t3.start();
    }
}
```
结果：发现卖出近100张票。

问题：但是有重复票或负数票问题。
>原因：线程安全问题


## 同步机制解决线程安全问题
要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (**`synchronized`**)来解决。也就是**原子性操作**
![1563372934332.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/1563372934332.png)
根据案例简述：
窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，完成对应的操作，保证了数据的同步性，解决了线程不安全的现象。

为了保证每个线程都能正常执行原子操作，Java引入了线程同步机制。注意:在任何时候,最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着(BLOCKED)。

### 什么是原子性
>- 我们把一段代码想象成一个房间，每个线程就是要进入这个房间的人。如果没有任何机制保证，A进入房间之后，还没有出来；B 是不是也可以进入房间，打断 A 在房间里的隐私。这个就是不具备原子性的。
>- 那我们应该如何解决这个问题呢？是不是只要给房间加一把锁，A 进去就把门锁上，其他人是不是就进不来了。这样就保证了这段代码的原子性了。

有时也把这个现象叫做同步互斥，表示操作是互相排斥的。

**一条 java 语句不一定是原子的，也不一定只是一条指令**
	比如刚才我们看到的 `n++`，其实是由三步操作组成的：
1. 从内存把数据读到 CPU
2. 进行数据更新
3. 把数据写回到 CPU

**不保证原子性会给多线程带来什么问题**
如果一个线程正在对一个变量操作，中途其他线程插入进来了，如果这个操作被打断了，结果就可能是错误的。
>这点也和线程的抢占式调度密切相关. 如果线程不是 "抢占" 的, 就算没有原子性, 也问题不大.

### 可见性
可见性指, 一个线程对共享变量值的修改，能够及时地被其他线程看到.

**Java 内存模型 (JMM)**: Java虚拟机规范中定义了Java内存模型.
目的是屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的并发效果.
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508140621.png)
- 线程之间的共享变量存在 主内存 (Main Memory).
- 每一个线程都有自己的 "工作内存" (Working Memory) .
- 当线程要读取一个共享变量的时候, 会先把变量从主内存拷贝到工作内存, 再从工作内存读取数据.
- 当线程要修改一个共享变量的时候, 也会先修改工作内存中的副本, 再同步回主内存.

由于每个线程有自己的工作内存, 这些工作内存中的内容相当于同一个共享变量的 "副本". 此时修改线程1 的工作内存中的值, 线程2 的工作内存不一定会及时变化.

1) 初始情况下, 两个线程的工作内存内容一致.
	-  ![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508140908.png)
2) 一旦线程1 修改了 a 的值, 此时主内存不一定能及时同步. 对应的线程2 的工作内存的 a 的值也不一定能及时同步.
	-  ![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508140936.png)
	- 这个时候代码中就容易出现问题.

**==此时引入了两个问题:==**
>- 为啥要整这么多内存?
>- 为啥要这么麻烦的拷来拷去?

1) ==为啥整这么多内存?==
实际并没有这么多 "内存". 这只是 Java 规范中的一个术语, 是属于 "抽象" 的叫法.
**所谓的 "主内存" 才是真正硬件角度的 "内存". 而所谓的 "工作内存", 则是指 CPU 的寄存器和高速缓存**.

2) ==为啥要这么麻烦的拷来拷去?==
因为 CPU 访问自身寄存器的速度以及高速缓存的速度, 远远超过访问内存的速度(快了 3 - 4 个数量级, 也就是几千倍, 上万倍).
>比如某个代码中要连续 10 次读取某个变量的值, 如果 10 次都从内存读, 速度是很慢的. 但是如果只是第一次从内存读, 读到的结果缓存到 CPU 的某个寄存器中, 那么后 9 次读数据就不必直接访问内存了. 效率就大大提高了.

那么接下来问题又来了, 既然访问寄存器速度这么快, 还要内存干啥??
答案就是一个字: ***贵***



### 同步机制解决线程安全问题的原理
同步机制的原理，其实就相当于给某段代码加“**锁**”，任何线程想要执行这段代码，都要先获得“锁”，我们称它为**同步锁**。因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含：
-   Mark Word：记录了和当前对象有关的GC、锁标记等信息。
-   指向类的指针：每一个对象需要记录它是由哪个类创建出来的。
-   数组长度（只有数组对象才有）

哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。

**同步代码块**：`synchronized` 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。 格式:
```java
synchronized(同步锁){  
     需要同步操作的代码  
}
```


**同步方法：** `synchronized` 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线程在外面等着。
```java
public synchronized void method(){  
    可能会产生线程安全问题的代码  
}
```

### 同步锁机制
对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。

###  synchronized的锁是什么
同步锁对象可以是任意类型，但是必须保证竞争“同一个共享资源”的多个线程必须使用同一个“同步锁对象”。

对于同步代码块来说，同步锁对象是由程序员手动指定的（很多时候也是指定为`this`或`类名.class`），但是对于同步方法来说，同步锁对象只能是默认的：
-   静态方法：当前类的Class对象（`类名.class`）
-   非静态方法：`this`


### 同步操作的思考顺序
1、如何找问题，即代码是否存在线程安全？（非常重要） 
>- 明确哪些代码是多线程运行的代码 
>- 明确多个线程是否有共享数据 
>- 明确多线程运行代码中是否有多条语句操作共享数据

2、如何解决呢？（非常重要） 
>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 
>即所有操作共享数据的这些语句都要放在同步范围中

3、切记：
>**范围太小**：不能解决安全问题
>**范围太大**：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，不能合理利用CPU资源。


### synchronized 的特性
#### 1) 互斥
synchronized 会起到互斥效果, 某个线程执行到某个对象的 synchronized 中时, 其他线程如果也执行到同一个对象 synchronized 就会阻塞等待.
- 进入 synchronized 修饰的代码块, 相当于 **加锁**
- 退出 synchronized 修饰的代码块, 相当于 **解锁**

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508142412.png)


synchronized用的锁是存在Java对象头里的。
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508142510.png)


==**理解 "阻塞等待".**==
针对每一把锁, 操作系统内部都维护了一个等待队列. 当这个锁被某个线程占有的时候, 其他线程尝试进行加锁, 就加不上了, 就会阻塞等待, 一直等到之前的线程解锁之后, 由操作系统唤醒一个新的线程, 再来获取到这个锁.

注意:
>- 上一个线程解锁之后, 下一个线程并不是立即就能获取到锁. 而是要靠操作系统来 "唤醒". 这也就是操作系统线程调度的一部分工作.
>- 假设有 A B C 三个线程, 线程 A 先获取到锁, 然后 B 尝试获取锁, 然后 C 再尝试获取锁, 此时 B和 C 都在阻塞队列中排队等待. 但是当 A 释放锁之后, 虽然 B 比 C 先来的, 但是 B 不一定就能获取到锁, 而是和 C 重新竞争, 并不遵守先来后到的规则.

synchronized的底层是使用操作系统的mutex lock实现的.


#### 2) 刷新内存
synchronized 的工作过程:
1. 获得互斥锁
2. 从主内存拷贝变量的最新副本到工作的内存
3. 执行代码
4. 将更改后的共享变量的值刷新到主内存
5. 释放互斥锁

所以 synchronized 也能保证内存可见性. 具体代码参见后面 volatile 部分.


#### 3) 可重入
synchronized 同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题；

理解 "把自己锁死"
一个线程没有释放锁, 然后又尝试再次加锁.
```
// 第一次加锁, 加锁成功
lock();
// 第二次加锁, 锁已经被占用, 阻塞等待.
lock();
```

按照之前对于锁的设定, 第二次加锁的时候, 就会阻塞等待. 直到第一次的锁被释放, 才能获取到第二个锁. 但是释放第一个锁也是由该线程来完成, 结果这个线程已经躺平了, 啥都不想干了, 也就无法进行解锁操作. 这时候就会 死锁.
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508142940.png)
这样的锁称为==**不可重入锁**==.

==Java 中的 synchronized 是 **可重入锁**==, 因此没有上面的问题.


### 代码演示
#### 示例一：静态方法加锁
```java
class TicketSaleThread extends Thread{
    private static int ticket = 100;
    public void run(){//直接锁这里，肯定不行，会导致，只有一个窗口卖票
        while (ticket > 0) {
            saleOneTicket();
        }
    }

    public synchronized static void saleOneTicket(){//锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个
        if(ticket > 0) {//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决
            System.out.println(Thread.currentThread().getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}
public class SaleTicketDemo3 {
    public static void main(String[] args) {
        TicketSaleThread t1 = new TicketSaleThread();
        TicketSaleThread t2 = new TicketSaleThread();
        TicketSaleThread t3 = new TicketSaleThread();

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

#### 示例二：非静态方法加锁
```java
public class SaleTicketDemo4 {
    public static void main(String[] args) {
        TicketSaleRunnable tr = new TicketSaleRunnable();
        Thread t1 = new Thread(tr, "窗口一");
        Thread t2 = new Thread(tr, "窗口二");
        Thread t3 = new Thread(tr, "窗口三");

        t1.start();
        t2.start();
        t3.start();
    }
}

class TicketSaleRunnable implements Runnable {
    private int ticket = 100;

    public void run() {//直接锁这里，肯定不行，会导致，只有一个窗口卖票
        while (ticket > 0) {
            saleOneTicket();
        }
    }

    public synchronized void saleOneTicket() {//锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以
        if (ticket > 0) {//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决
            System.out.println(Thread.currentThread().getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        }
    }
}
```

#### 示例三：同步代码块
```java
//1、编写资源类
class Ticket {
    private int ticket = 1000;

    public void sale() {//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象
        if (ticket > 0) {
            System.out.println(Thread.currentThread().getName() + "卖出一张票，票号:" + ticket);
            ticket--;
        } else {
            throw new RuntimeException("没有票了");
        }
    }

    public int getTicket() {
        return ticket;
    }
}

public class SaleTicketDemo5 {
    public static void main(String[] args) {
        //2、创建资源对象
        Ticket ticket = new Ticket();

        //3、启动多个线程操作资源类的对象
        Thread t1 = new Thread("窗口一") {
            public void run() {//不能给run()直接加锁，因为t1,t2,t3的三个run方法分别属于三个Thread类对象，
                // run方法是非静态方法，那么锁对象默认选this，那么锁对象根本不是同一个
                while (true) {
                    synchronized (ticket) {
                        ticket.sale();
                    }
                }
            }
        };
        Thread t2 = new Thread("窗口二") {
            public void run() {
                while (true) {
                    synchronized (ticket) {
                        ticket.sale();
                    }
                }
            }
        };
        Thread t3 = new Thread(new Runnable() {
            public void run() {
                while (true) {
                    synchronized (ticket) {
                        ticket.sale();
                    }
                }
            }
        }, "窗口三");


        t1.start();
        t2.start();
        t3.start();
    }
}
```

## Java 标准库中的线程安全类
Java 标准库中很多都是线程不安全的. 这些类可能会涉及到多线程修改共享数据, 又没有任何加锁措施.
- ArrayList
- LinkedList
- HashMap
- TreeMap
- HashSet
- TreeSet
- StringBuilder

但是还有一些是线程安全的. 使用了一些锁机制来控制.
- Vector (不推荐使用)
- HashTable (不推荐使用)
- ConcurrentHashMap
- StringBuffer


还有的虽然没有加锁, 但是不涉及 "修改", 仍然是线程安全的
- String


# volatile 关键字

## volatile 能保证内存可见性
volatile 修饰的变量, 能够保证 "内存可见性".
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230508140621.png)

代码在写入 volatile 修饰的变量的时候,
- 改变线程工作内存中volatile变量副本的值
- 将改变后的副本的值从工作内存刷新到主内存

代码在读取 volatile 修饰的变量的时候,
- 从主内存中读取volatile变量的最新值到线程的工作内存中
- 从工作内存中读取volatile变量的副本

前面我们讨论内存可见性时说了, 直接访问工作内存(实际是 CPU 的寄存器或者 CPU 的缓存), 速度非常快, 但是可能出现数据不一致的情况.加上 `volatile` , 强制读写内存. 速度是慢了, 但是数据变的更准确了. 

### 案例
在这个代码中
- 创建两个线程 t1 和 t2
- t1 中包含一个循环, 这个循环以 flag == 0 为循环条件.
- t2 中从键盘读入一个整数, 并把这个整数赋值给 flag.
- 预期当用户输入非 0 的值的时候, t1 线程结束.

```java
public class ThreadDemo3 {  
    static class Counter{  
        public int flag = 0;  
    }  
  
    public static void main(String[] args) {  
        Counter counter = new Counter();  
  
        Thread t1 = new Thread(()->{  
            while(counter.flag == 0){  
                // do nothing  
            }  
            System.out.println("循环结束");  
        });  
  
        Thread t2 = new Thread(()->{  
            Scanner scanner = new Scanner(System.in);  
            System.out.println("输入一个整数");  
            counter.flag = scanner.nextInt();  
        });  
  
        t1.start();  
        t2.start();  
    }  
}
```

**执行效果**
> 当用户输入非0值时, t1 线程循环不会结束. (这显然是一个 bug)

==**原因**==
原因就是JVM对代码进行了优化, 虽说是优化, 但是对于我们的这段代码来说,是优化过度了 , 优化后编译器就认为我们之后不会修改flag的值.

>t1 读的是自己工作内存中的内容.
>当 t2 对 flag 变量进行修改, 此时 t1 感知不到 flag 的变化


当我们给flag加上 `volatile` , JVM就不会对 `flag` 进行优化,也就保证了内存的可见性
```java
static class Counter {
	public volatile int flag = 0;
}

// 执行效果
// 当用户输入非0值时, t1 线程循环能够立即结束.
```

## volatil 能禁止指令重排序
![[单例模式#指令重排序问题问题]]

## volatile 不保证原子性
`volatile` 和 `synchronized` 有着本质的区别. `synchronized` 能够保证原子性, `volatile` 保证的是内存可见性.

代码示例
```java
public class ThreadDemo5 {  
    static class Counter{  
        volatile public int count = 0;  
  
        void increase(){  
            count++;  
        }  
    }  
  
    public static void main(String[] args) {  
        final Counter counter = new Counter();  
  
        Thread t1 = new Thread (()->{  
            for (int i = 0; i < 5000; i++) {  
                counter.increase();  
            }  
        });  
  
        Thread t2 = new Thread(()->{  
            for (int i = 0; i < 5000; i++) {  
                counter.increase();  
            }  
        });  
  
        t1.start();  
        t2.start();  
  
        try {  
            t1.join();  
            t2.join();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
        System.out.println(counter.count);  
    }   
}
```
此时可以看到, 最终 count 的值仍然无法保证是 10000


## synchronized 也能保证内存可见性
synchronized 既能保证原子性, 也能保证内存可见性.

对上面的代码进行调整:
- 去掉 flag 的 volatile
- 给 t1 的循环内部加上 synchronized, 并借助 counter 对象加锁.
```java
public class ThreadDemo3 {  
    static class Counter {  
        public int flag = 0;  
    }  
    
    public static void main(String[] args) {  
        Counter counter = new Counter();  
        Thread t1 = new Thread(() -> {  
            while (true) {  
                synchronized (counter) {  
                    if (counter.flag != 0) {  
                        break;  
                    }  
                }  
            // do nothing  
            }  
            System.out.println("循环结束!");  
        });  
        Thread t2 = new Thread(() -> {  
            Scanner scanner = new Scanner(System.in);  
            System.out.println("输入一个整数:");  
            counter.flag = scanner.nextInt();  
        });  
        t1.start();  
        t2.start();  
    }  
}
```


# wait 和 notify

这是多个线程间的一种`协作机制`。谈到线程我们经常想到的是线程间的`竞争（race）`，比如去争夺锁，但这并不是故事的全部，线程间也会有协作机制。

在一个线程满足某个条件时，就进入等待状态（`wait() / wait(time)`）， 等待其他线程执行完他们的指定代码过后再将其唤醒（`notify()`）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 `notifyAll()`来唤醒所有的等待线程。wait/notify 就是线程间的一种协作机制。
1.  `wait()`：线程不再活动，不再参与调度，进入 `wait set` 中，因此不会浪费 CPU 资源，也不会去竞争锁了，这时的线程状态是 `WAITING` 或 `TIMED_WAITING`。它还要等着别的线程执行一个`特别的动作`，也即“`通知（notify）`”或者等待时间到，在这个对象上等待的线程从wait set 中释放出来，重新进入到调度队列（`ready queue`）中
    
2.  `notify()`：则选取所通知对象的 wait set 中的一个线程释放；
    
3.  `notifyAll()`：则释放所通知对象的 wait set 上的全部线程。

注意：
>被通知的线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它已经不持有锁，所以它需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当初调用 wait 方法之后的地方恢复执行。
>
总结如下：
>-   如果能获取锁，线程就从 `WAITING` 状态变成 `RUNNABLE`（可运行） 状态；
>-   否则，线程就从 `WAITING` 状态又变成 `BLOCKED`（等待锁） 状态

## wait() 方法
==wait 做的事情==:
- 使当前执行代码的线程进行等待. (把线程放到等待队列中)
- 释放当前的锁
- 满足一定条件时被唤醒, 重新尝试获取这个锁.
>**wait 要搭配 `synchronized` 来使用. 脱离 `synchronized` 使用 wait 会直接抛出异常**.

==wait 结束等待的条件==:
- 其他线程调用该对象的 `notify()` 方法.
- wait 等待时间超时 (wait 方法提供一个带有 timeout 参数的版本, 来指定等待时间).
- 其他线程调用该等待线程的 interrupted 方法, 导致 wait 抛出 InterruptedException 异常.


## notify()方法
notify 方法是唤醒等待的线程.
- 方法`notify()`也要在同步方法或同步块中调用，该方法是用来通知那些可能等待该对象的对象锁的其它线程，对其发出通知notify，并使它们重新获取该对象的对象锁。
- 如果有多个线程等待，则有线程调度器随机挑选出一个呈 wait 状态的线程。(并没有 "先来后到")
- 在`notify()`方法后，当前线程不会马上释放该对象锁，要等到执行`notify()`方法的线程将程序执行完，也就是退出同步代码块之后才会释放对象锁。

## wait/notify使用案例
创建 WaitTask 类, 对应一个线程, run 内部循环调用 wait.
创建 NotifyTask 类, 对应另一个线程, 在 run 内部调用一次 notify
注意, WaitTask 和 NotifyTask 内部持有同一个 Object locker. **WaitTask 和 NotifyTask 要想配合就需要搭配同一个 `Object`**.
```java
public class ThreadDemo6 {  
    static class  WaitTask implements Runnable {  
        private Object locker;  
  
        public WaitTask(Object locker) {  
            this.locker = locker;  
        }  
        @Override  
        public void run() {  
            synchronized (locker){  
                while(true){  
                    try {  
                        System.out.println("wait begin");  
                        locker.wait();  
                        System.out.println("wait end");  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
            }  
        }  
    }  
  
    static class NotifyTask implements Runnable {  
        private Object locker;  
  
        public NotifyTask(Object locker) {  
            this.locker = locker;  
        }  
        @Override  
        public void run() {  
            synchronized (locker) {  
                System.out.println("notify 开始");  
                locker.notify();  
                System.out.println("notify 结束");  
            }  
        }  
  
    }  
    public static void main(String[] args) {  
        Object locker  = new Object();  
  
        Thread t1 = new Thread(new WaitTask(locker));  
        Thread t2 = new Thread(new NotifyTask(locker));  
  
        t1.start();  
        try {  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        t2.start();  
  
    }  
}
```

使用 lambda 表达式会更简洁, 但耦合性也高了
```java
public class ThreadDemo6 {  
    public static void main(String[] args) {  
        Object locker  = new Object();  
  
        Thread t1  = new Thread(()->{  
            synchronized (locker){  
                while(true){  
                    try {  
                        System.out.println("wait begin");  
                        locker.wait();  
                        System.out.println("wait end");  
                    } catch (InterruptedException e) {  
                        e.printStackTrace();  
                    }  
                }  
            }  
        });  
  
        Thread t2 = new Thread(()-> {  
            synchronized (locker) {  
                System.out.println("notify 开始");  
                locker.notify();  
                System.out.println("notify 结束");  
            }  
        });  
  
        t1.start();  
        try {  
            Thread.sleep(1000);  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
        t2.start();  
  
    }  
}
```

## notifyAll()方法
notify方法只是唤醒某一个等待线程. 使用notifyAll方法可以一次唤醒所有的等待线程.

范例：使用notifyAll()方法唤醒所有等待线程, 在上面的代码基础上做出修改.
- 创建 3 个 WaitTask 实例. 1 个 NotifyTask 实例.
```java
static class WaitTask implements Runnable {
// 代码不变
}

static class NotifyTask implements Runnable {
	private Object locker;  
  
public NotifyTask(Object locker) {  
    this.locker = locker;  
	@Override  
	public void run() {  
	    synchronized (locker) {  
	        System.out.println("notify 开始");  
	        locker.notifyAll();  
	        System.out.println("notify 结束");  
	    }  
	}
}

public static void main(String[] args) throws InterruptedException {  
    Object locker = new Object();  
    Thread t1 = new Thread(new WaitTask(locker));  
    Thread t3 = new Thread(new WaitTask(locker));  
    Thread t4 = new Thread(new WaitTask(locker));  
    Thread t2 = new Thread(new NotifyTask(locker));  
    t1.start();  
    t3.start();  
    t4.start();  
    Thread.sleep(1000);  
    t2.start();    
}
```
此时可以看到, 调用 notifyAll 能同时唤醒 3 个wait 中的线程

**注意: 虽然是同时唤醒 3 个线程, 但是这 3 个线程需要竞争锁. 所以并不是同时执行, 而仍然是有先有后的执行.**

## wait 和 sleep 的对比（面试题）
其实理论上 `wait()` 和 `sleep()` 完全是没有可比性的，因为一个是用于线程之间的通信的，一个是让线程阻塞一段时间，

唯一的相同点就是都可以让线程放弃执行一段时间.

当然为了面试的目的，我们还是总结下：
1. wait 需要搭配 synchronized 使用. sleep 不需要.
2. wait 是 Object 的方法 , sleep 是 Thread 的静态方法.


# 多线程案例
## 单例模式
![[单例模式#java实现]]



## 阻塞式队列
### 阻塞队列是什么
阻塞队列是一种特殊的队列. 也遵守 "先进先出" 的原则.

阻塞队列能是一种线程安全的数据结构, 并且具有以下特性:
- 当队列满的时候, 继续入队列就会阻塞, 直到有其他线程从队列中取走元素.
- 当队列空的时候, 继续出队列也会阻塞, 直到有其他线程往队列中插入元素.

阻塞队列的一个典型应用场景就是 "生产者消费者模型". 这是一种非常典型的开发模型.


### 生产者消费者模型
生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。

生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等
待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取.

1) 阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力.
>比如在 "秒杀" 场景下, 服务器同一时刻可能会收到大量的支付请求. 如果直接处理这些支付请求,服务器可能扛不住(每个支付请求的处理都需要比较复杂的流程). 这个时候就可以把这些请求都放到一个阻塞队列中, 然后再由消费者线程慢慢的来处理每个支付请求.
>这样做可以有效进行 "削峰", 防止服务器被突然到来的一波请求直接冲垮.

2) 阻塞队列也能使生产者和消费者之间 **解耦**.
>比如过年一家人一起包饺子. 一般都是有明确分工, 比如一个人负责擀饺子皮, 其他人负责包. 擀饺子皮的人就是 "生产者", 包饺子的人就是 "消费者".擀饺子皮的人不关心包饺子的人是谁(能包就行, 无论是手工包, 借助工具, 还是机器包), 包饺子的人也不关心擀饺子皮的人是谁(有饺子皮就行, 无论是用擀面杖擀的, 还是拿罐头瓶擀, 还是直接从超市买的).


#### 标准库中的阻塞队列
在 Java 标准库中内置了阻塞队列. 如果我们需要在一些程序中使用阻塞队列, 直接使用标准库中的即可.
- `BlockingQueue` 是一个接口. 真正实现的类是 `LinkedBlockingQueue`.
- `put()` 方法用于阻塞式的入队列, `take()` 用于阻塞式的出队列.
- BlockingQueue 也有 offer, poll, peek 等方法, 但是这些方法不带有阻塞特性.
```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>();

// 入队列
queue.put("abc");

// 出队列. 如果没有 put 直接 take, 就会阻塞.
String elem = queue.take();
```


#### 实现生产者消费者模型
```java
public class ThreadDemo7 {  
    public static void main(String[] args) throws InterruptedException {  
        BlockingDeque<Integer> blockingDeque = new LinkedBlockingDeque<Integer>();  
  
        Thread customer = new Thread(()->{  
            while(true){  
                try {  
                    int value = blockingDeque.take();  
                    System.out.println("消费元素:" + value);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        } , "消费者");  
        customer.start();  
  
        Thread producter = new Thread(()->{  
            Random random = new Random();  
            while(true){  
                try {  
                    int num = random.nextInt(1000);  
                    System.out.println("生产元素:"+ num );  
                    blockingDeque.put(num);  
                    Thread.sleep(1000);  
  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        }, "生产者");  
  
        producter.start();  
  
        customer.join();  
        producter.join();  
    }  
}
```

#### 实现阻塞队列
- 通过 "循环队列" 的方式来实现.
- 使用 `synchronized` 进行加锁控制.
- `put()` 插入元素的时候, 判定如果队列满了, 就进行 `wait()`. (注意, 要在循环中进行 wait. 被唤醒时不一定队列就不满了, 因为同时可能是唤醒了多个线程).
- `take()` 取出元素的时候, 判定如果队列为空, 就进行 `wait()`. (也是循环 wait)
```java
public class BlockingQueue {  
    private int[] items = new int[1000];  
    private int head = 0;  
    private int tail = 0;  
    private int size = 0;  
  
    public void put(int value) throws InterruptedException {  
        synchronized (this){  
	        // 此处最好使用 while.
			// 否则 notifyAll 的时候, 该线程从 wait 中被唤醒,
			// 但是紧接着并未抢占到锁. 当锁被抢占的时候, 可能又已经队列满了
			// 就只能继续等待
            while(size == items.length){  
                wait();  
            }  
            items[tail++] = value;  
            tail = tail % items.length;  
            size++;  
            notifyAll();  
        }  
    }  
  
    public int take() throws InterruptedException {  
        int  ret = 0;  
        synchronized (this){  
            while(size == 0){  
                wait();  
            }  
  
            ret = items[head++];  
            head = head % items.length;  
            size--;  
            notifyAll();  
        }  
        return ret;  
    }  
  
    public synchronized int size(){  
        return size;  
    }  
}
```

测试代码
```java  
public class test {  
    public static void main(String[] args) throws InterruptedException {  
        BlockingQueue blockingQueue = new BlockingQueue();  
        Thread customer = new Thread(() -> {  
            while (true) {  
                try {  
                    int value = blockingQueue.take();  
                    System.out.println(value);  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        }, "消费者");  
  
        customer.start();  
  
        Thread producer = new Thread(() -> {  
            Random random = new Random();  
            while (true) {  
                try {  
                    blockingQueue.put(random.nextInt(10000));  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            }  
        }, "生产者");  
        producer.start();  
  
        customer.join();  
        producer.join();  
    }  
}
```


















































































































































