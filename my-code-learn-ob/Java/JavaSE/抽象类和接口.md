
# 抽象类
## 抽象类接口
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，**如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类**。 比如：
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230421220925.png)

在打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由 Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 **抽象方法(abstract method)**, 包含抽象方法的类我们称为 **抽象类(abstract class)**.

## 抽象类语法
在Java中，**一个类如果被 `abstract` 修饰称为抽象类，抽象类中被`abstract` 修饰的方法称为抽象方法，抽象方法不用给出具体的实现体**。
```java
// 抽象类：被abstract修饰的类  
public abstract class Shape {  
    // 抽象方法：被abstract修饰的方法，没有方法体  
    abstract public void draw();  
    abstract void calcArea();  
    
    // 抽象类也是类，也可以增加普通方法和属性  
    protected double area; // 面积
    
    public double getArea(){  
        return area;  
    }  
}
```
**注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法**

## 抽象类特性
1. 抽象类不能直接实例化对象
2. 抽象方法不能是 private 的
3. 抽象方法不能被final和static修饰，因为抽象方法要被子类重写
4. 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用abstract 修饰
5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类
6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量

### 抽象类不能直接实例化对象
```java
Shape shape = new Shape();
```

```
// 编译出错
Error:(30, 23) java: Shape是抽象的; 无法实例化
```


###  抽象方法不能是 private 的
```java
abstract class Shape {
	abstract private void draw();
}
```

```
// 编译出错
Error:(4, 27) java: 非法的修饰符组合: abstract和private
```

**注意：抽象方法没有加访问限定符时，默认是public.**


### 抽象方法不能被final和static修饰，因为抽象方法要被子类重写
```java
public abstract class Shape {
abstract final void methodA();
abstract public static void methodB();
}
```

```
// 编译报错：
// Error:(20, 25) java: 非法的修饰符组合: abstract和final
// Error:(21, 33) java: 非法的修饰符组合: abstract和static
```




### 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用abstract 修饰
```java
public abstract class Shape {  
    // 抽象方法：被abstract修饰的方法，没有方法体  
    abstract public void draw();  
    abstract void calcArea();  
    // 抽象类也是类，也可以增加普通方法和属性  
    public double getArea(){  
        return area;  
    }  
    protected double area; // 面积  
}

//矩形类
public class Rect extends Shape {  
    private double length;  
    private double width;  
    Rect(double length, double width){  
        this.length = length;  
        this.width = width;  
    }  
    public void draw(){  
        System.out.println("矩形: length= "+length+" width= " + width);  
    }  
    public void calcArea(){  
        area = length * width;  
    }  
}


// 圆类：  
public class Circle extends Shape{  
    private double r;  
    final private static double PI = 3.14;  
    public Circle(double r){  
        this.r = r;  
    }  
    public void draw(){  
        System.out.println("圆：r = "+r);  
    }  
    public void calcArea(){  
        area = PI * r * r;  
    }  
}

// 三角形类：  
public abstract class Triangle extends Shape {  
    private double a;  
    private double b;  
    private double c;  
    @Override  
    public void draw() {  
        System.out.println("三角形：a = "+a + " b = "+b+" c = "+c);  
    }  
    // 三角形：直角三角形、等腰三角形等，还可以继续细化  
    //@Override  
    //double calcArea(); // 编译失败：要么实现该抽象方法，要么将三角形设计为抽象类  
}


```



## 抽象类的作用
抽象类本身不能被实例化, 要想使用, 只能创建该抽象类的子类. 然后让子类重写抽象类中的抽象方法.

有些同学可能会说了, 普通的类也可以被继承呀, 普通的方法也可以被重写呀, 为啥非得用抽象类和抽象方法呢?
>确实如此. 但是使用抽象类相当于多了一重编译器的校验.
>使用抽象类的场景就如上面的代码, 实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类了, 使用普通类编译器是不会报错的. 但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题.
>很多语法存在的意义都是为了 "预防出错", 例如我们曾经用过的 final 也是类似. 创建的变量用户不去修改, 不就相当于常量嘛? 但是加上 final 能够在不小心误修改的时候, 让编译器及时提醒我们.
>充分利用编译器的校验, 在实际开发中是非常有意义的.



# 接口








