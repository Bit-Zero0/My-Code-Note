
# 抽象类
## 抽象类接口
在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，**如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类**。 比如：
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230421220925.png)

在打印图形例子中, 我们发现, 父类 Shape 中的 draw 方法好像并没有什么实际工作, 主要的绘制图形都是由 Shape 的各种子类的 draw 方法来完成的. 像这种没有实际工作的方法, 我们可以把它设计成一个 **抽象方法(abstract method)**, 包含抽象方法的类我们称为 **抽象类(abstract class)**.

## 抽象类语法
在Java中，**一个类如果被 `abstract` 修饰称为抽象类，抽象类中被`abstract` 修饰的方法称为抽象方法，抽象方法不用给出具体的实现体**。
```java
// 抽象类：被abstract修饰的类  
public abstract class Shape {  
    // 抽象方法：被abstract修饰的方法，没有方法体  
    abstract public void draw();  
    abstract void calcArea();  
    
    // 抽象类也是类，也可以增加普通方法和属性  
    protected double area; // 面积
    
    public double getArea(){  
        return area;  
    }  
}
```
**注意：抽象类也是类，内部可以包含普通方法和属性，甚至构造方法**

## 抽象类特性
1. 抽象类不能直接实例化对象
2. 抽象方法不能是 private 的
3. 抽象方法不能被final和static修饰，因为抽象方法要被子类重写
4. 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用abstract 修饰
5. 抽象类中不一定包含抽象方法，但是有抽象方法的类一定是抽象类
6. 抽象类中可以有构造方法，供子类创建对象时，初始化父类的成员变量

### 抽象类不能直接实例化对象
```java
Shape shape = new Shape();
```

```
// 编译出错
Error:(30, 23) java: Shape是抽象的; 无法实例化
```


###  抽象方法不能是 private 的
```java
abstract class Shape {
	abstract private void draw();
}
```

```
// 编译出错
Error:(4, 27) java: 非法的修饰符组合: abstract和private
```

**注意：抽象方法没有加访问限定符时，默认是public.**


### 抽象方法不能被final和static修饰，因为抽象方法要被子类重写
```java
public abstract class Shape {
abstract final void methodA();
abstract public static void methodB();
}
```

```
// 编译报错：
// Error:(20, 25) java: 非法的修饰符组合: abstract和final
// Error:(21, 33) java: 非法的修饰符组合: abstract和static
```




### 抽象类必须被继承，并且继承后子类要重写父类中的抽象方法，否则子类也是抽象类，必须要使用abstract 修饰
```java
public abstract class Shape {  
    // 抽象方法：被abstract修饰的方法，没有方法体  
    abstract public void draw();  
    abstract void calcArea();  
    // 抽象类也是类，也可以增加普通方法和属性  
    public double getArea(){  
        return area;  
    }  
    protected double area; // 面积  
}

//矩形类
public class Rect extends Shape {  
    private double length;  
    private double width;  
    Rect(double length, double width){  
        this.length = length;  
        this.width = width;  
    }  
    public void draw(){  
        System.out.println("矩形: length= "+length+" width= " + width);  
    }  
    public void calcArea(){  
        area = length * width;  
    }  
}


// 圆类：  
public class Circle extends Shape{  
    private double r;  
    final private static double PI = 3.14;  
    public Circle(double r){  
        this.r = r;  
    }  
    public void draw(){  
        System.out.println("圆：r = "+r);  
    }  
    public void calcArea(){  
        area = PI * r * r;  
    }  
}

// 三角形类：  
public abstract class Triangle extends Shape {  
    private double a;  
    private double b;  
    private double c;  
    @Override  
    public void draw() {  
        System.out.println("三角形：a = "+a + " b = "+b+" c = "+c);  
    }  
    // 三角形：直角三角形、等腰三角形等，还可以继续细化  
    //@Override  
    //double calcArea(); // 编译失败：要么实现该抽象方法，要么将三角形设计为抽象类  
}


```



## 抽象类的作用
抽象类本身不能被实例化, 要想使用, 只能创建该抽象类的子类. 然后让子类重写抽象类中的抽象方法.

有些同学可能会说了, 普通的类也可以被继承呀, 普通的方法也可以被重写呀, 为啥非得用抽象类和抽象方法呢?
>确实如此. 但是使用抽象类相当于多了一重编译器的校验.
>使用抽象类的场景就如上面的代码, 实际工作不应该由父类完成, 而应由子类完成. 那么此时如果不小心误用成父类了, 使用普通类编译器是不会报错的. 但是父类是抽象类就会在实例化的时候提示错误, 让我们尽早发现问题.
>很多语法存在的意义都是为了 "预防出错", 例如我们曾经用过的 final 也是类似. 创建的变量用户不去修改, 不就相当于常量嘛? 但是加上 final 能够在不小心误修改的时候, 让编译器及时提醒我们.
>充分利用编译器的校验, 在实际开发中是非常有意义的.



# 接口

## 接口的概念
在现实生活中，接口的例子比比皆是，比如：笔记本上的USB口，电源插座等。

电脑的USB口上，可以插：U盘、鼠标、键盘...所有符合USB协议的设备
电源插座插孔上，可以插：电脑、电视机、电饭煲...所有符合规范的设备

通过上述例子可以看出：**接口就是公共的行为规范标准，大家在实现时，只要符合规范标准，就可以通用**。
**在Java中，接口可以看成是：多个类的公共规范，是一种引用数据类型**。


## 语法规则
接口的定义格式与定义类的格式基本相同，将class关键字换成 `interface` 关键字，就定义了一个接口。
```java
public interface 接口名称{
	// 抽象方法
	public abstract void method1(); // public abstract 是固定搭配，可以不写
	public void method2();
	abstract void method3();
	void method4();
	
	// 注意：在接口中上述写法都是抽象方法，跟推荐方式4，代码更简洁
}
```

==**提示:**==
>1. 创建接口时, 接口的命名一般以大写字母 I 开头.
>2. 接口的命名一般使用 "形容词" 词性的单词.
>3. 阿里编码规范中约定, 接口中的方法和属性不要加任何修饰符号, 保持代码的简洁性.

## 接口使用
**接口不能直接使用，必须要有一个"实现类"来"实现"该接口，实现接口中的所有抽象方法。**
```java
public class 类名称 implements 接口名称{
	// ...
}
```

注意：子类和父类之间是`extends` 继承关系，类与接口之间是 `implements` 实现关系。

### 案例

请实现笔记本电脑使用USB鼠标、USB键盘的例子
1. USB接口：包含打开设备、关闭设备功能
2. 笔记本类：包含开机功能、关机功能、使用USB设备功能
3. 鼠标类：实现USB接口，并具备点击功能
4. 键盘类：实现USB接口，并具备输入功能

**USB接口**
```java
public interface USB {  
    void OpenDrive();  
    void CloseDrive();  
}
```

**鼠标类，实现USB接口**
```java
public class Mouse implements USB{  
    @Override  
    public void OpenDrive() {  
        System.out.println("打开鼠标");  
    }  
  
    @Override  
    public void CloseDrive() {  
        System.out.println("关闭鼠标");  
    }  
  
    public void click(){  
        System.out.println("鼠标点击");  
    }  
}
```


**键盘类，实现USB接口**
```java
public class KeyBoard implements USB{  
    @Override  
    public void OpenDrive() {  
        System.out.println("打开键盘");  
    }  
  
    @Override  
    public void CloseDrive() {  
        System.out.println("关闭键盘");  
    }  
  
    public void inPut() {  
        System.out.println("键盘输入");  
    }  
}
```

**笔记本类：使用USB设备**
```java
public class Computer {  
    public void powerOn(){  
        System.out.println("打开笔记本电脑");  
    }  
  
    public void powerOff() {  
        System.out.println("关闭笔记本的电脑");  
    }  
    public void useDerive(USB usb) {  
        usb.OpenDrive();   //可以实现多态
        if(usb instanceof Mouse){  
            Mouse mouse = (Mouse) usb;  
            mouse.click();  
        }else if (usb instanceof KeyBoard){  
            KeyBoard keyBoard = (KeyBoard) usb;  
            keyBoard.inPut();  
        }  
        usb.CloseDrive();  
    }  
}
```

**测试类**
```java
public class TestUSB {  
    public static void main(String[] args) {  
        Computer computer = new Computer();  
       
		computer.powerOn();  //打开电脑
  
        computer.useDerive(new Mouse()); //打开鼠标  
  
        computer.useDerive(new KeyBoard());  //打开键盘
  
        computer.powerOff();  //关闭电脑
    }  
}
```

## 接口特性
1. **接口类型是一种引用类型，但是不能直接new 接口 的对象**
2. **接口中每一个方法都是public的抽象方法, 即接口中的方法会被隐式的指定为 public abstract**（只能是public abstract，其他修饰符都会报错)
3. 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现
4. 重写接口中方法时，不能使用default访问权限修饰
5. **接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量**
6. **接口中不能有静态代码块和构造方法**
7. 接口虽然不是类，但是接口编译完成后字节码文件的后缀格式也是`.class`
8. 如果类没有实现接口中的所有的抽象方法，则类必须设置为抽象类
9. jdk8中：接口中还可以包含default方法。

下面的代码，用的是上面案例的代码片段
### 接口类型是一种引用类型，但是不能直接new接口的对象
```java
public class TestUSB {
	public static void main(String[] args) {
		USB usb = new USB();
	}
}

// Error:(10, 19) java: day20210915.USB是抽象的; 无法实例化
```


### 接口中每一个方法都是public的抽象方法, 即接口中的方法会被隐式的指定为 public abstract（只能是public abstract，其他修饰符都会报错)
```java
public interface USB {
	private void openDevice();//此处不允许使用修饰符private
	void closeDevice();
}
```


### 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现
```java
public interface USB {
	void openDevice();
	
	void closeDevice(){
		System.out.println("关闭USB设备");
	}
}

// 编译失败：因为接口中的方式默认为抽象方法
// Error:(5, 23) java: 接口抽象方法不能带有主体
```


### 重写接口中方法时，不能使用default访问权限修饰
```java
public interface USB {
	void openDevice(); // 默认是public的
	void closeDevice(); // 默认是public的
}

public class Mouse implements USB {
	@Override
	void openDevice() {
		System.out.println("打开鼠标");
	}
	// ...
}

// 编译报错，重写USB中openDevice方法时，不能使用默认修饰符
// 正在尝试分配更低的访问权限; 以前为public
```


### 接口中可以含有变量，但是接口中的变量会被隐式的指定为` public static final 变量`
```java
public interface USB {
	double brand = 3.0; // 默认被：final public static修饰
	void openDevice();
	void closeDevice();
}

public class TestUSB {
	public static void main(String[] args) {
		System.out.println(USB.brand); // 可以直接通过接口名访问，说明是静态的
		
		USB.brand = 2.0; // 说明brand具有final属性
	}
}

// 编译报错：无法为最终变量brand分配值
```


### 接口中不能有静态代码块和构造方法
```java
public interface USB {
	// 编译失败
	public USB(){
	}
	
	{} // 编译失败
	
	void openDevice();
	void closeDevice();
}
```


## 实现多个接口
**注意：一个类实现多个接口时，每个接口中的抽象方法都要实现，否则类必须设置为抽象类**。
>提示, IDEA 中使用 ctrl + i 快速实现接口


在Java中，类和类之间是单继承的，一个类只能有一个父类，即**Java中不支持多继承**，但是**一个类可以实现多个接口**。下面通过类来表示一组动物.
```java
public class Animal {  
    protected String name;  
    
    public Animal(String name){  
        this.name = name;  
    }  
}
```

另外我们再提供一组接口, 分别表示 "会飞的", "会跑的", "会游泳的".写入不同的类文件中
```java
public interface Running {  
    void run();  
}

public interface Swimming {  
    void swim();  
}

public interface Flying {  
    void fly();  
}
```


接下来我们创建几个具体的动物
猫, 是会跑的.
```java
public class Cat extends Animal implements Running{  
    public Cat(String name) {  
        super(name);  
    }  
  
    @Override  
    public void run() {  
        System.out.println(this.name + "用四条腿跑");  
    }  
}
```


鱼, 是会游的.
```java
public class Fish extends Animal implements Swimming{  
    public Fish(String name){  
        super(name);  
    }  
  
    @Override  
    public void swim() {  
        System.out.println(this.name + "正在水中游");  
    }  
}
```


青蛙, 既能跑, 又能游(两栖动物)
```java
public class Frog extends Animal implements Running , Swimming{  
    Frog(String name){  
        super(name);  
    }  
  
    @Override  
    public void run() {  
        System.out.println(this.name + "正在往前跳");  
    }  
  
    @Override  
    public void swim() {  
        System.out.println(this.name + "正在蹬腿游泳");  
    }  
}
```


还有一种神奇的动物, 水陆空三栖, 叫做 "鸭子"
```java
public class Duck extends Animal implements Running , Swimming , Flying{  
    public Duck(String name){  
        super(name);  
    }  
  
    @Override  
    public void fly() {  
        System.out.println(this.name + "正在用翅膀飞");  
    }  
  
    @Override  
    public void run() {  
        System.out.println(this.name + "正在用两条腿跑");  
    }  
  
    @Override  
    public void swim() {  
        System.out.println(this.name + "正在漂在水上");  
    }  
}
```


上面的代码展示了 Java 面向对象编程中最常见的用法: 一个类继承一个父类, 同时实现多种接口.

继承表达的含义是 is - a 语义, 而接口表达的含义是 具有 xxx 特性 .
>猫是一种动物, 具有会跑的特性.
>青蛙也是一种动物, 既能跑, 也能游泳
>鸭子也是一种动物, 既能跑, 也能游, 还能飞

这样设计有什么好处呢? 时刻牢记多态的好处, 让程序猿**忘记类型**. 有了接口之后, 类的使用者就不必关注具体类型,而只关注某个类是否具备某种能力.
例如, 现在实现一个方法, 叫 "散步"
```java
public class Test {  
    public static void walk(Running running){  //散步方法
        System.out.println("我带着伙伴去散步");  
        running.run();  
    }  
  
    public static void main(String[] args) {  
        Cat cat = new Cat("小猫");  
        walk(cat);  
  
        Frog frog = new Frog("小青蛙");  
        walk(frog);  
    }  
}
```

执行结果：
```
我带着伙伴去散步
小猫正在用四条腿跑
我带着伙伴去散步
小青蛙正在往前跳
```


## 接口间的继承
在Java中，类和类之间是单继承的，一个类可以实现多个接口，接口与接口之间可以多继承。即：用接口可以达到多继承的目的。

接口可以继承一个接口, 达到复用的效果. 使用 `extends` 关键字.
```java
interface Running {  
    void run();  
}

interface Swimming {  
    void swim();  
}

// 两栖的动物, 既能跑, 也能游
interface Amphibious extends Running, Swimming {

}

class Frog implements Amphibious {
	...
}

```

通过接口继承创建一个新的接口 IAmphibious 表示 "两栖的". 此时实现接口创建的 Frog 类, 就继续要实现 run 方法, 也需要实现 swim 方法.
>接口间的继承相当于把多个接口合并在一起.

## 接口使用实例

### Comparable 接口
给对象数组排序
```java
class Student{  
    private String name;  
    private int score;  
  
    public Student(String name , int score)  
    {  
        this.name = name;  
        this.score = score;  
    }  
  
    @Override  
    public String toString() {  
        return "Student{" +  
                "name='" + name + '\'' +  
                ", score=" + score +  
                '}';  
    }  
}  
public class test1 {  
    public static void main(String[] args) {  
        Student[] students = new Student[] {  
                new Student("张三", 95),  
                new Student("李四", 96),  
                new Student("王五", 97),  
                new Student("赵六", 92),  
        };  
  
        Arrays.sort(students);  
        System.out.println(Arrays.toString(students));  
    }  
}
```

执行结果：
```
// 运行出错, 抛出异常.
Exception in thread "main" java.lang.ClassCastException: Student cannot be cast to java.lang.Comparable
```

仔细思考, 不难发现, 和普通的整数不一样, 两个整数是可以直接比较的, 大小关系明确. 而两个学生对象的大小关系怎么确定? 需要我们额外指定.

**让我们的 Student 类实现 Comparable 接口, 并实现其中的 compareTo 方法**
```java
class Student implements Comparable{  //引入Comparable接口
    private String name;  
    private int score;  
  
    public Student(String name , int score)  
    {  
        this.name = name;  
        this.score = score;  
    }  
  
    @Override  
    public String toString() {  
        return "Student{" +  
                "name='" + name + '\'' +  
                ", score=" + score +  
                '}';  
    }  
  
    @Override  
    public int compareTo(Object o) {  //实现Comparable接口中的compareTo方法
        Student s = (Student)o;  
        if (this.score > s.score) {  
            return -1;  
        } else if (this.score < s.score) {  
            return 1;  
        } else {  
            return 0;  
        }  
    }  
}  
public class test1 {  
    public static void main(String[] args) {  
        Student[] students = new Student[] {  
                new Student("张三", 95),  
                new Student("李四", 96),  
                new Student("王五", 97),  
                new Student("赵六", 92),  
        };  
  
        Arrays.sort(students);  
        System.out.println(Arrays.toString(students));  
    }  
}
```
在 sort 方法中会自动调用 `compareTo` 方法. `compareTo` 的参数是 Object , 其实传入的就是 Student 类型的对象.

然后比较当前对象和参数对象的大小关系(按分数来算).
- 如果当前对象应排在参数对象之前, 返回小于 0 的数字;
- 如果当前对象应排在参数对象之后, 返回大于 0 的数字;
- 如果当前对象和参数对象不分先后, 返回 0;

再次执行程序, 结果就符合预期了. 
```
[Student{name='王五', score=97}, Student{name='李四', score=96}, Student{name='张三', score=95}, Student{name='赵六', score=92}]
```

**注意事项: 对于 sort 方法来说, 需要传入的数组的每个对象都是 "可比较" 的, 需要具备 compareTo 这样的能力. 通过重写 compareTo 方法的方式, 就可以定义比较规则.**

### Comparator 接口
在上面的案例中使用Comparable , 我们可以发现,这种比较排序是很不方便的, 如果之后我们需要更改排序方式,就需要到`compareTo`方法中进行更改, 如果这是一个大程序,很有用导致程序中依赖此方法的模块无法正常使用, 导致整个程序无法运行.

Comparator接口就是能解决这个问题的.
```java
class Student {    
    public String name;  
    public int score;  
  
    public Student(String name , int score)  
    {  
        this.name = name;  
        this.score = score;  
    }  
  
    @Override  
    public String toString() {  
        return "Student{" +  
                "name='" + name + '\'' +  
                ", score=" + score +  
                '}';  
    }  
}  

//名字比较
class NameComparator implements Comparator<Student>{  
    @Override  
    public int compare(Student o1, Student o2) {  
        return o1.name.compareTo(o2.name)  ;  
    }  
}  

//分数比较
class ScoreComparator implements Comparator<Student> {  
    @Override  
    public int compare(Student o1, Student o2) {  
        return o1.score - o2.score;  
    }  
}  
  
  
public class test1 {  
    public static void main(String[] args) {  
        Student[] students = new Student[] {  
                new Student("张三", 95),  
                new Student("李四", 96),  
                new Student("王五", 97),  
                new Student("赵六", 92),  
        };  
        //定义比较器
        ScoreComparator scoreComparator = new ScoreComparator();  
  
        NameComparator nameComparator = new NameComparator();  
  
        Arrays.sort(students , scoreComparator);  
        System.out.println(Arrays.toString(students));  
    }  
}
```


## Clonable 接口和深拷贝
Java 中内置了一些很有用的接口, `Clonable` 就是其中之一.
`Object` 类中存在一个 `clone` 方法, 调用这个方法可以创建一个对象的 "拷贝". 但是要想合法调用 `clone` 方法, 必须要先实现 `Clonable` 接口, 否则就会抛出 `CloneNotSupportedException` 异常.
```java
class Animal implements Cloneable {  
    private String name;  
    @Override  
    public Animal clone() {  
        Animal o = null;  
        try {  
            o = (Animal)super.clone();  
        } catch (CloneNotSupportedException e) {  
            e.printStackTrace();  
        }  
        return o;  
    }  
}  

public class test1 {  
    public static void main(String[] args) {  
        Animal animal = new Animal();  
        Animal animal2 = animal.clone();  
        System.out.println(animal == animal2);  
    }  
}
```

执行结果为: `false`

### 浅拷贝 VS 深拷贝
**Cloneable 拷贝出的对象是一份 "浅拷贝"**
观察以下代码:
```java
class Money{  
    public double m = 99.99;  
}  
  
class Person implements Cloneable {  
    public Money money = new Money();  
  
    @Override  
    protected Object clone() throws CloneNotSupportedException {  
        return super.clone();  
    }  
}  
  
public class TestDemo3 {  
    public static void main(String[] args) throws CloneNotSupportedException {  
        Person person1 = new Person();  
        Person person2 = (Person) person1.clone();  
        System.out.println("通过person2修改前的结果");  
        
        System.out.println(person1.money.m);  
        System.out.println(person2.money.m);  
        
        person2.money.m = 13.6;  
        System.out.println("通过person2修改后的结果");  
        System.out.println(person1.money.m);  
        System.out.println(person2.money.m);  
    }  
}
```

执行结果:
```
通过person2修改前的结果
99.99
99.99
通过person2修改后的结果
13.6
13.6
```

如上代码，我们可以看到，通过clone，我们只是拷贝了Person对象。但是Person对象中的Money对象，并
没有拷贝。通过person2这个引用修改了m的值后，person1这个引用访问m的时候，值也发生了改变。这里
就是发生了浅拷贝。那么同学们想一下如何实现深拷贝呢？

### 实现深拷贝
为Money类也实现Cloneable接口
```java
class Money implements Cloneable{  
    public double m = 99.99;  
  
    @Override  
    protected Object clone() throws CloneNotSupportedException {  
        return super.clone();  
    }  
}  
  
class Person implements Cloneable {  
    public Money money = new Money();  
  
    @Override  
    protected Object clone() throws CloneNotSupportedException {  
        Person person = (Person) super.clone();  
        person.money  = (Money)this.money.clone();  
        return person;  
    }  
}  
  
public class TestDemo3 {  
    public static void main(String[] args) throws CloneNotSupportedException {  
        Person person1 = new Person();  
        Person person2 = (Person) person1.clone();  
        System.out.println("通过person2修改前的结果");  
        System.out.println(person1.money.m);  
        System.out.println(person2.money.m);  
        person2.money.m = 13.6;  
        System.out.println("通过person2修改后的结果");  
        System.out.println(person1.money.m);  
        System.out.println(person2.money.m);  
    }  
}
```
 执行结果
```
通过person2修改前的结果
99.99
99.99
通过person2修改后的结果
99.99
13.6
```

# 抽象类和接口的区别
抽象类和接口都是 Java 中多态的常见使用方式. 都需要重点掌握. 同时又要认清两者的区别(重要!!! 常见面试题).

==**核心区别**==: **抽象类中可以包含普通方法和普通字段, 这样的普通方法和字段可以被子类直接使用(不必重写), 而接口中不能包含普通方法, 子类必须重写所有的抽象方法**.

如之前写的 Animal 例子. 此处的 Animal 中包含一个 name 这样的属性, 这个属性在任何子类中都是存在的. 因此此处的 Animal 只能作为一个抽象类, 而不应该成为一个接口.
```java
class Animal {
	protected String name;
	
	public Animal(String name) {
		this.name = name;
	}
}
```

>再次提醒:
>抽象类存在的意义是为了让编译器更好的校验, 像 Animal 这样的类我们并不会直接使用, 而是使用它的子类.
>万一不小心创建了 Animal 的实例, 编译器会及时提醒我们.

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230422144803.png)
