
# 面试题
redis到底是单线程还是多线程?

IO多路复用听说过吗?

redis为什么快?


# Redis为什么选择单线程?
这种问法其实并不严谨，为啥这么说呢?

>Redis的版本很多3.x、4.x、6.x，版本不同架构也是不同的，不限定版本问是否单线程也不太严谨。
>1. 版本3.x ，最早版本，也就是大家口口相传的redis是单线程，阳哥2016年讲解的redis就是3.X的版本。
>2. 版本4.x，严格意义来说也不是单线程，而是负责处理客户端请求的线程是单线程，但是**开始加了点多线程的东西(异步删除)**。
>3. 2020年5月版本的**6.0.x后及2022年出的7.0版本后**，**告别了大家印象中的单线程，用一种全新的多线程来解决问题**。---实锤

有几个里程碑式的重要版本
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504155021.png)


## Redis的单线程
主要是指Redis的网络IO和键值对读写是由一个线程来完成的，Redis在处理客户端的请求时包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。这也是Redis对外提供键值存储服务的主要流程。
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504155200.png)

但Redis的其他功能，**比如持久化RDB、AOF、异步删除、集群数据同步等等，其实是由额外的线程执行的。**

**Redis命令工作线程是单线程的，但是，整个Redis来说，是多线程的**；



## Redis3.x 单线程时代性能依旧很快的主要原因
- 基于内存操作:Redis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高;
- 数据结构简单: Redis 的数据结构是专门设计的，而这些简单的数据结构的查我和操作的时间大部分复杂度都是O(1)，因此性能比较高;
- 多路复用和非阻塞I/O:Redis使用/O多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的开销，同时也避免了I/0阻塞操作
- 避免上下文切换:因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程不会导致死锁门题的发生

官网原话
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504155704.png)

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504155710.png)
他的大体意思是说 Redis 是基于内存操作的，**因此他的瓶颈可能是机器的内存或者网络带宽而并非 CPU**，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了，况且使用多线程比较麻烦。**但是在 Redis 4.0 中开始支持多线程了，例如后台删除、备份等功能**。

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504155755.png)

**简单来说，Redis4.0之前一直采用单线程的主要原因有以下三个：**
>1. 使用单线程模型是 Redis 的开发和维护更简单，因为单线程模型方便开发和调试；
>2. 即使使用单线程模型也并发的处理多客户端的请求，主要使用的是IO多路复用和非阻塞IO；
>3. 对于Redis系统来说，主要的性能瓶颈是内存或者网络带宽而并非 CPU。


# 既然单线程这么好，为什么逐渐又加入了多线程特性?

## 单线程的烦恼
正常情况下使用 `del` 指令可以很快的删除数据，**而当被删除的 key 是一个非常大的对象时，例如时包含了成千上万个元素的 hash 集合时，那么 del 指令就会造成 Redis 主线程卡顿**。

这就是redis3.x单线程时代最经典的故障，大key删除的头疼问题，

由于redis是单线程的，`del  bigKey .....`

等待很久这个线程才会释放，类似加了一个synchronized锁，你可以想象高并发下，程序堵成什么样子？


## bigkey删除问题解决
比如当我（Redis）需要删除一个很大的数据时，因为是单线程原子命令操作，这就会导致 Redis 服务卡顿，

于是在 Redis 4.0 中就新增了多线程的模块，当然此版本中的多线程主要是为了解决删除数据效率比较低的问题的。

```
unlink key

flushdb async

flushall async
```
这三个命令就是把删除工作交给了后台的小弟（子线程）异步来删除数据了。

>- 因为Redis是单个主线程处理，redis之父antirez一直强调"Lazy Redis is better Redis".
>- 而lazy free的本质就是把某些cost(主要时间复制度，占用主线程cpu时间片)较高删除操作，
>- 从redis主线程剥离让bio子线程来处理，极大地减少主线阻塞时间。从而减少删除导致性能和稳定性问题。


在Redis 4.0就引入了多个线程来实现数据的异步惰性删除等功能，但是其处理读写请求的仍然只有一个线程，所以仍然算是狭义上的单线程



# Redis6/7 多线程特性和IO多路复用
**对于Redis主要的性能瓶颈是内存或者网络带宽而并非CPU**。
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504161424.png)
**但是现在我们的电脑内存基本最少都是8GB了, 服务器级别甚至能达到几TB , 所以内存也不再是限制** ,所以==**目前的限制只有网络IO**== 





## Redis的瓶颈: 网络IO
**在Redis6/7中，非常受关注的第一个新特性就是多线程**。

这是因为，Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写）。但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的。

随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络IO的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度,

为了应对这个问题:
>**采用多个IO线程来处理网络请求，提高网络请求处理的并行度，Redis6/7就是采用的这种方法**。

但是，Redis的多IO线程只是用来处理网络请求的，**对于读写操作命令Redis仍然使用单线程来处理**。这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程**互斥加锁机制了(不管加锁操作处理)**，这样一来，Redis线程模型实现就简单了


## 主线程和IO线程之间怎么协作
预备知识[[网络编程套接字]]

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504162019.png)

**阶段一:服务端和客户端建立Socket连接，并分配处理线程**
>首先，主线程负责接收建立连接请求。当有客户端请求和实例建立Socket连接时，主线程会创建和客户端的连接，并把Socket放入全局等待队列中。紧接着，主线程通过轮询方法把Socket连接分配给IO线程。

**阶段二:IO线程读取并解析请求**
>主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求读取和解析。因为有多个IO线程在并行处理，所以，这个过程很快就可以完成。

**阶段三:主线程执行请求操作**
>等到IO线程解析完请求，主线程还是会以单线程的方式执行这些命令操作。

**阶段四:IO线程回写Socket和主线程清空全局队列**
>当主线程执行完请求操作后，会把需要返回的结果写入缓冲区，然后，主线程会阻塞等待I0线程，把这些结果回写到Socket中，并返回给客户端。
>和IO线程读取和解析请求一样，I0线程回写Socket时，也是有多个线程在并发执行，所以回写Socket的速度也很快。等到IO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504162127.png)


# Unix网络编程中的五种IO模型
![[网络IO模型#五种IO模型]]

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504163101.png)

## 面试题： redis为什么这么快
IO多路复用+epoll函数使用，才是redis为什么这么快的直接原因，而不是仅仅单线程命令+redis安装在内存中。


# 总结
==**Redis工作线程是单线程的，但是,整个Redis来说，是多线程的;**==

Redis6→7将网络数据读写、请求协议解析通过多个IO线程的来处理 ，对于真正的命令执行来说，仍然使用主线程操作，一举两得. 
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504163726.png)



## 主线程和IO线程之间怎么协作(精简版)
I/O 的读和写本身是堵塞的，比如当 socket 中有数据时，Redis 会通过调用先将数据从内核态空间拷贝到用户态空间，再交给 Redis 调用，而这个拷贝的过程就是阻塞的，当数据量越大时拷贝所需要的时间就越多，而这些操作都是基于单线程完成的。
![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504163355.png)

从Redis6开始，就新增了多线程的功能来提高 I/O 的读写性能，他的主要实现思路是将主线程的 IO 读写任务拆分给一组独立的线程去执行，这样就可以使多个 socket 的读写可以并行化了，采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504163407.png)

结合上图可知，网络IO操作就变成多线程化了，其他核心部分仍然是线程安全的，是个不错的折中办法。


# Redis7如何开启多线程
如果你在实际应用中，发现Redis实例的CPU开销不大但吞吐量却没有提升，可以考虑使用Redis7的多线程机制，加速网络处理，进而提升实例的吞吐量

>Redis7将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理8W到10W的QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。

在**Redis6.0及7后，多线程机制默认是关闭的**，如果需要使用多线程功能，需要在redis.conf中完成两个设置

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504164053.png)

![image.png](https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230504164059.png)

1. 设置`io-thread-do-reads`配置项为`yes`，表示启动多线程。

2. 设置线程个数。关于线程数的设置，官方的建议是如果为 4 核的 CPU，建议线程数设置为 2 或 3，**如果为 8 核 CPU 建议线程数设置为 6**，线程数一定要小于机器核数，线程数并不是越大越好。





