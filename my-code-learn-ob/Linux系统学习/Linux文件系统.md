# 磁盘的结构
![[Pasted image 20220819122712.png]]
>[!tip] 访问文件数据的顺序
>盘面(磁头) ——> 磁道 ——> 扇区

## LBA
可不可以将盘片想象成为线性的结构

![[Pasted image 20220819123603.png]]
LBA就是就是**抽象扇区**的**下标**，通过LBA就能找到对应的扇区，实际关系可以参考[[Linux程序地址空间|虚拟地址和物理地址]]的关系。


# Linux特有的EXT系列的文件系统

若磁盘有1T的空间，我们要怎么管理文件？
其实可以设想一下我们国家的管理。
>[!tip] 国家的管理
>国->省->市->县->乡->镇->村

所以==一个硬盘可以分为好几个区[大小可以不相同]，在每个区中又可以进行细分，循环往复==。但是和现实不同的是，**每一个分区的管理形式基本都是一样的** 。
>如电脑上的 C D E这些盘。

![[Pasted image 20220819135346.png]]
1. 分区 ： 将大磁盘 ，分为小空间
2. 格式化：在分区中写入文件系统

## inode
Linux中文件名在系统层面没有意义!  是给用户使用的!
Linux中真真标识一个文件，使通过文件的**inode编号**!!   **一个文件一个inode** ! 

![[Pasted image 20220819140451.png]]
如： 我们在磁盘中的其中一个分区，我们可以看到在分区中的文件管理系统。

- ==Boot Block==:  启动块，不一定每个分区都有。
- ==Block Group==：ext2文件系统会根据分区的大小划分为数个Block Group。而每个Block Group都有着相同的结构组成。政府管理各区的例子
- ==Super Block[超级块]==：**存放文件系统本身的结构信息**。记录的信息主要有：bolck 和 inode的总量，未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了
- ==Group Descriptor Table[GDT]==：块组描述符，描述块组属性信息，有兴趣的同学可以在了解一下，如上图，我们的 GDT 就是 0；
- ==Block Bitmap[块位图]==：**Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用**。
- ==inode Bitmap[inode位图]==：**每个bit表示一个inode是否空闲可用**。
- ==inode Table==: **存放文件属性** 如 文件大小，所有者，最近修改时间等。
- ==Data blocks[数据区]==：**存放文件内容**。


而我们主要学习的是**Block Bitmap** ,**inode Bitmap** , **inode Table** , **Data blocks**
![[Pasted image 20220819142632.png]]

每一个 inode都可以理解为一个结构体
```c
struct inode{
	文件的所有属性
	int inode_number 数据
	int blocks[32] //对应的文件内容的data blocks的下标
	int ref //表示当前这个inode被多少链接指向了
}
```
当我们得到文件的inode时，怎么找到它的文件内容呢？ ==就靠inode结构体中的**blocks[]**== 。


## inode bitmap的作用
OS 怎么知道 inode Table中的那些inode没有被使用呢？ ==就靠**inode bitmap**==

inode bitmap其实就是一个inode位图
![[Pasted image 20220819143812.png]]

**从右向左看**，
比特位的位置含义：inode编号。
比特位的内容含义：特定iode''是否"被占用。
> 1 则表示被占用了，0则表示没有。


# 目录是文件吗？

目录有inode？  ==**有！**==
目录有数据吗？  ==**有！**==
目录的数据块里放了什么？  ==**文件名和inode的映射关系！**==

你所创建的所有文件，全部一定在一个特定的目录下! ! !


图中指令在文件系统的步骤是什么？
![[Pasted image 20220819145213.png]]
在创建`lesson409`时，我们就会得到它的 inode 了
 > [!note] 步骤
 > cat myfile.c --> 先查看lesson409 --> data block --> 241234[inode] : 文件名 -->241234[inode]-->inode table--> inode-->block[]-->打印文件内容；


# 误删文件怎么办？
当我们删除文件时，其实只是将 `inode bitmap` 中相应的 inode 由1至0, 文件属性和内容是还在的，但是如果有新文件占用这个inode时，之前的内容就会被覆盖。

所以什么都别做，找人，如果你在新建文件，可能会使误删文件的inode被占用，导致无法恢复。



# 硬链接 and 软链接

## 软硬链接的原理
### 硬链接(hard link)：
文件A是文件B的硬链接，则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。

### 软链接(soft link)：
A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。


## 软链接
==软连接==和==windows中的中快捷方式==很像。

### 使用方式
使用 [[linux常用命令#ln| ln -s]] 指令即可创建软链接

如上级目录`lesson`的一个可执行文件 `myproc` 链接到`lesson409`目录
![[Pasted image 20220819160857.png]]

进入`lesson409`目录
输入指令 `ln -s ../myproc myexe` , 链接名为 `myexe` .
![[Pasted image 20220819161217.png]]
此时就可以在`lesson409`目录中运行被链接的文件了


## 硬链接
硬链接本质是根本就**不是一个独立的文件**，==**而是一个文件名和inode编号的映射关系**==，因为**自己没有独立的inode** !
创建硬链接，本质是在特定的目录下，填写一对文件名和inode的映射关系！

在我们进行 [[linux常用命令#ls|ls指令]]时，被红框选中的那栏就是文件对应的硬链接数量。
![[Pasted image 20220819161402.png]]
而硬链接数其实采用的就是 引用计数的方式，在 inode结构体中有个 `int ref` 来进行引用计数。


### 使用方式
使用[[linux常用命令#ln|ln指令]]，但是不带参数。
![[Pasted image 20220819161926.png]]
创建成功
![[Pasted image 20220819162044.png]]


### 目录的硬链接数
![[Pasted image 20220819163353.png]]
当我们创建一个目录时，会发现此目录的硬链接数是2。

>[!question]+ 为什么？
>当我们进入test目录，使用 `ls -al` 指令，会发现
>![[Pasted image 20220819163444.png]]
> `.`  的inode是和test目录的inode是相同的，所以硬链接数是2。

>[!question]+ 如果再test目录中在添加一个 t1目录呢，test目录的硬连接数是多少？
> ![[Pasted image 20220819163804.png]]
> 发现 test目录的硬链接变为了 3，怎么回事？
> 进入t1目录看看
> ![[Pasted image 20220819164031.png]]
> 发现 `..` 的 inode 和test目录的inode是一致的，所以test的硬链接数是3
> 










