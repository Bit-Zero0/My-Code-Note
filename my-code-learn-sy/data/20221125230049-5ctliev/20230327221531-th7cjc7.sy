{
	"ID": "20230327221531-th7cjc7",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230327221531-th7cjc7",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230328215053-ecg6b27\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20230327221531-tff40nm\u0026quot;,\u0026quot;scrollTop\u0026quot;:2800,\u0026quot;focusId\u0026quot;:\u0026quot;20230328215053-e4ucntt\u0026quot;,\u0026quot;focusStart\u0026quot;:3,\u0026quot;focusEnd\u0026quot;:3}",
		"title": "哈希表",
		"updated": "20230424223335"
	},
	"Children": [
		{
			"ID": "20230424223320-j6nvo1a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223320-j6nvo1a"
			}
		},
		{
			"ID": "20230424223321-n0ui0d5",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230424223321-n0ui0d5",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "383. 赎金信"
				}
			]
		},
		{
			"ID": "20230424223321-62d0gzw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-62d0gzw",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/ransom-note/",
					"TextMarkTextContent": "383. 赎金信"
				}
			]
		},
		{
			"ID": "20230424223321-9aurrbl",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230424223321-9aurrbl",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230424223321-vzighea",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-vzighea",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。"
				}
			]
		},
		{
			"ID": "20230424223321-pmuh77m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-pmuh77m",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。"
				}
			]
		},
		{
			"ID": "20230424223321-iitj4ap",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-iitj4ap",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "依然是数组在哈希法中的应用。"
				}
			]
		},
		{
			"ID": "20230424223321-ah0qprs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-ah0qprs",
				"updated": "20230424223335"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这道题目和"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20230327221545-mzjkasp",
					"TextMarkBlockRefSubtype": "d",
					"TextMarkTextContent": "242. 有效的字母异位词"
				},
				{
					"Type": "NodeText",
					"Data": "很像，相当于求 字符串a 和 字符串b 是否可以相互组成 ，而这道题目是求 字符串a能否组成字符串b，而不用管字符串b 能不能组成字符串a。"
				}
			]
		},
		{
			"ID": "20230424223321-aw64d9c",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230424223321-aw64d9c",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "c++题解"
				}
			]
		},
		{
			"ID": "20230424223321-97abmqc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230424223321-97abmqc",
				"updated": "20230424223321"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        int record[26] = {0};\n        if(ransomNote.size() \u003e magazine.size())\n        {\n            return false;\n        }\n        for(int i = 0 ; i \u003c magazine.size() ; i++)\n        {\n            record[magazine[i] - 'a']++;// 通过recode数据记录 magazine里各个字符出现次数\n        } \n\n        for(int i = 0; i \u003c ransomNote.size() ; i++)\n        {\n            record[ransomNote[i] - 'a']--;\n            if(record[ransomNote[i]-'a'] \u003c 0)// 如果小于零说明ransomNote里出现的字符，magazine没有\n            { \n                return false;\n            }\n        }\n        return true;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230424223321-gkieawo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230424223321-gkieawo"
			}
		},
		{
			"ID": "20230328215053-ecg6b27",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230328215053-ecg6b27",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "454. 四数相加 II"
				}
			]
		},
		{
			"ID": "20230328215053-8cigts7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-8cigts7",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/4sum-ii/",
					"TextMarkTextContent": "454. 四数相加 II"
				}
			]
		},
		{
			"ID": "20230328215053-ftc6fml",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328215053-ftc6fml",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230328215053-29uskho",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-29uskho",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "而这道题目是四个独立的数组，只要找到"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "nums1[i] + nums2[j] + nums2[k] + nums4[l] = 0"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "就可以，不用考虑有重复的四个元素相加等于0的情况"
				}
			]
		},
		{
			"ID": "20230328215053-10o5wtg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-10o5wtg",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本题解题步骤："
				}
			]
		},
		{
			"ID": "20230328215053-ifhvbug",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230328215053-ifhvbug",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"ID": "20230328215053-43eofui",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230328215053-43eofui",
						"updated": "20230328215053"
					},
					"Children": [
						{
							"ID": "20230328215053-hnlrt76",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328215053-hnlrt76",
								"updated": "20230328215053"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。"
								}
							]
						}
					]
				},
				{
					"ID": "20230328215053-n8rrfso",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230328215053-n8rrfso",
						"updated": "20230328215053"
					},
					"Children": [
						{
							"ID": "20230328215053-xz0inzo",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328215053-xz0inzo",
								"updated": "20230328215053"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。"
								}
							]
						}
					]
				},
				{
					"ID": "20230328215053-8ebmorr",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230328215053-8ebmorr",
						"updated": "20230328215053"
					},
					"Children": [
						{
							"ID": "20230328215053-8olxv5w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328215053-8olxv5w",
								"updated": "20230328215053"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "定义int变量count，用来统计 a+b+c+d = 0 出现的次数。"
								}
							]
						}
					]
				},
				{
					"ID": "20230328215053-gfyuqks",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230328215053-gfyuqks",
						"updated": "20230328215053"
					},
					"Children": [
						{
							"ID": "20230328215053-b1yua0a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328215053-b1yua0a",
								"updated": "20230328215053"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。"
								}
							]
						}
					]
				},
				{
					"ID": "20230328215053-yavs30w",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20230328215053-yavs30w",
						"updated": "20230328215053"
					},
					"Children": [
						{
							"ID": "20230328215053-tkyznhq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230328215053-tkyznhq",
								"updated": "20230328215053"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后返回统计值 count 就可以了"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230328215053-w624gki",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328215053-w624gki",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230328215053-e4ucntt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328215053-e4ucntt",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    int fourSumCount(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2, vector\u003cint\u003e\u0026 nums3, vector\u003cint\u003e\u0026 nums4) {\n        unordered_map\u003cint , int\u003e map;//key:a+b的数值，value:a+b数值出现的次数 \n        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中\n        for(int a : nums1)\n        {\n            for(int b : nums2)\n            {\n                map[a+b]++;\n            }\n        }\n\n        // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。\n        int count = 0;\n        for(int c : nums3)\n        {\n            for(int d : nums4)\n            {\n                if(map.find(0-(c+d)) != map.end())\n                {\n                    count += map[0 - (c+d)];\n                }\n            }\n        }\n        return count;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328215053-pk1w3so",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230328215053-pk1w3so",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "1. 两数之和"
				}
			]
		},
		{
			"ID": "20230328215053-ckhx5xl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-ckhx5xl",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/two-sum/",
					"TextMarkTextContent": "1. 两数之和"
				}
			]
		},
		{
			"ID": "20230328215053-osfi2e1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328215053-osfi2e1",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230328215053-m7i1z0r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-m7i1z0r",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要一个集合来存放我们遍历过的元素，然后在遍历数组的时候去询问这个集合，某元素是否遍历过，也就是 是否出现在这个集合。"
				}
			]
		},
		{
			"ID": "20230328215053-zcscdik",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-zcscdik",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以 map中的存储结构为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": " {key：数据元素，value：数组元素对应的下标}"
				},
				{
					"Type": "NodeText",
					"Data": "​。"
				}
			]
		},
		{
			"ID": "20230328215053-fl72ss2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215053-fl72ss2",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在遍历数组的时候，只需要向map去查询是否有和目前遍历元素匹配的数值，如果有，就找到的匹配对，如果没有，就把目前遍历的元素放进map中，因为map存放的就是我们访问过的元素。"
				}
			]
		},
		{
			"ID": "20230328215053-sfwtr4g",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230328215053-sfwtr4g",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230328215053-wmc9s7u",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230328215053-wmc9s7u",
				"updated": "20230328215053"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 nums, int target) {\n        unordered_map\u003cint,int\u003e map;\n        for(int i = 0; i \u003c nums.size() ; i++)\n        {\n            auto iter = map.find(target - nums[i]);\n             // 遍历当前元素，并在map中寻找是否有匹配的key\n            if(iter != map.end())\n            {\n                return {iter-\u003esecond, i};\n            }\n            else \n            {\n                map.insert({nums[i] , i});// 如果没找到相匹配的值，就把访问过的元素和下标加入到map中\n            }\n        }\n        return {};\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230328215043-op33k15",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215043-op33k15"
			}
		},
		{
			"ID": "20230328215043-vnaob5l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230328215043-vnaob5l"
			}
		},
		{
			"ID": "20230327221545-zhpkacn",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221545-zhpkacn",
				"updated": "20230328215047"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "202. 快乐数"
				}
			]
		},
		{
			"ID": "20230327221545-iuqhqac",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-iuqhqac",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/happy-number/",
					"TextMarkTextContent": "202. 快乐数"
				}
			]
		},
		{
			"ID": "20230327221545-ghwp8uo",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-ghwp8uo",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327221545-71w6tqn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-71w6tqn",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这题的难点在于跳出死循环, unordered_set是不会存储重复的数据的, 所以我们可以将已经得到的sum加入到unordered_set中 , 在循环中,如果我们再次得到重复的sum, 表示 n 不是快乐数 , 则可以退出循环."
				}
			]
		},
		{
			"ID": "20230327221545-yeh0zw6",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-yeh0zw6",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221545-t18mjvo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221545-t18mjvo",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    int getSum(int n)\n    {\n        int sum = 0;\n        while(n)\n        {\n            sum += (n % 10) * (n % 10);\n            n /= 10;\n        }\n\n        return sum;\n    }\n\n    bool isHappy(int n) {\n        unordered_set\u003cint\u003e set;\n        while(1)\n        {\n            int sum = getSum(n);\n            if(sum == 1)\n                return true;\n        \n            if(set.find(sum) != set.end())\n            {\n                return false;\n            }\n            else\n            {\n                set.insert(sum);\n            }\n            n = sum;\n        } \n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221545-mzjkasp",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221545-mzjkasp",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "242. 有效的字母异位词"
				}
			]
		},
		{
			"ID": "20230327221545-a2cfly1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-a2cfly1",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/valid-anagram/",
					"TextMarkTextContent": "242. 有效的字母异位词"
				}
			]
		},
		{
			"ID": "20230327221545-waauq3l",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-waauq3l",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327221545-npcceet",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-npcceet",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为本题中只使用小写字母 , 所以使用哈希的思路,将26个字母映射到数组中, 字母每出现一次则被映射到的位置 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "++"
				},
				{
					"Type": "NodeText",
					"Data": "​ ,  在与另一个数组进行比对时,该数组映射的相对位置 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "--"
				},
				{
					"Type": "NodeText",
					"Data": "​ . 最后若数组中所有元素都是 0 ,则是异位词 true , 反之不为异位词 false"
				}
			]
		},
		{
			"ID": "20230327221545-x69fard",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-x69fard",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221545-i9eijyd",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221545-i9eijyd",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int record[26] = {0};\n        for(int i = 0 ; i \u003c s.size() ; i++)//先将s映射到数组中\n        {\n            record[s[i] - 'a']++;\n        }\n\n        for(int i = 0 ; i \u003c t.size() ; i++) \n        {\n            record[t[i] -'a']--;\n        }\n\n        for(int i = 0 ; i \u003c 26 ; i++)\n        {\n            if(record[i] != 0)\n                return false;\n        }\n\n        return true;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221545-6ejecw1",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221545-6ejecw1",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "349. 两个数组的交集"
				}
			]
		},
		{
			"ID": "20230327221545-m10pcgc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-m10pcgc",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/intersection-of-two-arrays/",
					"TextMarkTextContent": "349. 两个数组的交集"
				}
			]
		},
		{
			"ID": "20230327221545-a510k04",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-a510k04",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327221545-oqg0wdb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221545-oqg0wdb",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用unordered_set来进行解决."
				}
			]
		},
		{
			"ID": "20230327221545-ks9ll6v",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230327221545-ks9ll6v",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"ID": "20230327221545-o4s7ai6",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221545-o4s7ai6",
						"updated": "20230327221545"
					},
					"Children": [
						{
							"ID": "20230327221545-8c0kmfa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221545-8c0kmfa",
								"updated": "20230327221545"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用unordered_set定义一个"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "result_set"
								},
								{
									"Type": "NodeText",
									"Data": "​来装 交集结果."
								}
							]
						}
					]
				},
				{
					"ID": "20230327221545-s1pkzep",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221545-s1pkzep",
						"updated": "20230327221545"
					},
					"Children": [
						{
							"ID": "20230327221545-7qccq3t",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221545-7qccq3t",
								"updated": "20230327221545"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用unordered_set定义一个"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "nums_set"
								},
								{
									"Type": "NodeText",
									"Data": "​来将"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "nums1"
								},
								{
									"Type": "NodeText",
									"Data": "​中的数据导入其中,"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "nums_set"
								},
								{
									"Type": "NodeText",
									"Data": "​是会进行 去重操作 的."
								}
							]
						}
					]
				},
				{
					"ID": "20230327221545-1qjozsd",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221545-1qjozsd",
						"updated": "20230327221545"
					},
					"Children": [
						{
							"ID": "20230327221545-i9e1wk4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221545-i9e1wk4",
								"updated": "20230327221545"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "nums2"
								},
								{
									"Type": "NodeText",
									"Data": "​中的元素 与"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "nums_set"
								},
								{
									"Type": "NodeText",
									"Data": "​中的元素进行对比 , 将找到的交集的插入到"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "result_set"
								},
								{
									"Type": "NodeText",
									"Data": "​中."
								}
							]
						}
					]
				},
				{
					"ID": "20230327221545-la1lzxk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221545-la1lzxk",
						"updated": "20230327221545"
					},
					"Children": [
						{
							"ID": "20230327221545-imlg81w",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221545-imlg81w",
								"updated": "20230327221545"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "最后使用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "result_set"
								},
								{
									"Type": "NodeText",
									"Data": "​ 初始化一个vector 进行提交即可"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230327221545-iapwai1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221545-iapwai1",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221545-7yttxos",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221545-7yttxos",
				"updated": "20230327221545"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    vector\u003cint\u003e intersection(vector\u003cint\u003e\u0026 nums1, vector\u003cint\u003e\u0026 nums2) {\n        unordered_set\u003cint\u003e result_set;\n        unordered_set\u003cint\u003e nums_set(nums1.begin() , nums1.end());\n        for(int i = 0 ; i \u003c nums2.size() ; i++)\n        {\n            if(nums_set.find(nums2[i]) != nums_set.end())\n            {\n                result_set.insert(nums2[i]);\n            }\n        }\n        vector\u003cint\u003e result(result_set.begin() , result_set.end());\n        return result;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221531-tff40nm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221531-tff40nm",
				"updated": "20230327221531"
			}
		}
	]
}