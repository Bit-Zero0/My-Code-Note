{
	"ID": "20230327221222-a7gw8x9",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230327221222-a7gw8x9",
		"title": "数组",
		"updated": "20230327221340"
	},
	"Children": [
		{
			"ID": "20230327221253-lew95co",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221253-lew95co",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "增删类"
				}
			]
		},
		{
			"ID": "20230327221253-c55ku9l",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221253-c55ku9l",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "27. 移除元素"
				}
			]
		},
		{
			"ID": "20230327221253-9spty6m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-9spty6m",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/remove-element/",
					"TextMarkTextContent": "27. 移除元素"
				}
			]
		},
		{
			"ID": "20230327221253-490ujqo",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-490ujqo",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327221253-p6etma9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-p6etma9",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然可以使用最简单的暴力解法,但是该方法的时间复杂度太高,所以本题使用了双指针法"
				}
			]
		},
		{
			"ID": "20230327221253-5j8ttcu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-5j8ttcu",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "定义快慢指针"
				}
			]
		},
		{
			"ID": "20230327221253-atbcp67",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230327221253-atbcp67",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"ID": "20230327221253-ffge1zv",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-ffge1zv",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-3hbku2n",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-3hbku2n",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组"
								}
							]
						}
					]
				},
				{
					"ID": "20230327221253-ra2zc1s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-ra2zc1s",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-txnjof5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-txnjof5",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "慢指针：指向更新 新数组下标的位置"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230327221253-8n48ed1",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-8n48ed1",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221253-9qbc054",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221253-9qbc054",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    int removeElement(vector\u003cint\u003e\u0026 nums, int val) {\n        int slow = 0;\n        int fast = 0;\n        for(; fast \u003c nums.size(); fast++)\n        {\n            if(nums[fast] != val)\n            {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221253-yoown4u",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221253-yoown4u",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "排序类"
				}
			]
		},
		{
			"ID": "20230327221253-uazbsfm",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221253-uazbsfm",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "977. 有序数组的平方"
				}
			]
		},
		{
			"ID": "20230327221253-1ksuse3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-1ksuse3",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/squares-of-a-sorted-array/",
					"TextMarkTextContent": "977. 有序数组的平方"
				}
			]
		},
		{
			"ID": "20230327221253-ul0nsvx",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-ul0nsvx",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路:"
				}
			]
		},
		{
			"ID": "20230327221253-6l8eh5b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-6l8eh5b",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "方法一: 使用标准库提供的sort函数进行暴力排序\n方法二:  使用双指针法"
				}
			]
		},
		{
			"ID": "20230327221253-jc0deq7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-jc0deq7",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本题使用方法二: "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "nums"
				},
				{
					"Type": "NodeText",
					"Data": "​中可能存在负数,对数组中的每一个元素进行平方时,有可能会出现比 负整数的平方 比 正整数平方 要大的值,所以当我们新定义一个数组时,优先从后到前的存放较大值."
				}
			]
		},
		{
			"ID": "20230327221253-x7hmrng",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-x7hmrng",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221253-a9xxyga",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221253-a9xxyga",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cint\u003e result(nums.size() , 0);\n        int k = nums.size()-1;\n        for(int i = 0 , j = nums.size() - 1; i \u003c= j;)\n        {\n            if((nums[i] * nums[i]) \u003e (nums[j] * nums[j]))\n            {\n                result[k--] = nums[i] * nums[i];\n                i++;\n            }\n            else\n            {\n                result[k--] = nums[j] * nums[j];\n                j--;\n            }\n        }\n        return result;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221253-zvnwu2p",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221253-zvnwu2p",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "矩阵类"
				}
			]
		},
		{
			"ID": "20230327221253-0skh6zy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221253-0skh6zy",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "59. 螺旋矩阵 II"
				}
			]
		},
		{
			"ID": "20230327221253-gbnkqix",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-gbnkqix",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/spiral-matrix-ii/",
					"TextMarkTextContent": "59. 螺旋矩阵 II"
				}
			]
		},
		{
			"ID": "20230327221253-frhtorn",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-frhtorn",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解图思路"
				}
			]
		},
		{
			"ID": "20230327221253-40o5hvy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-40o5hvy",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而求解本题依然是要坚持"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "循环不变量"
				},
				{
					"Type": "NodeText",
					"Data": "原则。"
				}
			]
		},
		{
			"ID": "20230327221253-odndjuy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-odndjuy",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "模拟顺时针画矩阵的过程:"
				}
			]
		},
		{
			"ID": "20230327221253-dfsvovx",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230327221253-dfsvovx",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"ID": "20230327221253-a6s9giu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-a6s9giu",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-vkeltrd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-vkeltrd",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "填充上行从左到右"
								}
							]
						}
					]
				},
				{
					"ID": "20230327221253-y8f8y9z",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-y8f8y9z",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-xbxigb4",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-xbxigb4",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "填充右列从上到下"
								}
							]
						}
					]
				},
				{
					"ID": "20230327221253-g1vqq6o",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-g1vqq6o",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-8kug5at",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-8kug5at",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "填充下行从右到左"
								}
							]
						}
					]
				},
				{
					"ID": "20230327221253-e7eajr6",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230327221253-e7eajr6",
						"updated": "20230327221253"
					},
					"Children": [
						{
							"ID": "20230327221253-oxddj7h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327221253-oxddj7h",
								"updated": "20230327221253"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "填充左列从下到上"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230327221253-5cdjomz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-5cdjomz",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由外向内一圈一圈这么画下去。"
				}
			]
		},
		{
			"ID": "20230327221253-j6wgy8f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-j6wgy8f",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "矩阵元素个数是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "n^2"
				},
				{
					"Type": "NodeText",
					"Data": "​ , 由此我们可以得出我们"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "总共要走的圈数"
				},
				{
					"Type": "NodeText",
					"Data": "是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "n/2"
				},
				{
					"Type": "NodeText",
					"Data": "​ ;"
				}
			]
		},
		{
			"ID": "20230327221253-ff1mbye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-ff1mbye",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意:如果 n 为奇数,我们还需要处理最中心的数."
				}
			]
		},
		{
			"ID": "20230327221253-24wlfkc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-24wlfkc",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221253-o3292ml",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-o3292ml",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/spiral-matrix-ii/",
					"TextMarkTextContent": "59. 螺旋矩阵 II"
				}
			]
		},
		{
			"ID": "20230327221253-5al5ced",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221253-5al5ced",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e generateMatrix(int n) {\n        vector\u003cvector\u003cint\u003e\u003e result(n , vector\u003cint\u003e(n , 0));\n\n        int x , y = 0;// 定义每循环一个圈的起始位置\n        int offset = 1; // 我们使用的是左边又开区间,offset为每次循环的收缩位\n        int loop = n / 2; //总共要走的圈数, 可以自己动手画一下就知道了\n        int mid = n/2; // 当n为基数时用到,如: n=3; 最中心的数的下标为[1,1] ; n=5时,下标为[2,2];\n        int count = 1; // 为result的每个位置赋值的值\n    \n        while(loop--)\n        {\n            int i = x ; \n            int j = y;\n\n            // 填充上行,从左到右(左闭右开)\n            for(; j \u003c n - offset ; j++)\n            {\n                result[i][j] = count++;\n            }\n            //填充右列,从上到下(左闭右开)\n            for(; i \u003c n - offset ; i++)\n            {\n                result[i][j] = count++;\n            }\n            // 填充下行,从左到右(左闭右开)\n            for(;j \u003e y; j--)\n            {\n                result[i][j] = count++;\n            }\n            //填充左列,从上到下(左闭右开)\n            for(;i \u003e x ; i--)\n            {\n                result[i][j] = count++;\n            }\n\n            //第二圈,各个起始位置+1;\n            x++;\n            y++;\n\n            // offset 控制每一圈里每一条边遍历的长度\n            offset++;\n        }\n\n        if(n % 2 == 1) // 说明n为基数.需要处理的最中心的数\n        {\n            result[mid][mid] = count;\n        }\n\n        return result;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221253-b6ybow9",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327221253-b6ybow9",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "滑动窗口"
				}
			]
		},
		{
			"ID": "20230327221253-2tvhzs5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-2tvhzs5",
				"updated": "20230327221340"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "block-ref",
					"TextMarkBlockRefID": "20230327221045-fyfh3pp",
					"TextMarkBlockRefSubtype": "s",
					"TextMarkTextContent": "滑动窗口模板学习"
				}
			]
		},
		{
			"ID": "20230327221253-2arv9r1",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327221253-2arv9r1",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "209.长度最小的子数组"
				}
			]
		},
		{
			"ID": "20230327221253-d15x8ly",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-d15x8ly",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/minimum-size-subarray-sum/",
					"TextMarkTextContent": "209. 长度最小的子数组"
				}
			]
		},
		{
			"ID": "20230327221253-5idbv62",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-5idbv62",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327221253-jo01klm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-jo01klm",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用滑动窗口思想"
				}
			]
		},
		{
			"ID": "20230327221253-nta0h37",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221253-nta0h37",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。"
				}
			]
		},
		{
			"ID": "20230327221253-0fodzxm",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230327221253-0fodzxm",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327221253-9ram3t9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327221253-9ram3t9",
				"updated": "20230327221253"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) {\n        int result = INT32_MAX;\n        int sum = 0;// 滑动窗口数值之和\n        int i = 0;// 滑动窗口起始位置\n        int sumL = 0;// 滑动窗口的长度\n        for(int j = 0 ; j \u003c nums.size() ; j++)\n        {\n            sum += nums[j]; \n            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件\n            while(sum \u003e= target)\n            {\n                sumL = j - i + 1;\n                result = result \u003e sumL ? sumL : result;\n                sum -= nums[i++];\n            }\n        }\n        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列\n        return result == INT32_MAX? 0 : result ;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}