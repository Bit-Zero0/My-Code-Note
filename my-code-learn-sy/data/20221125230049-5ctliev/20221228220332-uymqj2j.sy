{
	"ID": "20221228220332-uymqj2j",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20221228220332-uymqj2j",
		"scroll": "{\u0026quot;startId\u0026quot;:\u0026quot;20230327220938-q5uk4f1\u0026quot;,\u0026quot;endId\u0026quot;:\u0026quot;20221228220345-tc94qbh\u0026quot;,\u0026quot;scrollTop\u0026quot;:0,\u0026quot;focusId\u0026quot;:\u0026quot;20230327220938-q5uk4f1\u0026quot;,\u0026quot;focusStart\u0026quot;:0,\u0026quot;focusEnd\u0026quot;:0}",
		"title": "链表",
		"updated": "20230327221013"
	},
	"Children": [
		{
			"ID": "20230327220938-q5uk4f1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220938-q5uk4f1"
			}
		},
		{
			"ID": "20230327220941-u2v2l6i",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327220941-u2v2l6i",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "24. 两两交换链表中的节点"
				}
			]
		},
		{
			"ID": "20230327220941-t4ryjnu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220941-t4ryjnu",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/swap-nodes-in-pairs/",
					"TextMarkTextContent": "24. 两两交换链表中的节点"
				}
			]
		},
		{
			"ID": "20230327220941-u38ejyv",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327220941-u38ejyv",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327220941-3j8ezax",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220941-3j8ezax",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为要两两交换其中相邻的节点,所以我们需要找到需要交换的第一个对象前面的一个节点,并定义为cur,本题也使用了虚拟头节点的方法.随后进行以下四步走(最好进行画图理解):"
				}
			]
		},
		{
			"ID": "20230327220941-zmxrf6p",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230327220941-zmxrf6p",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"ID": "20230327220941-s7xmcxy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230327220941-s7xmcxy",
						"updated": "20230327220941"
					},
					"Children": [
						{
							"ID": "20230327220941-t6bmbh2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327220941-t6bmbh2",
								"updated": "20230327220941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "cur-\u003enext 指向 待交换的第二个节点"
								}
							]
						}
					]
				},
				{
					"ID": "20230327220941-grs2awx",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230327220941-grs2awx",
						"updated": "20230327220941"
					},
					"Children": [
						{
							"ID": "20230327220941-45t6dla",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327220941-45t6dla",
								"updated": "20230327220941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第二个节点的next 指向 第一个节点"
								}
							]
						}
					]
				},
				{
					"ID": "20230327220941-y38m2ox",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230327220941-y38m2ox",
						"updated": "20230327220941"
					},
					"Children": [
						{
							"ID": "20230327220941-g0xlla1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327220941-g0xlla1",
								"updated": "20230327220941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "第一个节点的next 指向 下一组待交换节点的第一个对象."
								}
							]
						}
					]
				},
				{
					"ID": "20230327220941-i02x4i4",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230327220941-i02x4i4",
						"updated": "20230327220941"
					},
					"Children": [
						{
							"ID": "20230327220941-n23vn06",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230327220941-n23vn06",
								"updated": "20230327220941"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "cur = cur-\u003enext-\u003enext(也就是指向下一组待交换节点的前一个节点)"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230327220941-h5epc03",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327220941-h5epc03",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "c++题解"
				}
			]
		},
		{
			"ID": "20230327220941-d1u2q8t",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327220941-d1u2q8t",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr) return nullptr;\n\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead-\u003enext = head;\n\n        ListNode* cur = dummyHead;\n        while(cur-\u003enext != nullptr \u0026\u0026 cur-\u003enext-\u003enext != nullptr)//保证待交换的节点存在\n        {\n            ListNode* temp1 = cur-\u003enext;//记录临时节点\n            ListNode* temp2 = cur-\u003enext-\u003enext-\u003enext; //记录临时节点\n        \n            cur-\u003enext = cur-\u003enext-\u003enext; // 步骤一\n            cur-\u003enext-\u003enext = temp1; // 步骤二\n            temp1-\u003enext = temp2; // 步骤三\n\n            cur = cur-\u003enext-\u003enext;  // 步骤四\n        }\n        return dummyHead-\u003enext;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327221013-7fqhsd3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327221013-7fqhsd3"
			}
		},
		{
			"ID": "20230327220941-08l6ozh",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230327220941-08l6ozh",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "19. 删除链表的倒数第 N 个结点"
				}
			]
		},
		{
			"ID": "20230327220941-jqeibkg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220941-jqeibkg",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/remove-nth-node-from-end-of-list/",
					"TextMarkTextContent": "19. 删除链表的倒数第 N 个结点"
				}
			]
		},
		{
			"ID": "20230327220941-p3t7m71",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327220941-p3t7m71",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230327220941-4pkauft",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220941-4pkauft",
				"updated": "20230327221000"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用快慢指针法, 如果要删除倒数第n个节点，让"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "fast"
				},
				{
					"Type": "NodeText",
					"Data": "​移动n步，然后让"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "fast"
				},
				{
					"Type": "NodeText",
					"Data": "​和"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "slow"
				},
				{
					"Type": "NodeText",
					"Data": "​同时移动，直到"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "fast"
				},
				{
					"Type": "NodeText",
					"Data": "​指向链表末尾。删掉"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "slow"
				},
				{
					"Type": "NodeText",
					"Data": "​所指向的节点就可以了。"
				}
			]
		},
		{
			"ID": "20230327220941-rro2500",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220941-rro2500",
				"updated": "20230327221006"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是我们要删除单向链表的节点时,必须找到被删除节点的前一个节点,所以"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "fast"
				},
				{
					"Type": "NodeText",
					"Data": "​应该多走一步,这样"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "slow"
				},
				{
					"Type": "NodeText",
					"Data": "​就能停留在被删除节点的前一个节点上."
				}
			]
		},
		{
			"ID": "20230327220941-dj2dwbb",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230327220941-dj2dwbb",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230327220941-pykp18r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230327220941-pykp18r",
				"updated": "20230327220941"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        if(head == nullptr) return nullptr;\n        ListNode* dumyHead = new ListNode(0);\n        dumyHead-\u003enext = head;\n        ListNode* fast = dumyHead;\n        ListNode* slow = dumyHead;\n\n        while(n-- \u0026\u0026 fast != nullptr)\n        {\n            fast = fast-\u003enext;\n        }\n        fast = fast-\u003enext;// fast再提前走一步，因为需要让slow指向删除节点的上一个节点\n\n        while(fast != nullptr)\n        {\n            slow = slow-\u003enext;\n            fast = fast-\u003enext;\n        }\n        slow-\u003enext = slow-\u003enext-\u003enext;\n        return dumyHead-\u003enext;\n    }\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230327220940-jepncx3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230327220940-jepncx3"
			}
		},
		{
			"ID": "20230323214457-3eld0xa",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230323214457-3eld0xa",
				"updated": "20230327220805"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "707.设计链表"
				}
			]
		},
		{
			"ID": "20230323214457-a6ti6b3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230323214457-a6ti6b3",
				"updated": "20230323214457"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/design-linked-list/",
					"TextMarkTextContent": "707. 设计链表"
				}
			]
		},
		{
			"ID": "20230323214457-fmhvgl9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230323214457-fmhvgl9",
				"updated": "20230323214457"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20230323214457-japs2zx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230323214457-japs2zx",
				"updated": "20230323214510"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实就是写个链表,我们这里就写个带头的单链表与双向链表"
				}
			]
		},
		{
			"ID": "20230323214457-su7axw7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230323214457-su7axw7",
				"updated": "20230323214457"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20230323214457-bwtby2y",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230323214457-bwtby2y",
				"updated": "20230323214457"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "单链表版"
				}
			]
		},
		{
			"ID": "20230323214457-mwwf7h9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230323214457-mwwf7h9",
				"updated": "20230323214457"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyLinkedList {\n\npublic:\n    struct LinkNode{\n        int _val;\n        LinkNode* _next = nullptr;\n        LinkNode(int val)\n            :_val(val)\n            ,_next(nullptr)\n        {}\n    };\n\nprivate:\n    int _size;\n    LinkNode* head;\n\npublic:\n  \n    MyLinkedList() {\n        _size = 0;\n        head = new LinkNode(0);\n    }\n  \n    int get(int index) {\n        if(index \u003e= _size || index \u003c 0) return -1;\n        LinkNode* cur = head-\u003e_next;\n    \n        while(index--)\n        {\n            cur= cur-\u003e_next;\n        }\n        return cur-\u003e_val;\n    }\n  \n    void addAtHead(int val) {\n        LinkNode* NewNode = new LinkNode(val);\n        NewNode-\u003e_next = head-\u003e_next;\n        head-\u003e_next = NewNode;\n        _size++;\n    }\n  \n    void addAtTail(int val) {\n        LinkNode* cur = head;\n        while(cur-\u003e_next != nullptr)\n        {\n            cur = cur-\u003e_next;\n        }\n        LinkNode* NewNode = new LinkNode(val); \n        cur-\u003e_next = NewNode;\n        _size++;\n    }\n  \n    void addAtIndex(int index, int val) {\n        if(index \u003e _size || index \u003c 0) return;\n        if(index == _size) \n        {\n            addAtTail(val);\n            return;\n        }\n        if(index == 0)\n        {\n            addAtHead(val);\n            return;\n        }\n\n        LinkNode* cur = head;\n        while(index--)\n        {\n            cur = cur-\u003e_next;\n        }\n        LinkNode* NewNode = new LinkNode(val);\n\n        NewNode-\u003e_next = cur-\u003e_next;\n        cur-\u003e_next = NewNode; \n        _size++;\n        return ;\n    }\n  \n    void deleteAtIndex(int index) {\n        if(_size == 0 || index \u003c 0 || index\u003e=_size) return ;\n\n        LinkNode *cur = head;\n        while(index--)\n        {\n            cur = cur-\u003e_next;\n        }\n        LinkNode* tmp = cur-\u003e_next;\n        cur-\u003e_next = cur-\u003e_next-\u003e_next;\n        delete tmp;\n        _size--;\n    }\n\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230323214456-njtaypp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230323214456-njtaypp"
			}
		},
		{
			"ID": "20221228220345-uw6kutq",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-uw6kutq",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "合并两个有序列表"
				}
			]
		},
		{
			"ID": "20221228220415-8qxymst",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20221228220415-8qxymst",
				"updated": "20221228220415"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/merge-two-sorted-lists/",
					"TextMarkTextContent": "21. 合并两个有序链表"
				}
			]
		},
		{
			"ID": "20221228220345-izdey1t",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-izdey1t",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-gkd6dgo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-gkd6dgo",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建一个带头结点的链表，比较list1 和list2每个节点的值，较小的插入到我们创建的链表中。两条链表最终有可能还有节点还没被插入到我们创建的列表中，所以还需要最后一层判断。"
				}
			]
		},
		{
			"ID": "20221228220345-l27m6po",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-l27m6po",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-5wdjtm7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-5wdjtm7",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Yw=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//带哨兵位的头结点  \nclass Solution {  \n    public:  \n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {  \n        ListNode* newList = new ListNode(-1);  //创建头结点\n        ListNode* tmp = newList;  \n  \n        while(list1 \u0026\u0026 list2)  \n        {  \n            if(list1-\u003eval \u003c list2-\u003eval)  \n            {  \n                tmp-\u003enext = list1;  \n                list1 = list1-\u003enext;  \n                tmp = tmp-\u003enext;  \n            }  \n            else  \n            {  \n                tmp-\u003enext = list2;  \n                list2 = list2-\u003enext;  \n                tmp = tmp-\u003enext;  \n            }  \n        }  \n  \n        if(list1)  //list1 还有节点未被插入\n            tmp-\u003enext = list1;  \n  \n        if(list2)  //list2 还有节点未被插入\n            tmp-\u003enext = list2;  \n  \n        ListNode* next = newList-\u003enext;  \n        delete newList;  \n  \n        return next;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-k0wy700",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-k0wy700",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java题解"
				}
			]
		},
		{
			"ID": "20221228220345-7zskced",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-7zskced",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {  \n        ListNode NewList = new ListNode(-1);  \n        ListNode tmp = NewList;  \n        while(list1 != null \u0026\u0026 list2 != null) {  \n            if(list1.val \u003c list2.val){  \n                tmp.next = list1;  \n                list1 = list1.next;  \n                tmp = tmp.next;  \n            }else{  \n                tmp.next = list2;  \n                list2 = list2.next;  \n                tmp = tmp.next;  \n            }  \n        }  \n        if(list1 != null)  \n            tmp.next = list1;  \n  \n        if(list2 != null)  \n            tmp.next = list2;  \n  \n        return NewList.next;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-w0of9f4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-w0of9f4"
			}
		},
		{
			"ID": "20221228220425-smp3jij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220425-smp3jij"
			}
		},
		{
			"ID": "20221228220345-v5fuuv3",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-v5fuuv3",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "反转链表"
				}
			]
		},
		{
			"ID": "20221228220345-e84inlv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-e84inlv",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/reverse-linked-list/",
					"TextMarkTextContent": "206. 反转链表"
				}
			]
		},
		{
			"ID": "20221228220345-kgxml6m",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-kgxml6m",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-z9spck2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-z9spck2",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用双指针，cur比prev先一步，在将cur的next指向prev即可。注意保存cur的next。"
				}
			]
		},
		{
			"ID": "20221228220345-u351k7t",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-u351k7t",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-ekhhh1s",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-ekhhh1s",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public:  \n    ListNode* reverseList(ListNode* head) {  \n        if(head == nullptr)return nullptr;  \n  \n        ListNode* prev = nullptr;  \n        ListNode* cur = head;  \n  \n        while(cur != nullptr){  \n            ListNode* next = cur-\u003enext;  //先保存cur的下一个节点\n            cur-\u003enext = prev;  \n            prev = cur;  \n            cur = next;  \n        }  \n        return prev;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-zocyzgd",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-zocyzgd",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java题解"
				}
			]
		},
		{
			"ID": "20221228220345-2zwvu8d",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-2zwvu8d",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public ListNode reverseList(ListNode head) {  \n        if(head == null){  \n            return null;  \n        }  \n  \n        ListNode prev = null;  \n        ListNode cur = head;  \n  \n        while(cur != null){  \n            ListNode next = cur.next;  \n            cur.next = prev ;  \n            prev = cur;  \n            cur = next;  \n        }  \n        return prev;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-cuh479q",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-cuh479q",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "移除链表元素"
				}
			]
		},
		{
			"ID": "20221228220345-ak9i8iu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-ak9i8iu",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/remove-linked-list-elements/",
					"TextMarkTextContent": "203. 移除链表元素"
				}
			]
		},
		{
			"ID": "20221228220345-rllrzky",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-rllrzky",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-p7otjpx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-p7otjpx",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public:  \n    ListNode* removeElements(ListNode* head, int val) {  \n        if(head == nullptr)return nullptr;  \n  \n        ListNode* prev = head;  \n        ListNode* cur = head-\u003enext;  \n        while(cur != nullptr)  \n        {  \n            if(cur-\u003eval == val)  \n            {  \n                prev-\u003enext = cur-\u003enext;  \n                cur = cur-\u003enext;  \n            }  \n            else  \n            {  \n                prev = cur ;  \n                cur = cur-\u003enext;  \n            }  \n        }  \n        if(head-\u003eval == val)  \n        {  \n            head = head-\u003enext;  \n        }  \n        return head;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-vfcuw2g",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-vfcuw2g",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java题解"
				}
			]
		},
		{
			"ID": "20221228220345-7fk67x3",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-7fk67x3",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public ListNode removeElements(ListNode head, int val) {  \n        if(head == null) return null;  \n  \n        ListNode prev = head;  \n        ListNode cur = head.next;  \n  \n        while(cur != null){  \n            if(cur.val == val ){  \n                prev.next = cur.next;  \n                cur = cur.next;  \n            }else{  \n                prev = cur;  \n                cur = cur.next;  \n            }  \n        }  \n        if(head.val == val){  \n            head = head.next;  \n        }  \n  \n        return head;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220444-nrdxzrn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220444-nrdxzrn"
			}
		},
		{
			"ID": "20221228220444-ey9x96n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220444-ey9x96n"
			}
		},
		{
			"ID": "20221228220345-hb539b8",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-hb539b8",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表的中间结点"
				}
			]
		},
		{
			"ID": "20221228220345-3zhgcxf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-3zhgcxf",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/middle-of-the-linked-list/",
					"TextMarkTextContent": "876. 链表的中间结点"
				}
			]
		},
		{
			"ID": "20221228220345-67abii7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-67abii7",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-2166cpz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-2166cpz",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用快慢指针，fast指针的速度是slow指针的两倍。"
				}
			]
		},
		{
			"ID": "20221228220345-hduaew2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-hduaew2",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-9ucn55w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-9ucn55w",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public:  \n    ListNode* middleNode(ListNode* head) {  \n        if(head == nullptr) return nullptr;  \n        ListNode* fast = head;  \n        ListNode* slow = head;  \n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr){  \n            fast = fast-\u003enext-\u003enext;  \n            slow = slow-\u003enext;  \n        }  \n        return slow;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-683g1km",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-683g1km",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java题解"
				}
			]
		},
		{
			"ID": "20221228220345-jjyaazm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-jjyaazm",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public ListNode middleNode(ListNode head) {  \n        if(head == null) return null;  \n  \n        ListNode fast = head;  \n        ListNode slow = head;  \n        while(fast != null \u0026\u0026 fast.next != null){  \n            fast = fast.next.next;  \n            slow = slow.next;  \n        }  \n        return slow;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220501-y3jzlm5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220501-y3jzlm5"
			}
		},
		{
			"ID": "20221228220345-gmdsrqi",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-gmdsrqi",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表分割"
				}
			]
		},
		{
			"ID": "20221228220345-wxqp4u3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-wxqp4u3",
				"updated": "20221228220456"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?",
					"TextMarkTextContent": "https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?"
				}
			]
		},
		{
			"ID": "20221228220345-pwy40zk",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-pwy40zk",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-5io37jx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-5io37jx",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "创建四个指针 ，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "as"
				},
				{
					"Type": "NodeText",
					"Data": " ， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "ae"
				},
				{
					"Type": "NodeText",
					"Data": " ， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "bs"
				},
				{
					"Type": "NodeText",
					"Data": "  ，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "be"
				},
				{
					"Type": "NodeText",
					"Data": " ,  (as = a start , ae = a end...以此类推),使用as到ae来操作小于x的数，使用bs到be来操作大于x的数。"
				}
			]
		},
		{
			"ID": "20221228220345-2tyspl9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-2tyspl9",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-h58bhg2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-h58bhg2",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Partition {  \n    public:  \n    ListNode* partition(ListNode* pHead, int x) {  \n        // write code here  \n        if(pHead == nullptr) return nullptr;  \n  \n        ListNode* as = nullptr;  \n        ListNode* ae = nullptr;  \n        ListNode* bs = nullptr;  \n        ListNode* be = nullptr;  \n        ListNode* cur = pHead;  \n        while(cur != nullptr)  \n        {  \n            if(cur-\u003eval \u003c x )  \n            {  \n                if(ae == nullptr)  \n                {  \n                    as = cur;  \n                    ae = cur;  \n                }  \n                else  \n                {  \n                    ae-\u003enext = cur;  \n                    ae = ae-\u003enext;  \n                }  \n            }  \n            else  \n            {  \n                if(be == nullptr)  \n                {  \n                    bs = cur;  \n                    be = cur;  \n                }  \n                else  \n                {  \n                    be-\u003enext = cur;  \n                    be = be-\u003enext;  \n                }  \n            }  \n            cur = cur-\u003enext;  \n        }  \n        if(as == nullptr)  \n        {  \n            return bs;  \n        }  \n        ae-\u003enext = bs;  \n  \n        if(bs != nullptr)  \n        {  \n            be-\u003enext = nullptr;  \n        }  \n  \n        return as;  \n  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-zeyp7i8",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-zeyp7i8",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java题解"
				}
			]
		},
		{
			"ID": "20221228220345-g5axhc6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-g5axhc6",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Partition {  \n    public ListNode partition(ListNode pHead, int x) {  \n        ListNode bs = null;  \n        ListNode be = null;  \n        ListNode as = null;  \n        ListNode ae = null;  \n        ListNode cur = pHead;  \n        while (cur != null) {  \n            if (cur.val \u003c x) {  \n                //1、第一次  \n                if (as == null) {  \n                    as = cur;  \n                    ae = cur;  \n                } else {  \n                    //2、不是第一次  尾插  \n                    ae.next = cur;  \n                    ae = ae.next;  \n                }  \n            } else {  \n                if (bs == null) {  \n                    bs = cur;  \n                    be = cur;  \n                } else {  \n                    //2、不是第一次  \n                    be.next = cur;  \n                    be = be.next;  \n                }  \n            }  \n            cur = cur.next;  \n        }  \n        //预防第一个段为空  \n        if (as == null) {  \n            return bs;  \n        }  \n        ae.next = bs;  \n        //预防第2个段当中的数据，最后一个节点不是空的  \n        if (bs != null) {  \n            be.next = null;  \n        }  \n        return as;  \n    }  \n}\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220508-ifk5lg3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220508-ifk5lg3"
			}
		},
		{
			"ID": "20221228220345-2mpz9ew",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-2mpz9ew",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "链表中倒数第k个结点"
				}
			]
		},
		{
			"ID": "20221228220345-zlm7v8m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-zlm7v8m",
				"updated": "20221228220507"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a",
					"TextMarkTextContent": "https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a"
				}
			]
		},
		{
			"ID": "20221228220345-fandtg7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-fandtg7",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-joch3f5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-joch3f5",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "本题使用的是快慢指针，既然我们要找倒数第k个节点，我们就让快指针先走k-1步(要注意k-1是否超过链表长度)，随后快慢指针一起行走，当快指针到达终点时，慢指针就是我们要找的倒数第K个节点。"
				}
			]
		},
		{
			"ID": "20221228220345-gnsqadw",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-gnsqadw",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-tc94qbh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-tc94qbh",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public:  \n    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {  \n        if(k \u003c 0 || pListHead  == nullptr) return nullptr;  \n        ListNode* prev = pListHead;  \n        ListNode* cur = pListHead;  \n  \n        while(k -1 != 0)  \n        {  \n            prev = prev-\u003enext;  \n            if(prev == nullptr) return nullptr;  //判断k是否超过链表的长度\n            k--;  \n        }  \n  \n        while(prev-\u003enext != nullptr)  \n        {  \n            prev = prev-\u003enext;  \n            cur = cur-\u003enext;  \n        }  \n  \n        return cur;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-dqoonhy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-dqoonhy",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java题解"
				}
			]
		},
		{
			"ID": "20221228220345-nwfkzzz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-nwfkzzz",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Solution {  \n    public ListNode FindKthToTail(ListNode head,int k) {  \n        if(k \u003c 0 || head == null) return null;  \n        ListNode prev = head;  \n        ListNode cur = head;  \n  \n        while(k -1 != 0){  \n            prev = prev.next;  \n            if(prev == null) return null;  \n            k--;  \n        }  \n        while(prev.next != null){  \n            prev = prev.next;  \n            cur = cur.next;  \n        }  \n        return cur;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220512-zmvvifr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220512-zmvvifr"
			}
		},
		{
			"ID": "20221228220345-b3pij34",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-b3pij34",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "删除链表中重复的结点"
				}
			]
		},
		{
			"ID": "20221228220345-42m2va9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-42m2va9",
				"updated": "20221228220528"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?",
					"TextMarkTextContent": "https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?"
				}
			]
		},
		{
			"ID": "20221228220345-2lky02o",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-2lky02o",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++题解"
				}
			]
		},
		{
			"ID": "20221228220345-2vbqzmb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-2vbqzmb",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public:  \n    ListNode* deleteDuplication(ListNode* pHead) {  \n        if(pHead == nullptr) return nullptr;  \n        ListNode* newList = new ListNode(-1);  \n        ListNode* tmp = newList;  \n        ListNode* cur = pHead;  \n        while(cur != nullptr){  \n            if(cur-\u003enext != nullptr \u0026\u0026 cur-\u003eval == cur-\u003enext-\u003eval ){  \n                while(cur-\u003enext != nullptr \u0026\u0026 cur-\u003eval == cur-\u003enext-\u003eval){  \n                    cur = cur-\u003enext;  \n                }  \n  \n                cur = cur-\u003enext;//多走一步  \n            }else{  \n                tmp-\u003enext = cur;  \n                tmp = tmp-\u003enext;  \n                cur = cur-\u003enext;  \n            }  \n        }  \n  \n        tmp-\u003enext = nullptr;//防止最后一个节点的值也是重复的  \n        ListNode* next  = newList-\u003enext;  \n        delete newList;  \n        return next;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-c1lprd9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-c1lprd9",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java题解"
				}
			]
		},
		{
			"ID": "20221228220345-3hrnh4k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-3hrnh4k",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Solution {  \n    public ListNode deleteDuplication(ListNode pHead) {  \n        if(pHead == null) return null;  \n        ListNode newList = new ListNode(-1);  \n        ListNode tmp = newList;  \n        ListNode cur = pHead;  \n        while(cur != null){  \n            if(cur.next != null \u0026\u0026 cur.val == cur.next.val ){  \n                while(cur.next != null \u0026\u0026 cur.val == cur.next.val){  \n                    cur = cur.next;  \n                }  \n  \n                cur = cur.next;//多走一步  \n            }else{  \n                tmp.next = cur;  \n                tmp = tmp.next;  \n                cur = cur.next;  \n            }  \n        }  \n  \n        tmp.next = null;//防止最后一个节点的值也是重复的  \n  \n        return newList.next;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220532-lygy0oa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220532-lygy0oa"
			}
		},
		{
			"ID": "20221228220345-31qfxf3",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221228220345-31qfxf3",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "回文链表"
				}
			]
		},
		{
			"ID": "20221228220345-mo9wzye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-mo9wzye",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://leetcode.cn/problems/palindrome-linked-list/",
					"TextMarkTextContent": "234. 回文链表"
				},
				{
					"Type": "NodeText",
					"Data": "\n "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?",
					"TextMarkTextContent": "牛客网 回文链表"
				}
			]
		},
		{
			"ID": "20221228220345-mct32bd",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-mct32bd",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "解题思路"
				}
			]
		},
		{
			"ID": "20221228220345-mz8spaz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-mz8spaz",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "先找到中间节点，如果链表的节点是偶数个 ，则找到中间的第二个节点，从此节点开始反转链表，最后使用双指针进行判断即可。"
				}
			]
		},
		{
			"ID": "20221228220345-dn4vpe5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-dn4vpe5",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++ 题解"
				}
			]
		},
		{
			"ID": "20221228220345-dzcdc9d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-dzcdc9d",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不知为何在leetcode中无法通过，但是牛客网没问题。"
				}
			]
		},
		{
			"ID": "20221228220345-p3jeygh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-p3jeygh",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class PalindromeList {  \n    public:  \n    bool chkPalindrome(ListNode* head) {  \n        // write code here  \n        if(head == nullptr) return true;  \n        ListNode* fast = head;  \n        ListNode* slow = head;  \n  \n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr)  \n        {  \n            fast = fast-\u003enext-\u003enext;  \n            slow = slow-\u003enext;  \n        }  \n        //slow走到了中间位置-\u003e反转 \n  \n        ListNode* cur = slow-\u003enext;  \n        while(cur != nullptr)  \n        {  \n            ListNode* next = cur-\u003enext;  \n            cur-\u003enext = slow;  \n            slow = cur;  \n            cur = next;  \n        }  \n\t\t//反转完成\n        while(head != slow)  \n        {  \n            if(head-\u003eval != slow-\u003eval)  \n                return false;  \n  \n            if(head-\u003enext == slow)  \n                return true;  \n  \n            head = head-\u003enext;  \n            slow = slow-\u003enext;  \n        }  \n        return true;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-svdqp97",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221228220345-svdqp97",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "思路二：集中到数组中，进行前后比较。"
				}
			]
		},
		{
			"ID": "20221228220345-k0pg00e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-k0pg00e",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \npublic:  \n    bool isPalindrome(ListNode* head) {  \n        std::vector\u003cint\u003e vec;  \n        while(head != nullptr)  \n        {  \n            vec.push_back(head-\u003eval);  \n            head = head-\u003enext;  \n        }  \n  \n        for( int i = 0 , j = vec.size() -1 ;i \u003c j ; i++ ,j--)  \n        {  \n            if(vec[i] != vec[j]) return false;  \n        }  \n        return true;  \n    }  \n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221228220345-s75518b",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221228220345-s75518b",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "java题解"
				}
			]
		},
		{
			"ID": "20221228220345-k90600n",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221228220345-k90600n",
				"updated": "20221228220345"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Solution {  \n    public boolean isPalindrome(ListNode head) {  \n        if(head == null) return true;  \n        ListNode fast = head;  \n        ListNode slow = head;  \n        while(fast != null \u0026\u0026 fast.next != null) {  \n            fast = fast.next.next;  \n            slow = slow.next;  \n        }  \n        //slow走到了中间位置-》反转  \n  \n        ListNode cur = slow.next;  \n        while(cur != null) {  \n            ListNode curNext = cur.next;  \n            cur.next = slow;  \n            slow = cur;  \n            cur = curNext;  \n        }  \n        //反转完成  \n        while(head != slow) {  \n            if(head.val != slow.val) {  \n                return false;  \n            }  \n            if(head.next == slow) {  \n                return true;  \n            }  \n            head = head.next;  \n            slow = slow.next;  \n        }  \n        return true;  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}