{
	"ID": "20221012224533-nfzna86",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20221012224533-nfzna86",
		"title": "右值引用",
		"updated": "20221012225419"
	},
	"Children": [
		{
			"ID": "20221012224538-rhyj3uu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-rhyj3uu",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++98中提出了引用的概念，引用即别名，引用变量与其引用实体公共同一块内存空间，而引用的底层是通过指针来实现的，因此使用引用，可以提高程序的可读性"
				}
			]
		},
		{
			"ID": "20221012224538-ah0xd4r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-ah0xd4r",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "void Swap(int\u0026 left, int\u0026 right) \n{\n\tint temp = left; \n\tleft = right; \n\tright = temp;\n}\n\nint main() \n{\n\tint a = 10; \n\tint b = 20; \n\tSwap(a, b);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-4x2wwka",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-4x2wwka",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为了提高程序运行效率，C++11中引入了右值引用，右值引用也是别名，但其只能对右值引用。"
				}
			]
		},
		{
			"ID": "20221012224607-w2vbqd1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224607-w2vbqd1"
			}
		},
		{
			"ID": "20221012224538-3hxsy29",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-3hxsy29",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++左值和右值"
				}
			]
		},
		{
			"ID": "20221012224538-db3dyo8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-db3dyo8",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。"
				}
			]
		},
		{
			"ID": "20221012224538-le35h9i",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-le35h9i",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-d8rymoi",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221012224538-d8rymoi",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是\"left value\"、\"right value\" 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 \"read value\"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224619-hkzvqrv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224619-hkzvqrv"
			}
		},
		{
			"ID": "20221012224538-97jw0hj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-97jw0hj",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。"
				}
			]
		},
		{
			"ID": "20221012224538-5i254za",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221012224538-5i254za",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-7fz0mvl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221012224538-7fz0mvl",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-6opr6o6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-6opr6o6",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "。举个例子："
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-fj46fbe",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-fj46fbe",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int a = 5;  \n5 = a; //错误，5 不能为左值\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-ndr1ilf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ndr1ilf",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如："
				}
			]
		},
		{
			"ID": "20221012224538-dbft26v",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-dbft26v",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int b = 10; // b 是一个左值  \na = b; // a、b 都是左值，只不过将 b 可以当做右值使用\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224627-9s6fr81",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224627-9s6fr81"
			}
		},
		{
			"ID": "20221012224538-y1wctdj",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221012224538-y1wctdj",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-uiuz80j",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221012224538-uiuz80j",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-s7czm6u",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-s7czm6u",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "有名称的、可以获取到存储地址的表达式即为左值；反之则是右值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "。"
								},
								{
									"Type": "NodeBr",
									"Data": "br"
								},
								{
									"Type": "NodeText",
									"Data": "以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 \u0026a 和 \u0026b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。 "
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-sypkjhn",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-sypkjhn",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-4jdpes4",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221012224538-4jdpes4",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注意，以上 2 种判定方法只适用于大部分场景。由于本节主要讲解右值引用，因此这里适可而止，不再对 C++ 左值和右值做深度剖析，感兴趣的读者可自行研究。"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224643-31imu89",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224643-31imu89"
			}
		},
		{
			"ID": "20221012224538-3ylblmq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-3ylblmq",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "引用和右值引用是左值"
				}
			]
		},
		{
			"ID": "20221012224538-fzfo58n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-fzfo58n",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "也就是说，可以对右值引用取址，但是不能对右值取址（当然，左值引用也是左值，可以取址）。可以把引用理解为指针变量。"
				}
			]
		},
		{
			"ID": "20221012224538-zt1bedm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-zt1bedm",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cutility\u003e\nusing namespace std;\n \nvoid fun1(int\u0026 t) { // 接受一个左值参数，当然t本身也是左值\n}\n \nvoid fun2(int\u0026\u0026 t){  // 接受一个右值参数，但是t本身是左值\n}\n \nint main() {\n \n    int a=10;\n    int \u0026\u0026 ra=move(a); // move(a)返回一个右值，ra却是一个左值\n  \n    fun2(ra); // 报错：ra是一个左值，不允许绑定到右值引用\n \n    fun1(ra); // 正确：因为ra是左值，可以绑定到左值引用\n \n    fun2(move(a)); // 正确：move(a)返回一个右值\n \n    fun1(move(a)); // 报错：不允许将右值绑定到左值引用\n \n    return 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224657-ceootua",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224657-ceootua"
			}
		},
		{
			"ID": "20221012224538-9e2wuid",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-9e2wuid",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数调用时，同样要注意，一旦完成绑定，结果将是一个左值。"
				}
			]
		},
		{
			"ID": "20221012224538-ptxcth9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-ptxcth9",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cutility\u003e\nusing namespace std;\n \nvoid fun1(int\u0026\u0026 t, int b){ // 接受一个右值参数；但是t本身是左值\n \n}\n \nvoid fun2(int\u0026\u0026 t){ // t是右值引用，右值引用本身为左值\n    fun1(t, 1); // 报错：t现在是一个左值，不允许将左值绑定到右值引用\n}\n \nint main(){\n    int a=10;\n    fun2(move(a));\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224703-u1j8b5i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224703-u1j8b5i"
			}
		},
		{
			"ID": "20221012224538-vy91h0o",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-vy91h0o",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++右值引用"
				}
			]
		},
		{
			"ID": "20221012224538-h0x5trx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-h0x5trx",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "前面提到，其实 C++98/03 标准中就有引用，使用 \"\u0026\" 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子："
				}
			]
		},
		{
			"ID": "20221012224538-61hr2n1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-61hr2n1",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int num = 10;\nint \u0026b = num; //正确\nint \u0026c = 10; //错误\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-kk02nc4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-kk02nc4",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98 标准中的引用又称为左值引用。"
				}
			]
		},
		{
			"ID": "20221012224708-jrjwv6h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224708-jrjwv6h"
			}
		},
		{
			"ID": "20221012224538-4vjwvnt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-4vjwvnt",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意，虽然 C++98/03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如："
				}
			]
		},
		{
			"ID": "20221012224538-9tx0cqq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-9tx0cqq",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "1.  int num = 10;\n2.  const int \u0026b = num;\n3.  const int \u0026c = 10;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-y824i19",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-y824i19",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。"
				}
			]
		},
		{
			"ID": "20221012224715-2ek79tf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224715-2ek79tf"
			}
		},
		{
			"ID": "20221012224538-nj6fydt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-nj6fydt",
				"updated": "20221012224730"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为此，C++11 标准新引入了另一种引用方式，称为"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "右值引用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，用 \""
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "\u0026\u0026"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\" 表示。"
				}
			]
		},
		{
			"ID": "20221012224538-jp49vgt",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-jp49vgt",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-wdisnbl",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221012224538-wdisnbl",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98标准产生冲突，最终选定了 2 个 '\u0026' 表示右值引用。"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-iqwsmtr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-iqwsmtr",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如："
				}
			]
		},
		{
			"ID": "20221012224538-pl1ybwv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-pl1ybwv",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int num = 10;\n//int \u0026\u0026 a = num;  //右值引用不能初始化为左值\nint \u0026\u0026 a = 10;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224754-56v1f1w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224754-56v1f1w"
			}
		},
		{
			"ID": "20221012224538-ib2m90i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ib2m90i",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和常量左值引用不同的是，右值引用还可以对右值进行修改。例如："
				}
			]
		},
		{
			"ID": "20221012224538-ql0h1ud",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-ql0h1ud",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int \u0026\u0026 a = 10;\na = 100;\ncout \u003c\u003c a \u003c\u003c endl;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-pdv4o25",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-pdv4o25",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "程序输出结果为 100。"
				}
			]
		},
		{
			"ID": "20221012224804-6gvot70",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224804-6gvot70"
			}
		},
		{
			"ID": "20221012224538-oq8yvby",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-oq8yvby",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：\n"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "const int\u0026\u0026 a = 10;//编译器不会报错"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。"
				}
			]
		},
		{
			"ID": "20221012224816-75hc924",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224816-75hc924"
			}
		},
		{
			"ID": "20221012224538-ku0ouqf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ku0ouqf",
				"updated": "20221012224902"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "学到这里，一些读者可能无法记清楚左值引用和右值引用各自可以引用左值还是右值，这里给大家一张表格，方便大家记忆："
				},
				{
					"Type": "NodeBr",
					"Data": "br"
				},
				{
					"Type": "NodeText",
					"Data": "  "
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Properties": {
						"parent-style": "max-width: 473px;",
						"style": "width: 463px;"
					},
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012173252"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012173252-20221012224902-l9uz5rg.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeKramdownSpanIAL",
					"Data": "{: style=\"width: 463px;\" parent-style=\"max-width: 473px;\"}"
				},
				{
					"Type": "NodeText",
					"Data": "\n表中，Y 表示支持，N 表示不支持。"
				}
			]
		},
		{
			"ID": "20221012224538-yi41rta",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-yi41rta",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-t55aks1",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221012224538-t55aks1",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98/03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T \u0026\u0026 类型的表达式）。对于纯右值和将亡值，都属于右值，读者知道即可，不必深究。"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224918-4tdt511",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224918-4tdt511"
			}
		},
		{
			"ID": "20221012224538-vdxsjxk",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-vdxsjxk",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "左值与右值的区分"
				}
			]
		},
		{
			"ID": "20221012224538-x00mv29",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-x00mv29",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-md9co6y",
					"Type": "NodeList",
					"ListData": {
						"Typ": 1
					},
					"Properties": {
						"id": "20221012224538-md9co6y",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-a11slgd",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "MS4=",
								"Num": 1
							},
							"Properties": {
								"id": "20221012224538-a11slgd",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-y23yw3q",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-y23yw3q",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "普通类型的变量，因为"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "有名字"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "，可以"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "取地址"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "，都认为是"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "左值"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "。"
										}
									]
								}
							]
						},
						{
							"ID": "20221012224538-yrq79iz",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "Mi4=",
								"Num": 2
							},
							"Properties": {
								"id": "20221012224538-yrq79iz",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-u59qvr0",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-u59qvr0",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "const修饰的常量，不可修改，只读类型"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "的，理论应该按照右值对待，但因为其可以取地址(如果只是 const类型常量的定义，编译器不给其开辟空间，如果对该常量取地址时，编译器才为其开辟空间)，C++11认为其是"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "左值"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "。"
										}
									]
								}
							]
						},
						{
							"ID": "20221012224538-0ealelt",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "My4=",
								"Num": 3
							},
							"Properties": {
								"id": "20221012224538-0ealelt",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-mz2wxyz",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-mz2wxyz",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "如果"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "表达式的运行结果是一个临时变量或者对象"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "，认为是"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "右值"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "。"
										}
									]
								}
							]
						},
						{
							"ID": "20221012224538-m0zfdj5",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "NC4=",
								"Num": 4
							},
							"Properties": {
								"id": "20221012224538-m0zfdj5",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-fh80tn5",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-fh80tn5",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "如果表达式运行结果或单个变量是一个引用则认为是左值。"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-okria8r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-okria8r",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "总结："
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-arub4x3",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221012224538-arub4x3",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-sek1n68",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221012224538-sek1n68",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-yfru484",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-yfru484",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "不能简单地通过能否放在=左侧右侧或者取地址来判断左值或者右值，要根据表达式结果或变量的性质\n判断，比如上述：c常量"
								}
							]
						}
					]
				},
				{
					"ID": "20221012224538-q9y7dbg",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221012224538-q9y7dbg",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-phcw0ac",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-phcw0ac",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "能得到引用的表达式一定能够作为引用，否则就用常引用。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224938-elcbw3e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224938-elcbw3e"
			}
		},
		{
			"ID": "20221012224538-trmw6d1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-trmw6d1",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "C++11对右值进行了严格的区分："
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-6c42ai2",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221012224538-6c42ai2",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-puke7iu",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221012224538-puke7iu",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-b2620eu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-b2620eu",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "C语言中的纯右值，比如：a+b, 100."
								}
							]
						}
					]
				},
				{
					"ID": "20221012224538-xp0tdvk",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221012224538-xp0tdvk",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-o119140",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-o119140",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "将亡值。比如：表达式的中间结果、函数按照值的方式进行返回."
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224941-6qaw504",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224941-6qaw504"
			}
		},
		{
			"ID": "20221012224538-zf06hff",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-zf06hff",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "引用与右值引用比较"
				}
			]
		},
		{
			"ID": "20221012224538-uy5kvfd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-uy5kvfd",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在C++98中的普通引用与const引用在引用实体上的区别："
				}
			]
		},
		{
			"ID": "20221012224538-q85od1c",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-q85od1c",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main() \n{\n\t// 普通类型引用只能引用左值，不能引用右值 \n\tint a = 10;\n\tint\u0026 ra1 = a;   // ra为a的别名\n\tint\u0026 ra2 = 10;   // 编译失败，因为10是右值 \n\n\tconst int\u0026 ra3 = 10;//可以正常使用，但是是左值；\n\tconst int\u0026 ra4 = a; \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-6401pbi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-6401pbi",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意:"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "普通引用只能引用左值，不能引用右值，const引用既可引用左值，也可引用右值"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221012224948-5z0zkpj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224948-5z0zkpj"
			}
		},
		{
			"ID": "20221012224538-07jiu7p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-07jiu7p",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++11中右值引用:只能引用右值，一般情况不能直接引用左值。"
				}
			]
		},
		{
			"ID": "20221012224538-j0thktb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-j0thktb",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main() \n{\n\t// 10纯右值，本来只是一个符号，没有具体的空间，\n\t// 右值引用变量r1在定义过程中，编译器产生了一个临时变量，r1实际引用的是临时变量 \n\tint\u0026\u0026 r1 = 10;\n\tr1 = 100; \n\n\tint a = 10;\n\tint\u0026\u0026 r2 = a;  // 编译失败：右值引用不能引用左值 \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-hv92gcx",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-hv92gcx",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "交叉引用"
				}
			]
		},
		{
			"ID": "20221012224538-vro5sy2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-vro5sy2",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "左值引用能否引用 右值？\n右值引用能否引用 左值？"
				}
			]
		},
		{
			"ID": "20221012224953-y2eokro",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224953-y2eokro"
			}
		},
		{
			"ID": "20221012224538-ypiv6aq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ypiv6aq",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "左值引用能否引用右值 -- "
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "不能直接引用，但是const 左值引用可以引用右值"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-k411l9b",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-k411l9b",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 左值引用能否引用右值 -- 不能直接引用，但是const 左值引用可以引用右值\n\tconst int\u0026 r1 = 10;\n\tconst double\u0026 r2 = x+y;\n\tconst double\u0026 r3 = fmin(x, y);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-d9oa7j9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-d9oa7j9",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "右值引用能否引用左值 -- "
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "不能直接引用，但是可以右值引用可以引用move以后左值"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-k2cgdih",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-k2cgdih",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 右值引用能否引用左值 -- 不能直接引用，但是可以右值引用可以引用move以后左值\n\tint*\u0026\u0026 rr1 = move(p);\n\tint\u0026\u0026 rr2 = move(*p);\n\tint\u0026\u0026 rr3 = move(b);\n\tconst int\u0026\u0026 rr4 = move(c);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012225005-4lpcn5q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225005-4lpcn5q"
			}
		},
		{
			"ID": "20221012224538-etslj2z",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-etslj2z",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "值形式返回对象的缺陷"
				}
			]
		},
		{
			"ID": "20221012224538-z17s9nk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-z17s9nk",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果一个类中涉及到资源管理l,用户必须显式提供拷贝构造、赋值运算符重载以及析构函数，否则编译器将会自动生成一个默认的，如果遇到拷贝对象或者对象之间相互赋值，就会出错，比如在使用模拟实现string时:"
				}
			]
		},
		{
			"ID": "20221012224538-ikovuyc",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-ikovuyc",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "namespace bit\n{\n\tclass string\n\t{\n\tpublic:\n\t\tstring(const char* str = \"\")\n\t\t\t:_size(strlen(str))\n\t\t\t, _capacity(_size)\n\t\t{\n\t\t\t//cout \u003c\u003c \"string(char* str)\" \u003c\u003c endl;\n\t\t\t_str = new char[_capacity + 1];\n\t\t\tstrcpy(_str, str);\n\t\t}\n\n\t\t// s1.swap(s2)\n\t\tvoid swap(string\u0026 s)\n\t\t{\n\t\t\t::swap(_str, s._str);\n\t\t\t::swap(_size, s._size);\n\t\t\t::swap(_capacity, s._capacity);\n\t\t}\n\n\t\t// 拷贝构造\n\t\tstring(const string\u0026 s)\n\t\t\t:_str(nullptr)\n\t\t\t, _size(0)\n\t\t\t, _capacity(0)\n\t\t{\n\t\t\tcout \u003c\u003c \"string(const string\u0026 s) -- 深拷贝\" \u003c\u003c endl;\n\n\t\t\tstring tmp(s._str);\n\t\t\tswap(tmp);\n\t\t}\n\n\t\t// 移动构造\n\t\tstring(string\u0026\u0026 s)\n\t\t\t:_str(nullptr)\n\t\t\t, _size(0)\n\t\t\t, _capacity(0)\n\t\t{\n\t\t\tcout \u003c\u003c \"string(string\u0026\u0026 s) -- 资源转移\" \u003c\u003c endl;\n\n\t\t\tthis-\u003eswap(s);\n\t\t}\n\n\t\t//string operator+=(char ch)\n\t\tstring\u0026 operator+=(char ch)\n\t\t{\n\t\t\tpush_back(ch);\n\t\t\treturn *this;\n\t\t}\n\n\t\tstring operator+(char ch) //这里会出问题\n\t\t{\n\t\t\tstring tmp(*this);\n\t\t\tpush_back(ch);\n\n\t\t\treturn tmp;\n\t\t}\n\n\t\tconst char* c_str() const\n\t\t{\n\t\t\treturn _str;\n\t\t}\n\tprivate:\n\t\tchar* _str;\n\t\tsize_t _size;\n\t\tsize_t _capacity; // 不包含最后做标识的\\0\n\t};\n}\n\nint main() \n{\n\tString s1(\"hello\");\n\tString s2(\"world\");\n\tString s3(s1+s2); \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-3xr4nih",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-3xr4nih",
				"updated": "20221012225022"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上述代码看起来没有什么问题，但是有一个不太尽人意的地方：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012192519"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012192519-20221012225022-jcfvi48.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n在operator+中："
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "strRet在按照值返回时，必须创建一个临时对象，临时对象创建好之后，strRet就被销毁了，最后使用返回的临时对象构造s3，s3构造好之后，临时对象就被销毁了"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。仔细观察会发现："
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "strRet、临时对象、s3每个对象创建后，都有自己独立的空间，而空间中存放内容也都相同，相当于创建了三个内容完全相同的对象，对于空间是一种浪费，程序的效率也会降低，而且临时对象确实作用不是很大"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，那能否对该种情况进行优化呢？"
				}
			]
		},
		{
			"ID": "20221012224538-gr7ss2j",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-gr7ss2j",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "移动语义(移动构造)"
				}
			]
		},
		{
			"ID": "20221012224538-132ounz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-132ounz",
				"updated": "20221012225037"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "C++11提出了移动语义概念，即："
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "将一个对象中资源移动到另一个对象中的方式"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，可以有效缓解该问题。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012193112"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012193112-20221012225036-vrvfeuv.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeBr",
					"Data": "br"
				}
			]
		},
		{
			"ID": "20221012224538-2uh1j9r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-2uh1j9r",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 移动构造\nstring(string\u0026\u0026 s)\n\t:_str(nullptr)\n\t, _size(0)\n\t, _capacity(0)\n{\n\tcout \u003c\u003c \"string(string\u0026\u0026 s) -- 资源转移\" \u003c\u003c endl;\n\tthis-\u003eswap(s);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-0f2vdhb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-0f2vdhb",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为strRet对象的生命周期在创建好临时对象后就结束了，即"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "将亡值"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，C++11认为其为"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "右值"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，在用strRet构造临时对象时，就会采用移动构造，即将strRet中资源转移到临时对象中。\n而临时对象也是右值，因此在用临时对象构造s3时，也采用移动构造，将临时对象中资源转移到s3中，整个过程，只需要创建一块堆内存即可，既省了空间，又大大提高程序运行的效率。"
				}
			]
		},
		{
			"ID": "20221012225052-su4bs6h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225052-su4bs6h"
			}
		},
		{
			"ID": "20221012224538-76dp8qu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-76dp8qu",
				"updated": "20221012225102"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "注意:"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-j8jb1r1",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221012224538-j8jb1r1",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-s4srcvq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221012224538-s4srcvq",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-2tzis8y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-2tzis8y",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "移动构造函数的参数千万不能设置成const类型的右值引用，因为资源无法转移而导致移动语义失效"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221012224538-oaqb0f2",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221012224538-oaqb0f2",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-lqlfqqh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-lqlfqqh",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在C++11中，编译器会为类"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "默认生成一个移动构造"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，该移动构造为"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "浅拷贝"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，因此当类中涉及到资源管理时，用户必须显式定义自己的移动构造。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-nwcvam2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-nwcvam2",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "右值引用 引用 左值"
				}
			]
		},
		{
			"ID": "20221012224538-yacvewd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-yacvewd",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？因为：有些场景下，可能真的需要用右值去引用左值实现移动语义。"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "当需要用右值引用引用一个左值时，可以通过move函数将左值转化为右值"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。C++11中，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "std::move()"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 函数位于 头文件中，该函数名字具有迷惑性，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "它并不搬移任何东西，唯一的功能就是将一个左值强制转化为右值引用，然后实现移动语义"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221012225118-u8pn3ye",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225118-u8pn3ye"
			}
		},
		{
			"ID": "20221012224538-ai1fz3t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ai1fz3t",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "std::move就是使用全能引用实现的。"
				}
			]
		},
		{
			"ID": "20221012224538-pu3amyi",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-pu3amyi",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "template \u003ctypename T\u003e\ntypename remove_reference\u003cT\u003e::type\u0026\u0026 move(T\u0026\u0026 t)\n{\n    return static_cast\u003ctypename remove_reference\u003cT\u003e::type \u0026\u0026\u003e(t);\n}\n\n\n/*****************************************\nstd::remove_reference功能为去除类型中的引用\n\nstd::remove_reference\u003cT \u0026\u003e::type ---\u003e T\nstd::remove_reference\u003cT \u0026\u0026\u003e::type ---\u003e T\nstd::remove_reference\u003cT\u003e::type ---\u003e T\n******************************************/\n//原始的，最通用的版本\ntemplate \u003ctypename T\u003e struct remove_reference{\n    typedef T type;  //定义T的类型别名为type\n};\n \n//部分版本特例化，将用于左值引用和右值引用\ntemplate \u003cclass T\u003e struct remove_reference\u003cT\u0026\u003e //左值引用\n{ typedef T type; }\n \ntemplate \u003cclass T\u003e struct remove_reference\u003cT\u0026\u0026\u003e //右值引用\n{ typedef T type; }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012225127-e91pv4d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225127-e91pv4d"
			}
		},
		{
			"ID": "20221012224538-falmudz",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-falmudz",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "拷贝构造函数和移动构造函数："
				}
			]
		},
		{
			"ID": "20221012224538-byekssg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-byekssg",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "问：为什么接受右值引用的构造函数被视为“移动”语义？"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "答："
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 因为输入参数是一个引用（右值引用也是引用），所以可以通过该引用直接访问到所引对象，我们可以借机将其持有的资源（堆指针）接管，并且将源对象的堆指针改为NULL，也就是移走了其持有的资源。\n其次，输入参数是对右值的引用，所以，只有通过右值进行“复制”（实际上是移动）构造时，才会调用该构造函数，所以移走一个即将析构的右值持有的资源，是安全的。"
				}
			]
		},
		{
			"ID": "20221012225133-sj93eby",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225133-sj93eby"
			}
		},
		{
			"ID": "20221012224538-3eli6kt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-3eli6kt",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "自定义了拷贝构造函数（const引用版），则移动构造函数会被编译器隐式地声明为delete的，此时如果用右值来构造对象，调用的则是const引用版的拷贝构造函数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20221012224538-ta02upe",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-ta02upe",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cvector\u003e\n#include \u003ciostream\u003e\n#include \u003ciostream\u003e\n#include \u003cutility\u003e\nusing namespace std;\n \nclass A {\npublic:\n\tA() {\n\t\tcout \u003c\u003c \"A()\" \u003c\u003c endl;\n\t}\n    // 参数为常量引用，可以接受左值或右值。\n    // 如果没有同时定义移动构造函数，当使用右值构造时，将调用该拷贝构造函数。\n\tA(const A\u0026) {\n\t\tcout \u003c\u003c \"A(const A\u0026)\" \u003c\u003c endl;\n\t}\n\tA(A\u0026) {\n\t\tcout \u003c\u003c \"A(A\u0026)\" \u003c\u003c endl;\n\t}\n\t//A(A\u0026\u0026) = delete; // 不能显式声明为delete，不然下面的std::move调用会报错；\n    // 如果显式声明，那么编译器认为移动构造函数已经被定义，并且定义为delete。\n    // 下面的std::move调用时，会直接调用移动构造函数版本，而不会去绑定到const引用拷贝构造函数版本\n    // 但是，如果没有显式声明为delete，则编译器不会生成移动构造函数，运行时则寻找能够匹配的函数，\n    // 显然，此时接受const引用参数的拷贝构造函数可以接受右值，于是被调用。\n};\n \nint main() {\n\tA a;\n    getchar();\n\tA b(std::move(a)); // 输出：A(const A\u0026)\n    getchar();\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-gex6ms7",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221012224538-gex6ms7",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "拷贝构造 和 拷贝构造+移动构造 的区别"
				}
			]
		},
		{
			"ID": "20221012224538-ritkk2b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ritkk2b",
				"updated": "20221012225207"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "具体看下图：\n上是：只用一个拷贝构造来进使用的\n下是：用一个拷贝构造+移动构造来进使用的\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012210447"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012210447-20221012225207-41yrivg.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "只使用拷贝构造"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-czh4ged",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-czh4ged",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-nvqa5pm",
					"Type": "NodeList",
					"ListData": {
						"Typ": 1
					},
					"Properties": {
						"id": "20221012224538-nvqa5pm",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-aj4t4r1",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "MS4=",
								"Num": 1
							},
							"Properties": {
								"id": "20221012224538-aj4t4r1",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-gnbhz21",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-gnbhz21",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "如果编译器不优化str拷贝构造临时对象，临时对象作为to_string的返回值再拷贝构造ret优化"
										}
									]
								}
							]
						},
						{
							"ID": "20221012224538-fkwfvfd",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "Mi4=",
								"Num": 2
							},
							"Properties": {
								"id": "20221012224538-fkwfvfd",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-9rih9t7",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-9rih9t7",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "to_string函数快结束时，返回前，直接用str去构造ret"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012225215-zephe3c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225215-zephe3c"
			}
		},
		{
			"ID": "20221012224538-x48wag8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-x48wag8",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "使用拷贝构造+移动构造"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-ravbxsa",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221012224538-ravbxsa",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221012224538-aw1ysln",
					"Type": "NodeList",
					"ListData": {
						"Typ": 1
					},
					"Properties": {
						"id": "20221012224538-aw1ysln",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-xtbgkls",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "MS4=",
								"Num": 1
							},
							"Properties": {
								"id": "20221012224538-xtbgkls",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-lkr6yvv",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-lkr6yvv",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "如果编译器不优化str拷贝构造临时对象，临时对象作为to_string的返回值再拷贝构造ret优化"
										}
									]
								}
							]
						},
						{
							"ID": "20221012224538-1rj0lxn",
							"Type": "NodeListItem",
							"ListData": {
								"Typ": 1,
								"Delimiter": 46,
								"Marker": "Mi4=",
								"Num": 2
							},
							"Properties": {
								"id": "20221012224538-1rj0lxn",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"ID": "20221012224538-ob8tuvj",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221012224538-ob8tuvj",
										"updated": "20221012224538"
									},
									"Children": [
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "to_string函数快结束时，将str的值传入移动构造，然后ret取得资源，相当于str的资源被ret继承了"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012225234-2w07cfh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225234-2w07cfh"
			}
		},
		{
			"ID": "20221012224538-5jc1us8",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221012224538-5jc1us8",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "完美转发："
				}
			]
		},
		{
			"ID": "20221012224538-jllegb1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-jllegb1",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "指对"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "模板参数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "实现完美转发：即输入什么类型（左值、右值）的参数，就是什么类型的参数。"
				}
			]
		},
		{
			"ID": "20221012225241-ciuqm9h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225241-ciuqm9h"
			}
		},
		{
			"ID": "20221012224538-ahec5sb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ahec5sb",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这是C++11的引用折叠规则决定的。"
				}
			]
		},
		{
			"ID": "20221012225243-ufgon88",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225243-ufgon88"
			}
		},
		{
			"ID": "20221012224538-2k3eg4u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-2k3eg4u",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "引用折叠"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "：如果有左值引用，优先折叠成左值引用（如果有左值引用，参数推导成左值引用；只有右值引用，参数推导成右值引用。）"
				}
			]
		},
		{
			"ID": "20221012225245-2xa0g14",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225245-2xa0g14"
			}
		},
		{
			"ID": "20221012224538-blctiv0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-blctiv0",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意：引用折叠和完美转发，只针对模板参数，非模板是不允许的，例如把一个左值绑定到右值引用是不允许的。"
				}
			]
		},
		{
			"ID": "20221012225246-fswcp6y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225246-fswcp6y"
			}
		},
		{
			"ID": "20221012224538-z4k9k8s",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-z4k9k8s",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "未实现完美转发的代码"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221012224538-sjhzqhm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-sjhzqhm",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003ciostream\u003e  \nusing namespace std;  \n  \nvoid RunCode(int \u0026 m) {  \n    cout \u003c\u003c \"lvalue ref\" \u003c\u003c endl;  \n}  \n  \nvoid RunCode(int \u0026\u0026 m) {  \n    cout \u003c\u003c \"rvalue ref\" \u003c\u003c endl;  \n}  \n  \nvoid RunCode(const int \u0026 m) {  \n    cout \u003c\u003c \"const lvalue ref\" \u003c\u003c endl;  \n}  \n  \nvoid RunCode(const int \u0026\u0026 m) {  \n    cout \u003c\u003c \"const rvalue ref\" \u003c\u003c endl;  \n}  \n  \ntemplate\u003ctypename T\u003e  \nvoid PerfectForward(T\u0026\u0026 t) {  \n    RunCode(t); //这里使用t进行再次转发\n}  \n  \nint main() {  \n    int a = 10;  \n    const int b = 20;  \n  \n    PerfectForward(a); // lvalue ref  \n    PerfectForward(move(a)); //    rvalue ref  \n    PerfectForward(b); // const lvalue ref  \n    PerfectForward(move(b));   // const rvalue ref  \n    return 0;  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-7ftu2ij",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-7ftu2ij",
				"updated": "20221012225317"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是看看运行结果，都"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "被转发为了左值引用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012204008"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012204008-20221012225317-5xl1avp.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20221012225334-330pxko",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225334-330pxko"
			}
		},
		{
			"ID": "20221012224538-346zo89",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-346zo89",
				"updated": "20221012225332"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "万能引用"
				}
			]
		},
		{
			"ID": "20221012224538-ybv2o6j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-ybv2o6j",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原因：T\u0026\u0026 是万能引用"
				}
			]
		},
		{
			"ID": "20221012224538-rsblbv9",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221012224538-rsblbv9",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"ID": "20221012224538-p6nn0w4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221012224538-p6nn0w4",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-39z6zda",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-39z6zda",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "模板中的\u0026\u0026不代表右值引用，而是万能引用"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，其既"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "能接收左值又能接收右值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20221012224538-b4n1oja",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221012224538-b4n1oja",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-svvq4h1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-svvq4h1",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "模板的"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "万能引用只是提供了能够接收同时接收左值引用和右值引用的能力"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，"
								}
							]
						}
					]
				},
				{
					"ID": "20221012224538-2cbn53g",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221012224538-2cbn53g",
						"updated": "20221012224538"
					},
					"Children": [
						{
							"ID": "20221012224538-bwie2oa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221012224538-bwie2oa",
								"updated": "20221012224538"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "但是"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "引用类型的唯一作用"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "就是"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "限制了接收的类型"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，后续使用中都"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "退化成了左值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221012225347-yr7hmsa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225347-yr7hmsa"
			}
		},
		{
			"ID": "20221012224538-45kct5p",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-45kct5p",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实现完美转发代码"
				}
			]
		},
		{
			"ID": "20221012224538-z1mh83j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-z1mh83j",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里使用"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "forward\u003cT\u003e()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "函数进行完美转发，"
				}
			]
		},
		{
			"ID": "20221012224538-wd7v10g",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-wd7v10g",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003ciostream\u003e\nusing namespace std;\n \nvoid RunCode(int \u0026 m) {\n\tcout \u003c\u003c \"lvalue ref\" \u003c\u003c endl;\n}\n \nvoid RunCode(int \u0026\u0026 m) {\n\tcout \u003c\u003c \"rvalue ref\" \u003c\u003c endl;\n}\n \nvoid RunCode(const int \u0026 m) {\n\tcout \u003c\u003c \"const lvalue ref\" \u003c\u003c endl;\n}\n \nvoid RunCode(const int \u0026\u0026 m) {\n\tcout \u003c\u003c \"const rvalue ref\" \u003c\u003c endl;\n}\n \ntemplate\u003ctypename T\u003e\nvoid PerfectForward(T\u0026\u0026 t) {\n\t// 类型转换是必须要的，以保证RunCode调用依然是完美转发\n\t// 否则，如果传入右值，t作为右值引用，是一个左值,所以这里的转换必不可少\n\tRunCode(forward\u003cT\u0026\u0026\u003e(t)); // forward可以用static_cast/move替换\n\t\t\t\t\t//\u003c\u003e 中可以用使用T\u0026\u0026 ,也可以使用T\n}\n \nint main() {\n\tint a = 10;\n\tconst int b = 20;\n \n\tPerfectForward(a); // lvalue ref\n\tPerfectForward(move(a)); //\trvalue ref\n\tPerfectForward(b); // const lvalue ref\n\tPerfectForward(move(b));  \t// const rvalue ref\n \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-c91pcb2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012224538-c91pcb2",
				"updated": "20221012225402"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行结果，此时就实现了完美转发\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221012205350"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221012205350-20221012225402-jgx9i5b.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeBr",
					"Data": "br"
				}
			]
		},
		{
			"ID": "20221012225409-wqrauas",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221012225409-wqrauas"
			}
		},
		{
			"ID": "20221012224538-aozg2fe",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221012224538-aozg2fe",
				"updated": "20221012225409"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "完美转发的注意事项"
				}
			]
		},
		{
			"ID": "20221012224538-qvpvsht",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-qvpvsht",
				"updated": "20221012225419"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003ciostream\u003e\n \ntemplate\u003ctypename T\u003e\nvoid fun(T\u0026\u0026 t) {\n\tputs(\"fun()\");\n}\n// 如果同时把左值引用参数的函数声明为删除的，那么就阻止了完美转发\ntemplate\u003ctypename T\u003e\nvoid fun(T\u0026 t) = delete;\n \nint main() {\n\tint a = 10;\n\tfun(std::move(a)); // 正确\n\tfun(a); // 编译不过，不能进行完美转发\n \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-pftxz4f",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-pftxz4f",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// unique_ptr deleter with state\n#include \u003ciostream\u003e\n \n// 非模板函数，不能进行完美转发\nvoid fun(int\u0026\u0026 t) {\n\tputs(\"fun()\");\n}\n \nint main() {\n\tint a = 10;\n\tfun(a); // 编译不过，不允许把左值绑定到右值引用\n \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221012224538-3u167z5",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221012224538-3u167z5",
				"updated": "20221012224538"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// unique_ptr deleter with state\n#include \u003ciostream\u003e\n \ntemplate\u003ctypename T\u003e\nclass A{\npublic:\n    // 非模板函数，不能进行完美转发，即使是在类模板中也不行\n    void fun(int\u0026\u0026 t) {\n\tputs(\"fun()\");\n    }\n}; \n \nint main() {\n    A\u003cint\u003e a;\n    int n = 10;\n    a.fun(n); // 编译不过，不允许把左值绑定到右值引用\n \n    return 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}