{
	"ID": "20230423122746-h5hfm8k",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230423122746-h5hfm8k",
		"title": "继承和多态",
		"updated": "20230423123313"
	},
	"Children": [
		{
			"ID": "20230423123252-9yzhyqn",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123252-9yzhyqn",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承"
				}
			]
		},
		{
			"ID": "20230423123252-3khjjb6",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-3khjjb6",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承的概念"
				}
			]
		},
		{
			"ID": "20230423123252-jecc4cn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-jecc4cn",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "继承(inheritance)机制"
				},
				{
					"Type": "NodeText",
					"Data": "：是面向对象程序设计使代码可以复用的最重要的手段，它允许程序员在保持原有类特 性的基础上进行"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "扩展，增加新功能"
				},
				{
					"Type": "NodeText",
					"Data": "，这样产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构， 体现了由简单到复杂的认知过程。继承主要解决的问题是："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "共性的抽取，实现代码复用"
				},
				{
					"Type": "NodeText",
					"Data": "。\n例如：狗和猫都是动物，那么我们就可以将共性的内容进行抽取，然后采用继承的思想来达到共用。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222123810.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222123810.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-9v8p14n",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-9v8p14n",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承的语法"
				}
			]
		},
		{
			"ID": "20230423123252-q2drt23",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-q2drt23",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在Java中如果要表示类之间的继承关系，需要借助extends关键字，具体如下："
				}
			]
		},
		{
			"ID": "20230423123252-z3f0pf7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-z3f0pf7",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class 子类名 extends 父类名{\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-2dvq5ow",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-2dvq5ow",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Animal{  \n    String name;  \n    int age;  \n    public void eat(){  \n        System.out.println(name + \"正在吃饭\");  \n    }  \n    public void sleep(){  \n        System.out.println(name + \"正在睡觉\");  \n    }  \n}  \n// Dog.java  \npublic class Dog extends public Animal{  \n    void bark(){  \n        System.out.println(name + \"汪汪汪~~~\");  \n    }  \n}  \n  \n// Cat.Java  \npublic class Cat extends public Animal{  \n    void mew(){  \n        System.out.println(name + \"喵喵喵~~~\");  \n    }  \n}  \n  \n// TestExtend.java  \npublic class TestExtend {  \n    public static void main(String[] args) {  \n        Dog dog = new Dog();  \n\t\t// dog类中并没有定义任何成员变量，name和age属性肯定是从父类Animal中继承下来的  \n        System.out.println(dog.name);  \n        System.out.println(dog.age);  \n\t\t// dog访问的eat()和sleep()方法也是从Animal中继承下来的  \n        dog.eat();  \n        dog.sleep();  \n        dog.bark();  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-xfpp5f2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-xfpp5f2",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注意："
				}
			]
		},
		{
			"ID": "20230423123252-ry0pxhj",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-ry0pxhj",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-yn5675l",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-yn5675l",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-0v24n4f",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-0v24n4f",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "子类会将父类中的成员变量或者成员方法继承到子类中了"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-fnv23m8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-fnv23m8",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-nsuvmxy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-nsuvmxy",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "子类继承父类之后，必须要新添加自己特有的成员，体现出与基类的不同，否则就没有必要继承了"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-hf05eip",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-hf05eip",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "super关键字"
				}
			]
		},
		{
			"ID": "20230423123252-vslww7q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-vslww7q",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "由于设计不好，或者因场景需要，子类和父类中可能会存在相同名称的成员，如果要在子类方法中访问父类同名成员时，该如何操作？直接访问是无法做到的，Java提供了"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "super关键字，该关键字主要作用：在子类方法中访问父类的成员"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230423123252-o52984m",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-o52984m",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Base {  \n    int a;  \n    int b;  \n    public void methodA(){  \n        System.out.println(\"Base中的methodA()\");  \n    }  \n    public void methodB(){  \n        System.out.println(\"Base中的methodB()\");  \n    }  \n}  \n  \n class Derived extends Base{  \n    int a; // 与父类中成员变量同名且类型相同  \n    char b; // 与父类中成员变量同名但类型不同  \n  \n    // 与父类中methodA()构成重载  \n    public void methodA(int a) {  \n        System.out.println(\"Derived中的method()方法\");  \n    }  \n  \n    // 与基类中methodB()构成重写(即原型一致，重写后序详细介绍)  \n    public void methodB(){  \n        System.out.println(\"Derived中的methodB()方法\");  \n    }  \n  \n    public void methodC(){  \n        // 对于同名的成员变量，直接访问时，访问的都是子类的  \n        a = 100; // 等价于： this.a = 100;        b = 101; // 等价于： this.b = 101;  \n        // 注意：this是当前对象的引用  \n        // 访问父类的成员变量时，需要借助super关键字  \n        // super是获取到子类对象中从基类继承下来的部分  \n        super.a = 200;  \n        super.b = 201;  \n  \n        // 父类和子类中构成重载的方法，直接可以通 过参数列表区分清访问父类还是子类方法  \n        methodA(); // 没有传参，访问父类中的methodA()  \n        methodA(20); // 传递int参数，访问子类中的methodA(int)  \n  \n        // 如果在子类中要访问重写的基类方法，则需要借助super关键字  \n        methodB(); // 直接访问，则永远访问到的都是子类中的methodA()，基类的无法访问到  \n        super.methodB(); // 访问基类的methodB()  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-ycps0kl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-ycps0kl",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在子类方法中，如果想要明确访问父类中成员时，借助super关键字即可。"
				}
			]
		},
		{
			"ID": "20230423123252-1b43fvj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-1b43fvj",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "【注意事项】"
				}
			]
		},
		{
			"ID": "20230423123252-t1xw0vq",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-t1xw0vq",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-5javtrz",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-5javtrz",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-gfcbh2m",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-gfcbh2m",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "只能在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "mark",
									"TextMarkTextContent": "非静态方法"
								},
								{
									"Type": "NodeText",
									"Data": "中使用"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-mxk2u7i",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-mxk2u7i",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-41v9331",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-41v9331",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在子类方法中，访问父类的成员变量和方法。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-noy134p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-noy134p",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "super的其他用法在后文中介绍。"
				}
			]
		},
		{
			"ID": "20230423123252-r911o3e",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-r911o3e",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "子类构造方法"
				}
			]
		},
		{
			"ID": "20230423123252-7mlqwby",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-7mlqwby",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "父子父子，先有父再有子，即：子类对象构造时，需要先调用基类构造方法，然后执行子类的构造方法。"
				}
			]
		},
		{
			"ID": "20230423123252-vvg27ec",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-vvg27ec",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Base {  \n    public Base(){  \n        System.out.println(\"Base()\");  \n    }  \n}  \n  \n class Derived extends Base{  \n    public Derived(){  \n        // super(); // 注意子类构造方法中默认会调用基类的无参构造方法：super(),  \n        // 用户没有写时,编译器会自动添加，而且super()必须是子类构造方法中第一条语句，  \n        // 并且只能出现一次  \n        System.out.println(\"Derived()\");  \n    }  \n}\n\n//结果打印：\n//Base()\n//Derived()\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-ttj33q5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-ttj33q5",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在子类构造方法中，并没有写任何关于基类构造的代码，但是在构造子类对象时，先执行基类的构造方法，然后执行子类的构造方法，因为:"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "子类对象中成员是有两部分组成的，基类继承下来的以及子类新增加的部分。父子父子肯定是先有父再有子，所以在构造子类对象时候，先要调用基类的构造方法，将从基类继承下来的成员构造完整，然后再调用子类自己的构造方法，将子类自己新增加的成员初始化完整"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230423123252-0gh0jgj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-0gh0jgj",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注意:"
				}
			]
		},
		{
			"ID": "20230423123252-obh8k1m",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-obh8k1m",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-qxzuafj",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-qxzuafj",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-s1uc5lv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-s1uc5lv",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "若父类显式定义无参或者默认的构造方法，在子类构造方法第一行默认有隐含的super()调用，即调用基类构造方法"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-4slbio9",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-4slbio9",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-onh332e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-onh332e",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果父类构造方法是带有参数的，此时编译器不会再给子类生成默认的构造方法，此时需要用户为子类显式定义构造方法，并在子类构造方法中选择合适的父类构造方法调用，否则编译失败。"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-43olssw",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-43olssw",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-3dl4bxa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-3dl4bxa",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在子类构造方法中，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​调用父类构造时，必须是子类构造函数中第一条语句。"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-1kyftan",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230423123252-1kyftan",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-zi3m1gu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-zi3m1gu",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​只能在子类构造方法中出现一次，并且不能和"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​同时出现"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-vqjl1lr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-vqjl1lr",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "super和this"
				}
			]
		},
		{
			"ID": "20230423123252-sppc9gv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-sppc9gv",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "super和this都可以在成员方法中用来访问：成员变量和调用其他的成员函数，都可以作为构造方法的第一条语句，那他们之间有什么区别呢？"
				}
			]
		},
		{
			"ID": "20230423123252-lfkp8bz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-lfkp8bz",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "【相同点】"
				}
			]
		},
		{
			"ID": "20230423123252-6mhotfl",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-6mhotfl",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-fx01yc1",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-fx01yc1",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-2u4fhna",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-2u4fhna",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "都是Java中的关键字"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-8b4ahvw",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-8b4ahvw",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-tqpgeft",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-tqpgeft",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "只能在类的非静态方法中使用，用来访问非静态成员方法和字段"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-lphftco",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-lphftco",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-tyz2c5g",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-tyz2c5g",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在构造方法中调用时，必须是构造方法中的第一条语句，并且不能同时存在"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-849w6zm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-849w6zm",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "【不同点】"
				}
			]
		},
		{
			"ID": "20230423123252-uqrw8ii",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-uqrw8ii",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-nigfu9s",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-nigfu9s",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-x1ftror",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-x1ftror",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​是当前对象的引用，当前对象即调用实例方法的对象，super相当于是子类对象中从父类继承下来部分成员的引用、\n​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "Pasted image 20230222130149.png"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222130149.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-olhcdc6",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-olhcdc6",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-c34qsvn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-c34qsvn",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在非静态成员方法中，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​用来访问本类的方法和属性，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super"
								},
								{
									"Type": "NodeText",
									"Data": "​用来访问父类继承下来的方法和属性"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-tnyht31",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-tnyht31",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-g1w8abv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-g1w8abv",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "​"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​是非静态成员方法的一个隐藏参数，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super"
								},
								{
									"Type": "NodeText",
									"Data": "​不是隐藏的参数"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-x5xwhll",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20230423123252-x5xwhll",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-iu448d9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-iu448d9",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "成员方法中直接访问本类成员时，编译之后会将"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​还原，即本类非静态成员都是通过"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this"
								},
								{
									"Type": "NodeText",
									"Data": "​来访问的；在子类中如果通过"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super"
								},
								{
									"Type": "NodeText",
									"Data": "​访问父类成员，编译之后在字节码层面super实际是不存在的(通过字节码文件可以验证)\n​"
								},
								{
									"Type": "NodeImage",
									"Data": "span",
									"Children": [
										{
											"Type": "NodeBang"
										},
										{
											"Type": "NodeOpenBracket"
										},
										{
											"Type": "NodeLinkText",
											"Data": "Pasted image 20230222130418.png"
										},
										{
											"Type": "NodeCloseBracket"
										},
										{
											"Type": "NodeOpenParen"
										},
										{
											"Type": "NodeLinkDest",
											"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222130418.png"
										},
										{
											"Type": "NodeCloseParen"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-mzck65d",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20230423123252-mzck65d",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-ln501ez",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-ln501ez",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在构造方法中："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​用于调用本类构造方法，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​用于调用父类构造方法，两种调用不能同时在构造方法中出现"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-knll7cr",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Ni4=",
						"Num": 6
					},
					"Properties": {
						"id": "20230423123252-knll7cr",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-qc5a5by",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-qc5a5by",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "构造方法中一定会存在"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "super(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​的调用，用户没有写编译器也会增加，但是"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "this(...)"
								},
								{
									"Type": "NodeText",
									"Data": "​用户不写则没有"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-bx2evs9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-bx2evs9",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再谈初始化"
				}
			]
		},
		{
			"ID": "20230423123252-tr2kx0f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-tr2kx0f",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们还记得之前讲过的代码块吗？我们简单回顾一下几个重要的代码块：实例代码块和静态代码块。在没有继承关系时的执行顺序。"
				}
			]
		},
		{
			"ID": "20230423123252-s7uiwss",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-s7uiwss",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//Person.java\npublic class Person {  \n    public String name;  \n    public int age;  \n  \n    public Person(String name, int age) {  \n        this.name = name;  \n        this.age = age;  \n        System.out.println(\"构造方法执行\");  \n    }  \n  \n    {  \n        System.out.println(\"实例代码块执行\");  \n    }  \n  \n    static {  \n        System.out.println(\"静态代码块执行\");  \n    }  \n}\n\n//demo1.java\npublic class demo1 {  \n    public static void main(String[] args) {  \n        Person person1 = new Person(\"bit\",10);  \n        System.out.println(\"============================\");  \n        Person person2 = new Person(\"gaobo\",20);  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-hh1lcg2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-hh1lcg2",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "执行结果："
				}
			]
		},
		{
			"ID": "20230423123252-ykftbd2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-ykftbd2",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "静态代码块执行\n实例代码块执行\n构造方法执行\n============================\n实例代码块执行\n构造方法执行\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-mfhqot8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-mfhqot8",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "原因"
				}
			]
		},
		{
			"ID": "20230423123252-nuuac10",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-nuuac10",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-43u01ca",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-43u01ca",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-jw08uvw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-jw08uvw",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "静态代码块先执行，并且只执行一次，在类加载阶段执行"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-0xmmv1b",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-0xmmv1b",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-2ipsdqp",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-2ipsdqp",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当有对象创建时，才会执行实例代码块，实例代码块执行完成后，最后构造方法执行"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-sitmmu1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-sitmmu1",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "【继承关系上的执行顺序】"
				}
			]
		},
		{
			"ID": "20230423123252-o25im7l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-o25im7l",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Person {  \n    public String name;  \n    public int age;  \n    public Person(String name, int age) {  \n        this.name = name;  \n        this.age = age;  \n        System.out.println(\"Person：构造方法执行\");  \n    }  \n    {  \n        System.out.println(\"Person：实例代码块执行\");  \n    }  \n    static {  \n        System.out.println(\"Person：静态代码块执行\");  \n    }  \n}  \n  \nclass Student extends Person{  \n    public Student(String name,int age) {  \n        super(name,age);  \n        System.out.println(\"Student：构造方法执行\");  \n    }  \n  \n    {  \n        System.out.println(\"Student：实例代码块执行\");  \n    }  \n  \n    static {  \n        System.out.println(\"Student：静态代码块执行\");  \n    }  \n}  \n  \npublic class demo1 {  \n    public static void main(String[] args) {  \n        Student student1 = new Student(\"张三\",19);  \n        System.out.println(\"===========================\");  \n        Student student2 = new Student(\"李四\",20);  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-nlvtbvv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-nlvtbvv",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【执行结果】"
				}
			]
		},
		{
			"ID": "20230423123252-b6vp1ys",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-b6vp1ys",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Person：静态代码块执行\nStudent：静态代码块执行\nPerson：实例代码块执行\nPerson：构造方法执行\nStudent：实例代码块执行\nStudent：构造方法执行\n===========================\nPerson：实例代码块执行\nPerson：构造方法执行\nStudent：实例代码块执行\nStudent：构造方法执行\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-vqij043",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-vqij043",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "结果分析:\n1、父类静态代码块优先于子类静态代码块执行，且是最早执行\n2、父类实例代码块和父类构造方法紧接着执行\n3、子类的实例代码块和子类构造方法紧接着再执行\n4、第二次实例化子类对象时，父类和子类的静态代码块都将不会再执行"
				}
			]
		},
		{
			"ID": "20230423123252-wglafrq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-wglafrq",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "protected 关键字"
				}
			]
		},
		{
			"ID": "20230423123252-a992n4n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-a992n4n",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在类和对象章节中，为了实现封装特性，Java中引入了访问限定符，主要限定：类或者类中成员能否在类外或者其他包中被访问。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222133422.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222133422.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-dlsybpp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-dlsybpp",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那父类中不同访问权限的成员，在子类中的可见性又是什么样子的呢？"
				}
			]
		},
		{
			"ID": "20230423123252-5kg610e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-5kg610e",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 为了掩饰基类中不同访问权限在子类中的可见性，为了简单类B中就不设置成员方法了  \n// extend01包中  \npublic class B {  \n    private int a;  \n    protected int b;  \n    public int c;  \n    int d;  \n}  \n  \n// extend01包中  \n// 同一个包中的子类  \npublic class D extends B{  \n    public void method(){  \n        // super.a = 10; // 编译报错，父类private成员在相同包子类中不可见  \n        super.b = 20; // 父类中protected成员在相同包子类中可以直接访问  \n        super.c = 30; // 父类中public成员在相同包子类中可以直接访问  \n        super.d = 40; // 父类中默认访问权限修饰的成员在相同包子类中可以直接访问  \n    }  \n}  \n  \n// extend02包中  \n// 不同包中的子类  \npublic class C extends B {  \n    public void method(){  \n// super.a = 10; // 编译报错，父类中private成员在不同包子类中不可见  \n        super.b = 20; // 父类中protected修饰的成员在不同包子类中可以直接访问  \n        super.c = 30; // 父类中public修饰的成员在不同包子类中可以直接访问  \n//super.d = 40; // 父类中默认访问权限修饰的成员在不同包子类中不能直接访问  \n    }  \n}  \n  \n// extend02包中  \n// 不同包中的类  \npublic class TestC {  \n    public static void main(String[] args) {  \n        C c = new C();  \n        c.method();  \n        // System.out.println(c.a); // 编译报错，父类中private成员在不同包其他类中不可见  \n        // System.out.println(c.b); // 父类中protected成员在不同包其他类中不能直接访问  \n        System.out.println(c.c); // 父类中public成员在不同包其他类中可以直接访问  \n        // System.out.println(c.d); // 父类中默认访问权限修饰的成员在不同包其他类中不能直接访问  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-k6p3km6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-k6p3km6",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意：父类中private成员变量随时在子类中不能直接访问，但是也继承到子类中了"
				}
			]
		},
		{
			"ID": "20230423123252-hojfmar",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123252-hojfmar",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123252-nsiavqb",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-nsiavqb",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "什么时候下用哪一种呢?"
						},
						{
							"Type": "NodeText",
							"Data": "\n我们希望类要尽量做到 \"封装\", 即隐藏内部实现细节, 只暴露出 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "必要"
						},
						{
							"Type": "NodeText",
							"Data": " 的信息给类的调用者."
						}
					]
				},
				{
					"ID": "20230423123252-317cacc",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-317cacc",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "因此我们在使用的时候应该尽可能的使用 比较严格 的访问权限. 例如如果一个方法能用 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "private"
						},
						{
							"Type": "NodeText",
							"Data": "​, 就尽量不要用 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "public"
						},
						{
							"Type": "NodeText",
							"Data": "​."
						}
					]
				},
				{
					"ID": "20230423123252-ype08ac",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-ype08ac",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "另外, 还有一种 简单粗暴 的做法: 将所有的字段设为 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "private"
						},
						{
							"Type": "NodeText",
							"Data": "​, 将所有的方法设为 "
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "public"
						},
						{
							"Type": "NodeText",
							"Data": "​. 不过这种方式属于是对访问权限的滥用, 还是更希望同学们能写代码的时候认真思考, 该类提供的字段方法到底给 \"谁\" 使用(是类内部自己用, 还是类的调用者使用, 还是子类使用)."
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-60b8ewy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-60b8ewy",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承方式"
				}
			]
		},
		{
			"ID": "20230423123252-qe673tc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-qe673tc",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在现实生活中，事物之间的关系是非常复杂，灵活多样，比如：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222134856.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222134856.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-ei1i64a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-ei1i64a",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但在Java中只支持以下几种继承方式：\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222134909.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222134909.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-s9c85ia",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-s9c85ia",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注意：Java中不支持多继承"
				}
			]
		},
		{
			"ID": "20230423123252-q4n31wo",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123252-q4n31wo",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123252-k6cm15h",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-k6cm15h",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "时刻牢记,我们写的类是现实事物的抽象.而我们真正在公司中所遇到的项目往往业务比较复杂,可能会涉及到一系列复杂的概念,都需要我们使用代码来表示,所以我们真实项目中所写的类也会有很多.类之间的关系也会更加复杂.\n但是即使咄,我们并不希望类之间的继承层次太复杂."
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "strong",
							"TextMarkTextContent": "一般我们不希望出现超过三层的继承关系"
						},
						{
							"Type": "NodeText",
							"Data": ".如果继承层次太多,就需要考虑对代码进行重构了.\n如果想从语法上进行限制继承,就可以使用"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "final"
						},
						{
							"Type": "NodeText",
							"Data": "​关键字"
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-d6tqc5z",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-d6tqc5z",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "final 关键字"
				}
			]
		},
		{
			"ID": "20230423123252-086se3c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-086se3c",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "final关键可以用来修饰变量、成员方法以及类。"
				}
			]
		},
		{
			"ID": "20230423123252-cm16p9v",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-cm16p9v",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-jzpkis0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-jzpkis0",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-mmlyp96",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-mmlyp96",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修饰变量或字段，表示常量(即不能修改)"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-5i69z2a",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-5i69z2a",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "final int a = 10;\na = 20;//编译出错\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-nimspat",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-nimspat",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-yqp7k30",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-yqp7k30",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-hyrrpe6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-hyrrpe6",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修饰类：表示此类不能被继承"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-3j12w2j",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-3j12w2j",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "final public class Animal {\n...\n}\npublic class Bird extends Animal {\n...\n}\n\n\n// 编译出错\nError:(3, 27) java: 无法从最终com.bit.Animal进行继\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-um24lh5",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123252-um24lh5",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123252-iucuqc1",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-iucuqc1",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeTextMark",
							"TextMarkType": "em strong",
							"TextMarkTextContent": "小知识"
						},
						{
							"Type": "NodeText",
							"Data": "\n我们平时是用的 String 字符串类, 就是用 final 修饰的, 不能被继承.\n​"
						},
						{
							"Type": "NodeImage",
							"Data": "span",
							"Children": [
								{
									"Type": "NodeBang"
								},
								{
									"Type": "NodeOpenBracket"
								},
								{
									"Type": "NodeLinkText",
									"Data": "Pasted image 20230222135257.png"
								},
								{
									"Type": "NodeCloseBracket"
								},
								{
									"Type": "NodeOpenParen"
								},
								{
									"Type": "NodeLinkDest",
									"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222135257.png"
								},
								{
									"Type": "NodeCloseParen"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "​"
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-ihw8g9o",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-ihw8g9o",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-k7ol266",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-k7ol266",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-bn997ew",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-bn997ew",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "修饰方法：表示该方法不能被重写(后序介绍)"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-384yjsx",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-384yjsx",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "继承与组合"
				}
			]
		},
		{
			"ID": "20230423123252-6o6iq9t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-6o6iq9t",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和继承类似, 组合也是一种表达类之间关系的方式, 也是能够达到代码重用的效果。组合并没有涉及到特殊的语法(诸如 extends 这样的关键字), 仅仅是将一个类的实例作为另外一个类的字段。\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "继承表示对象之间是is-a"
				},
				{
					"Type": "NodeText",
					"Data": "的关系，比如：狗是动物，猫是动物\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "组合表示对象之间是has-a"
				},
				{
					"Type": "NodeText",
					"Data": "的关系，比如：汽车\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222135628.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222135628.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-l95bn37",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-l95bn37",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 轮胎类  \nclass Tire{  \n// ...  \n}  \n\n// 发动机类  \nclass Engine{  \n// ...  \n}  \n\n// 车载系统类  \nclass VehicleSystem{  \n// ...  \n}  \n\nclass Car{  \n    private Tire tire; // 可以复用轮胎中的属性和方法  \n    private Engine engine; // 可以复用发动机中的属性和方法  \n    private VehicleSystem vs; // 可以复用车载系统中的属性和方法  \n\t// ...  \n}  \n\n// 奔驰是汽车  \nclass Benz extend Car{  \n\t// 将汽车中包含的：轮胎、发送机、车载系统全部继承下来  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-ohs8hs9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-ohs8hs9",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "组合和继承都可以实现代码复用，应该使用继承还是组合，需要根据应用场景来选择，一般建议：能用组合尽量用组合。"
				}
			]
		},
		{
			"ID": "20230423123252-lq145ys",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-lq145ys",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://www.hollischuang.com/archives/1319",
					"TextMarkTextContent": "继承与组合详解"
				}
			]
		},
		{
			"ID": "20230423123313-p6nj7ap",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123313-p6nj7ap"
			}
		},
		{
			"ID": "20230423123252-2e01o16",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123252-2e01o16",
				"updated": "20230423123312"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态"
				}
			]
		},
		{
			"ID": "20230423123252-8okyqz9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-8okyqz9",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态的概念"
				}
			]
		},
		{
			"ID": "20230423123252-te409x6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-te409x6",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态的概念：通俗来说，就是多种形态，具"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "体点就是去完成某个行为，当不同的对象去完成时会产生出不同 的状态"
				},
				{
					"Type": "NodeText",
					"Data": "。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222140053.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222140053.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-3xg3f5q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-3xg3f5q",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "总的来说：同一件事情，发生在不同对象身上，就会产生不同的结果。"
				}
			]
		},
		{
			"ID": "20230423123252-ehz1kmg",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-ehz1kmg",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态实现条件"
				}
			]
		},
		{
			"ID": "20230423123252-j19j7ba",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-j19j7ba",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在java中要实现多态，必须要满足如下几个条件，缺一不可："
				}
			]
		},
		{
			"ID": "20230423123252-fcv64bo",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-fcv64bo",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-6v1shvm",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-6v1shvm",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-3r6jbs8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-3r6jbs8",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "必须在继承体系下"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-9dpygwv",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-9dpygwv",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-mbb0kyz",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-mbb0kyz",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "子类必须要对父类中方法进行重写"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-hev36z7",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-hev36z7",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-61794us",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-61794us",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "通过父类的引用调用重写的方法"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-k3mxdsw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-k3mxdsw",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "多态体现：在代码运行时，当传递不同类对象时，会调用对应类中的方法。"
				}
			]
		},
		{
			"ID": "20230423123252-fgu496y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-fgu496y",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Animal {String name;  \n    int age;  \n    public Animal(String name, int age){  \n        this.name = name;  \n        this.age = age;  \n    }  \n    public void eat(){  \n        System.out.println(name + \"吃饭\");  \n    }  \n}  \n\npublic class Cat extends Animal{  \n    public Cat(String name, int age){  \n        super(name, age);  \n    }  \n    @Override  \n    public void eat(){  \n        System.out.println(name+\"吃鱼~~~\");  \n    }  \n}  \n\npublic class Dog extends Animal {  \n    public Dog(String name, int age){  \n        super(name, age);  \n    }  \n    @Override  \n    public void eat(){  \n        System.out.println(name+\"吃骨头~~~\");  \n    }  \n}\n\n///////////////////////////////分割线/////////////////////////////////////////\n\npublic class TestAnimal {  \n    // 编译器在编译代码时，并不知道要调用Dog 还是 Cat 中eat的方法  \n\t// 等程序运行起来后，形参a引用的具体对象确定后，才知道调用那个方法  \n\t// 注意：此处的形参类型必须时父类类型才可以  \n    public static void eat(Animal a){  \n        a.eat();  \n    }  \n    public static void main(String[] args) {  \n        Cat cat = new Cat(\"元宝\",2);  \n        Dog dog = new Dog(\"小七\", 1);  \n        eat(cat);  \n        eat(dog);  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-4qa1igx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-4qa1igx",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在上述代码中, 分割线上方的代码是 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "类的实现者"
				},
				{
					"Type": "NodeText",
					"Data": " 编写的, 分割线下方的代码是 类的调用者 编写的."
				}
			]
		},
		{
			"ID": "20230423123252-quqi7l3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-quqi7l3",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当类的调用者在编写 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "eat"
				},
				{
					"Type": "NodeText",
					"Data": "​ 这个方法的时候, 参数类型为 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Animal (父类)"
				},
				{
					"Type": "NodeText",
					"Data": "​, 此时在该方法内部并"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "不知道, 也不关注"
				},
				{
					"Type": "NodeText",
					"Data": "当前的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "a"
				},
				{
					"Type": "NodeText",
					"Data": "​ 引用指向的是哪个类型(哪个子类)的实例. 此时 a这个引用调用 eat方法可能会有多种不同的表现(和 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "a"
				},
				{
					"Type": "NodeText",
					"Data": "​ 引用的实例相关), 这种行为就称为 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "多态"
				},
				{
					"Type": "NodeText",
					"Data": ".\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222141643.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222141643.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-5g1mh6q",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-5g1mh6q",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "重写"
				}
			]
		},
		{
			"ID": "20230423123252-3govosc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-3govosc",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "重写(override)：也称为覆盖。重写是子类对父类非静态、非private修饰，非final修饰，非构造方法等的实现过程进行重新编写, "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "返回值和形参都不能改变。即外壳不变，核心重写"
				},
				{
					"Type": "NodeText",
					"Data": "！重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。"
				}
			]
		},
		{
			"ID": "20230423123252-yr6iyta",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-yr6iyta",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【方法重写的规则】"
				}
			]
		},
		{
			"ID": "20230423123252-2b997ud",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123252-2b997ud",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123252-0bzn8ot",
					"Type": "NodeList",
					"ListData": {},
					"Properties": {
						"id": "20230423123252-0bzn8ot",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-x8h3msr",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-x8h3msr",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-1i640ph",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-1i640ph",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "子类在重写父类的方法必须与父类方法原型一致:"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "strong",
											"TextMarkTextContent": "修饰符 返回值类型方法名(参数列表)要完全一致"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-h5tsfp2",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-h5tsfp2",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-dbcabrp",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-dbcabrp",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "JDK7以后，被重写的方法返回值类型可以不同，但是必须是具有父子关系的"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-bdrmi1u",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-bdrmi1u",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-7k2tt39",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-7k2tt39",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "访问权限不能比父类中被重写的方法的访问权限更低。例如:如果父类方法被"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "public"
										},
										{
											"Type": "NodeText",
											"Data": "​修饰，则子类中重写该方法就不能声明为"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "protected"
										},
										{
											"Type": "NodeText",
											"Data": "​"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-bgdaejs",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-bgdaejs",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-dpp1yjt",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-dpp1yjt",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "父类被"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "static"
										},
										{
											"Type": "NodeText",
											"Data": "​、"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "private"
										},
										{
											"Type": "NodeText",
											"Data": "​修饰的方法、构造方法都不能被重写。"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-0ghjh0w",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-0ghjh0w",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-nhg1jdg",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-nhg1jdg",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "private"
										},
										{
											"Type": "NodeText",
											"Data": "​和"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "final"
										},
										{
											"Type": "NodeText",
											"Data": "​的方法。"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-8qyc1jc",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-8qyc1jc",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-oh2u5y3",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-oh2u5y3",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "子类和父类不在同一个包中，那么子类只能够重写父类的声明为"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "public"
										},
										{
											"Type": "NodeText",
											"Data": "​和"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "protected"
										},
										{
											"Type": "NodeText",
											"Data": "​ 的非"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "final"
										},
										{
											"Type": "NodeText",
											"Data": "​方法。"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123252-321q3va",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123252-321q3va",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"ID": "20230423123252-wfs59v2",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123252-wfs59v2",
										"updated": "20230423123252"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "重写的方法,可以使用"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "@Override"
										},
										{
											"Type": "NodeText",
											"Data": "​注解来显式指定.有了这个注解能帮我们进行一些合法性校验.例如不小心将方法名字拼写错了(比如写成aet),那么此时编译器就会发现父类中没有aet方法,就会编译报错,提示无法构成重写."
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-fte1xl6",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-fte1xl6",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【重写和重载的区别】"
				}
			]
		},
		{
			"ID": "20230423123252-301zr1e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-301zr1e",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222154832.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222154832.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-st6turi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-st6turi",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "即：方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222154901.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222154901.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-ry087v3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-ry087v3",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【重写的设计原则】"
				}
			]
		},
		{
			"ID": "20230423123252-o7qylhm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-o7qylhm",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于已经投入使用的类，尽量不要进行修改。最好的方式是：重新定义一个新的类，来重复利用其中共性的内容，并且添加或者改动新的内容。"
				}
			]
		},
		{
			"ID": "20230423123252-x0hz9vp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-x0hz9vp",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如：若干年前的手机，只能打电话，发短信，来电显示只能显示号码，而今天的手机在来电显示的时候，不仅仅可以显示号码，还可以显示头像，地区等。在这个过程当中，我"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "们不应该在原来老的类上进行修改，因为原来的类，可能还在有用户使用"
				},
				{
					"Type": "NodeText",
					"Data": "，正确做法是："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "新建一个新手机的类，对来电显示这个方法重写就好了，这样就达到了我们当今的需求了"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230423123252-7qejm7y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-7qejm7y",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222155148.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222155148.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-qa6fkzt",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-qa6fkzt",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "静态绑定和动态绑定"
				}
			]
		},
		{
			"ID": "20230423123252-0u267go",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-0u267go",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "静态绑定"
				},
				{
					"Type": "NodeText",
					"Data": "：也称为前期绑定(早绑定)，即在编译时，根据用户所传递实参类型就确定了具体调用那个方法。典型代表函数重载。"
				}
			]
		},
		{
			"ID": "20230423123252-s8nwos3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-s8nwos3",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "动态绑定"
				},
				{
					"Type": "NodeText",
					"Data": "：也称为后期绑定(晚绑定)，即在编译时，不能确定方法的行为，需要等到程序运行时，才能够确定具体调用那个类的方法。"
				}
			]
		},
		{
			"ID": "20230423123252-g63c19y",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-g63c19y",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向上转移和向下转型"
				}
			]
		},
		{
			"ID": "20230423123252-bws92ga",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-bws92ga",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向上转型"
				}
			]
		},
		{
			"ID": "20230423123252-wkg8lam",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-wkg8lam",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向上转型：实际就是创建一个子类对象，将其当成父类对象来使用。"
				}
			]
		},
		{
			"ID": "20230423123252-elr6tx9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-elr6tx9",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "语法格式："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "父类类型 对象名 = new 子类类型()"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-j5gffgw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-j5gffgw",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Animal animal = new Cat(\"元宝\" ,2);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-1zqj9h4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-1zqj9h4",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "animal"
				},
				{
					"Type": "NodeText",
					"Data": "​是父类类型，但可以引用一个子类对象，因为是从小范围向大范围的转换。"
				}
			]
		},
		{
			"ID": "20230423123252-wo4tlnn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-wo4tlnn",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20230222155428.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/Pasted%20image%2020230222155428.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123252-ep1kju3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-ep1kju3",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "em strong",
					"TextMarkTextContent": "使用场景"
				}
			]
		},
		{
			"ID": "20230423123252-qtc6gg1",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-qtc6gg1",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-1i2r1p2",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-1i2r1p2",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-0vcqxou",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-0vcqxou",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "直接赋值"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-8s48rvq",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-8s48rvq",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-a7k2p69",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-a7k2p69",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法传参"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-pzb75do",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123252-pzb75do",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-mrd7aol",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-mrd7aol",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法返回"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-dz8br3g",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-dz8br3g",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class TestAnimal {  \n    // 2. 方法传参：形参为父类型引用，可以接收任意子类的对象  \n    public static void eatFood(Animal a){  \n        a.eat();  \n    }  \n  \n    // 3. 作返回值：返回任意子类对象  \n    public static Animal buyAnimal(String var){  \n        if(\"狗\" == var){  \n            return new Dog(\"狗狗\",1);  \n        }else if(\"猫\" == var){  \n            return new Cat(\"猫猫\", 1);  \n        }else{  \n            return null;  \n        }  \n    }  \n  \n    public static void main(String[] args) {  \n        Animal cat = new Cat(\"元宝\",2); // 1. 直接赋值：子类对象赋值给父类对象  \n        Dog dog = new Dog(\"小七\", 1);\n      \n        eatFood(cat);  \n        eatFood(dog);  \n    \n        Animal animal = buyAnimal(\"狗\");  \n        animal.eat();  \n    \n        animal = buyAnimal(\"猫\");  \n        animal.eat();  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-f16t8q4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-f16t8q4",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "向上转型的优点：让代码实现更简单灵活。向上转型的缺陷：不能调用到子类特有的方法。"
				}
			]
		},
		{
			"ID": "20230423123252-et7p106",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-et7p106",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向下转型"
				}
			]
		},
		{
			"ID": "20230423123252-zyneaao",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-zyneaao",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将一个子类对象经过向上转型之后当成父类方法使用，再无法调用子类的方法，但有时候可能需要调用子类特有的方法，此时：将父类引用再还原为子类对象即可，即向下转换。"
				}
			]
		},
		{
			"ID": "20230423123252-se848nf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-se848nf",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class TestAnimal {  \n    public static void main(String[] args) {  \n        Cat cat = new Cat(\"元宝\",2);  \n        Dog dog = new Dog(\"小七\", 1);  \n\n\t\t// 向上转型  \n        Animal animal = cat;  \n        animal.eat();  \n        animal = dog;  \n        animal.eat();  \n\n\t\t// 编译失败，编译时编译器将animal当成Animal对象处理  \n\t\t// 而Animal类中没有bark方法，因此编译失败  \n\t\t// animal.bark();  \n\n\t\t// 向上转型  \n\t\t// 程序可以通过编程，但运行时抛出异常---因为：animal实际指向的是狗  \n\t\t// 现在要强制还原为猫，无法正常还原，运行时抛出：ClassCastException  \n        cat = (Cat)animal;  \n        cat.mew();  \n\n\t\t// animal本来指向的就是狗，因此将animal还原为狗也是安全的  \n        dog = (Dog)animal;  \n        dog.bark();  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-qbtazsm",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20230423123252-qbtazsm",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "instanceof"
				}
			]
		},
		{
			"ID": "20230423123252-b5e5xuy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-b5e5xuy",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "向下转型用的比较少，而且不安全，万一转换失败，运行时就会抛异常。Java中为了提高向下转型的安全性，引入了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "instanceof"
				},
				{
					"Type": "NodeText",
					"Data": "​ ，返回值是bool类型， 如果该表达式为"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "true"
				},
				{
					"Type": "NodeText",
					"Data": "​，则可以安全转换。"
				}
			]
		},
		{
			"ID": "20230423123252-prbzeap",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-prbzeap",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class TestAnimal {  \n    public static void main(String[] args) {  \n        Cat cat = new Cat(\"元宝\",2);  \n        Dog dog = new Dog(\"小七\", 1);  \n\n\t\t// 向上转型  \n        Animal animal = cat;  \n        animal.eat();  \n        animal = dog;  \n        animal.eat();  \n    \n        if(animal instanceof Cat){  \n            cat = (Cat)animal;  \n            cat.mew();  \n        }  \n    \n        if(animal instanceof Dog){  \n            dog = (Dog)animal;  \n            dog.bark();  \n        }  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-13nj1yp",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123252-13nj1yp",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态的优缺点"
				}
			]
		},
		{
			"ID": "20230423123252-jfhj4j3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-jfhj4j3",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【使用多态的好处】"
				}
			]
		},
		{
			"ID": "20230423123252-nexbl0u",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-nexbl0u",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-dkvir7h",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123252-dkvir7h",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-tk33ozj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-tk33ozj",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "能够降低代码的 \u0026quot;圈复杂度\u0026quot;, 避免使用大量的 if - else"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-h6vtbg7",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123252-h6vtbg7",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123252-mqby0t0",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123252-mqby0t0",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "什么叫 \"圈复杂度\" ?\n圈复杂度是一种描述一段代码复杂程度的方式. 一段代码如果平铺直叙, 那么就比较简单容易理解. 而如果有很多的条件分支或者循环语句, 就认为理解起来更复杂.\n因此我们可以简单粗暴的计算一段代码中条件语句和循环语句出现的个数, 这个个数就称为 \"圈复杂度\".如果一个方法的圈复杂度太高, 就需要考虑重构.\n不同公司对于代码的圈复杂度的规范不一样. 一般不会超过 10 ."
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-l0wj11w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-l0wj11w",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如我们现在需要打印的不是一个形状了, 而是多个形状. 如果不基于多态, 实现代码如下:"
				}
			]
		},
		{
			"ID": "20230423123252-8ngaovt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-8ngaovt",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void drawShapes() {  \n    Rect rect = new Rect();  \n    Cycle cycle = new Cycle();  \n    Flower flower = new Flower();  \n    String[] shapes = {\"cycle\", \"rect\", \"cycle\", \"rect\", \"flower\"};  \n    for (String shape : shapes) {  \n        if (shape.equals(\"cycle\")) {  \n            cycle.draw();  \n        } else if (shape.equals(\"rect\")) {  \n            rect.draw();  \n        } else if (shape.equals(\"flower\")) {  \n            flower.draw();  \n        }  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-xtwrxcn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-xtwrxcn",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果使用使用多态, 则不必写这么多的 if - else 分支语句, 代码更简单."
				}
			]
		},
		{
			"ID": "20230423123252-c7n0f5e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-c7n0f5e",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void drawShapes() {  \n\t// 我们创建了一个 Shape 对象的数组.  \n\tShape[] shapes = {new Cycle(), new Rect(), new Cycle(),  new Rect(), new Flower()};  \n\tfor (Shape shape : shapes) {  \n\t\tshape.draw();  \n\t}  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-u9e9rkd",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123252-u9e9rkd",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-z3286ee",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123252-z3286ee",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-u81hb7t",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-u81hb7t",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "可扩展能力更强\n如果要新增一种新的形状, 使用多态的方式代码改动成本也比较低."
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-k7sbllg",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-k7sbllg",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Triangle extends Shape {  \n    @Override  \n    public void draw() {  \n        System.out.println(\"△\");  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-60h990j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-60h990j",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于类的调用者来说(drawShapes方法), 只要创建一个新类的实例就可以了, 改动成本很低.\n而对于不用多态的情况, 就要把 drawShapes 中的 if - else 进行一定的修改, 改动成本更高."
				}
			]
		},
		{
			"ID": "20230423123252-hw0af13",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123252-hw0af13",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "【使用多态的缺陷】"
				}
			]
		},
		{
			"ID": "20230423123252-4oztppa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-4oztppa",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多态缺陷：代码的运行效率降低。"
				}
			]
		},
		{
			"ID": "20230423123252-y61e5s6",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123252-y61e5s6",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "避免在构造方法中调用重写的方法"
				}
			]
		},
		{
			"ID": "20230423123252-cjhm4sc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-cjhm4sc",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一段有坑的代码. 我们创建两个类, B 是父类, D 是子类. D 中重写 func 方法. 并且在 B 的构造方法中调用 func"
				}
			]
		},
		{
			"ID": "20230423123252-5nt556b",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123252-5nt556b",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class B {  \n    public B() {  \n\t\t// do nothing  \n        func();  \n    }  \n  \n    public void func() {  \n        System.out.println(\"B.func()\");  \n    }  \n}  \n\nclass D extends B {  \n    private int num = 1;  \n    @Override  \n    public void func() {  \n        System.out.println(\"D.func() \" + num);  \n    }  \n}  \n\npublic class Test {  \n    public static void main(String[] args) {  \n        D d = new D();  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123252-8pidkxm",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20230423123252-8pidkxm",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"ID": "20230423123252-c0lb1te",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230423123252-c0lb1te",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-9enuyqk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-9enuyqk",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "构造 D 对象的同时, 会调用 B 的构造方法."
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-uc1u3oe",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230423123252-uc1u3oe",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-nd2guuf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-nd2guuf",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "B 的构造方法中调用了 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "func()"
								},
								{
									"Type": "NodeText",
									"Data": "​ 方法, 此时会触发动态绑定, 会调用到 D 中的 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "func"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123252-q8s6hi4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20230423123252-q8s6hi4",
						"updated": "20230423123252"
					},
					"Children": [
						{
							"ID": "20230423123252-nfiuplt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123252-nfiuplt",
								"updated": "20230423123252"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "此时 D 对象自身还没有构造, 此时 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "num"
								},
								{
									"Type": "NodeText",
									"Data": "​ 处在未初始化的状态, 值为 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "0"
								},
								{
									"Type": "NodeText",
									"Data": "."
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123252-m5wh6ok",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123252-m5wh6ok",
				"updated": "20230423123252"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "结论"
				},
				{
					"Type": "NodeText",
					"Data": ": \"用尽量简单的方式使对象进入可工作状态\", 尽量不要在构造器中调用方法(如果这个方法被子类重写, 就会触发动态绑定, 但是此时子类对象还没构造完成), 可能会出现一些隐藏的但是又极难发现的问题."
				}
			]
		}
	]
}