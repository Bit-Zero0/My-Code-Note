{
	"ID": "20230423123542-5at1ru4",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20230423123542-5at1ru4",
		"title": "泛型",
		"updated": "20230423123555"
	},
	"Children": [
		{
			"ID": "20230423123555-64yf2e4",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-64yf2e4",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "什么是泛型"
				}
			]
		},
		{
			"ID": "20230423123555-2iecofk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-2iecofk",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一般的类和方法，只能使用具体的类型: 要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。"
				}
			]
		},
		{
			"ID": "20230423123555-n4jbztl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-n4jbztl",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型是在JDK1.5引入的新的语法，通俗讲，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "mark strong",
					"TextMarkTextContent": "泛型"
				},
				{
					"Type": "NodeText",
					"Data": "：就"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "是适用于许多许多类型"
				},
				{
					"Type": "NodeText",
					"Data": "。从代码上讲，就是对"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "类型实现了参数化"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20230423123555-xzj12mq",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-xzj12mq",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型解决了什么"
				}
			]
		},
		{
			"ID": "20230423123555-lwetblg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-lwetblg",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "未出现泛型前"
				},
				{
					"Type": "NodeText",
					"Data": "\n实现一个类，类中包含一个数组成员，使得数组中可以存放任何类型的数据，也可以根据成员方法返回数组中某个下标的值？"
				}
			]
		},
		{
			"ID": "20230423123555-xiqxhtu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-xiqxhtu",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "思路："
				}
			]
		},
		{
			"ID": "20230423123555-22uqqjr",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123555-22uqqjr",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"ID": "20230423123555-3d8eefl",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123555-3d8eefl",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-r4ym6q3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-r4ym6q3",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "我们以前学过的数组，只能存放指定类型的元素，例如："
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "int[] array = new int[10]; String[] strs = new String[10];"
								},
								{
									"Type": "NodeText",
									"Data": "​"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123555-291qugy",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123555-291qugy",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-76gpmh9",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-76gpmh9",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "所有类的父类，默认为[[Object类]]。数组是否可以创建为Object?"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-clnmpom",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-clnmpom",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "代码实例"
				}
			]
		},
		{
			"ID": "20230423123555-qv7n0uh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-qv7n0uh",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyArray {  \n    public Object[] array = new Object[10];  \n    public Object getPos(int pos) {  \n        return this.array[pos];  \n    }  \n    public void setVal(int pos,Object val) {  \n        this.array[pos] = val;  \n    }  \n}  \n\npublic class TestDemo {  \n    public static void main(String[] args) {  \n        MyArray myArray = new MyArray();  \n        myArray.setVal(0,10);  \n        myArray.setVal(1,\"hello\");//字符串也可以存放  \n        String ret = myArray.getPos(1);//编译报错  \n        System.out.println(ret);  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-1e8b0ku",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-1e8b0ku",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "问题：以上代码实现后 发现"
				}
			]
		},
		{
			"ID": "20230423123555-s1hppqg",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123555-s1hppqg",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"ID": "20230423123555-i7hfvfi",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123555-i7hfvfi",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-8hijzhs",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-8hijzhs",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "任何类型数据都可以存放"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123555-yz648p8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123555-yz648p8",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-udl45im",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-udl45im",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "1号下标"
								},
								{
									"Type": "NodeText",
									"Data": "本身就是字符串，但是确编译报错。必须进行强制类型转换"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-hu87pg7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-hu87pg7",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然在这种情况下，当前数组任何数据都可以存放，但是，更多情况下，我们还是希望他只能够持有一种数据类型。而不是同时持有这么多类型。\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "所以，泛型的主要目的：就是指定当前的容器，要持有什么类型的对象。让编译器去做检查"
				},
				{
					"Type": "NodeText",
					"Data": "。此时，就需要把类型，作为参数传递。需要什么类型，就传入什么类型。"
				}
			]
		},
		{
			"ID": "20230423123555-nx3xngt",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-nx3xngt",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型语法"
				}
			]
		},
		{
			"ID": "20230423123555-9ua64ps",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-9ua64ps",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class 泛型类名称\u003c类型形参列表\u003e {\n\t// 这里可以使用类型参数\n}\nclass ClassName\u003cT1, T2, ..., Tn\u003e {\n}\n\nclass 泛型类名称\u003c类型形参列表\u003e extends 继承类/* 这里可以使用类型参数 */ {\n\t// 这里可以使用类型参数\n}\n\nclass ClassName\u003cT1, T2, ..., Tn\u003e extends ParentClass\u003cT1\u003e {\n\t// 可以只使用部分类型参数\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-8yoav68",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-8yoav68",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上述代码进行改写如下："
				}
			]
		},
		{
			"ID": "20230423123555-s8b8io9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-s8b8io9",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyArray\u003cT\u003e {  \n    public T[] array = (T[])new Object[10];//不能new泛型类型的数组 \n    public T getPos(int pos) {  \n        return this.array[pos];  \n    }  \n    public void setVal(int pos,T val) {  \n        this.array[pos] = val;  \n    }  \n}  \npublic class TestDemo {  \n    public static void main(String[] args) {  \n        MyArray\u003cInteger\u003e myArray = new MyArray\u003c\u003e();//类型后加入\u003cInteger\u003e 指定当前类型 \n        myArray.setVal(0,10);  \n        myArray.setVal(1,12);  \n        int ret = myArray.getPos(1);//不需要进行强制类型转换  \n        System.out.println(ret);  \n        myArray.setVal(2,\"bit\");//4  代码编译报错\n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-da7i9rq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-da7i9rq",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "类名后的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "\u0026lt;T\u0026gt;"
				},
				{
					"Type": "NodeText",
					"Data": "​ 代表占位符，表示当前类是一个泛型类\n了解： 【规范】类型形参一般使用一个大写字母表示，常用的名称有："
				}
			]
		},
		{
			"ID": "20230423123555-smj7jyy",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123555-smj7jyy",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123555-sgtxvsf",
					"Type": "NodeList",
					"ListData": {},
					"Properties": {
						"id": "20230423123555-sgtxvsf",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-xdq3et2",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-xdq3et2",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-yw5v46x",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-yw5v46x",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "E"
										},
										{
											"Type": "NodeText",
											"Data": "​ 表示 Element"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123555-wfuq6c2",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-wfuq6c2",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-m192nj6",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-m192nj6",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "K"
										},
										{
											"Type": "NodeText",
											"Data": "​ 表示 Key"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123555-zh2mfq4",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-zh2mfq4",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-qm8x3gh",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-qm8x3gh",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "V"
										},
										{
											"Type": "NodeText",
											"Data": "​ 表示 Value"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123555-0h12m62",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-0h12m62",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-3vzjhpu",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-3vzjhpu",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "N"
										},
										{
											"Type": "NodeText",
											"Data": "​ 表示 Number"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123555-lwigk2p",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-lwigk2p",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-anu7fss",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-anu7fss",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "T"
										},
										{
											"Type": "NodeText",
											"Data": "​ 表示 Type"
										}
									]
								}
							]
						},
						{
							"ID": "20230423123555-5ci49s0",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20230423123555-5ci49s0",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"ID": "20230423123555-qq8z59f",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20230423123555-qq8z59f",
										"updated": "20230423123555"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "​"
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "S"
										},
										{
											"Type": "NodeText",
											"Data": "​, "
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "U"
										},
										{
											"Type": "NodeText",
											"Data": "​, "
										},
										{
											"Type": "NodeTextMark",
											"TextMarkType": "code",
											"TextMarkTextContent": "V"
										},
										{
											"Type": "NodeText",
											"Data": "​ 等等 - 第二、第三、第四个类型"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-8c2aorb",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-8c2aorb",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型类的使用"
				}
			]
		},
		{
			"ID": "20230423123555-9qoexpc",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-9qoexpc",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "语法"
				}
			]
		},
		{
			"ID": "20230423123555-92gvzq0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-92gvzq0",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "泛型类\u003c类型实参\u003e 变量名; // 定义一个泛型类引用\nnew 泛型类\u003c类型实参\u003e(构造方法实参); // 实例化一个泛型类对象\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-52z1ak2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-52z1ak2",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "MyArray\u003cInteger\u003e list = new MyArray\u003cInteger\u003e();\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-33ftf00",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-33ftf00",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注意：泛型只能接受类，所有的基本数据类型必须使用包装类！"
				}
			]
		},
		{
			"ID": "20230423123555-sbaoqk5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-sbaoqk5",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "类型推导(Type Inference)"
				}
			]
		},
		{
			"ID": "20230423123555-ydfo74e",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-ydfo74e",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当编译器可以根据上下文推导出类型实参时，可以省略类型实参的填写"
				}
			]
		},
		{
			"ID": "20230423123555-h5kf9qj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-h5kf9qj",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "MyArray\u003cInteger\u003e list = new MyArray\u003c\u003e(); // 可以推导出实例化需要的类型实参为 Integer\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-8g0lo3n",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-8g0lo3n",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "裸类型(Raw Type)"
				}
			]
		},
		{
			"ID": "20230423123555-iw82ynh",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-iw82ynh",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "说明"
				}
			]
		},
		{
			"ID": "20230423123555-qwzhi78",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-qwzhi78",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "裸类型是一个泛型类但没有带着类型实参，例如 MyArrayList 就是一个裸类型"
				}
			]
		},
		{
			"ID": "20230423123555-7y9hqc7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-7y9hqc7",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "MyArray list = new MyArray();\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-hegd8lw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-hegd8lw",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意： 我们不要自己去使用裸类型，因为泛型是在Java1.5出现的,之前的Java实现的API中是没有泛型机制的, 裸类型是为了兼容老版本的 API 保留的机制"
				}
			]
		},
		{
			"ID": "20230423123555-9f8h6k5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-9f8h6k5",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "下面的类型擦除部分，我们也会讲到编译器是如何使用裸类型的。"
				}
			]
		},
		{
			"ID": "20230423123555-pznr62i",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-pznr62i",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "小结："
				}
			]
		},
		{
			"ID": "20230423123555-b6xzc24",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20230423123555-b6xzc24",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"ID": "20230423123555-hiemrxh",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20230423123555-hiemrxh",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-c547dbd",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-c547dbd",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "泛型是将数据类型参数化，进行传递"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123555-wjbiaxd",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20230423123555-wjbiaxd",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-vp058tn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-vp058tn",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "\u0026lt;T\u0026gt;"
								},
								{
									"Type": "NodeText",
									"Data": "​ 表示当前类是一个泛型类。"
								}
							]
						}
					]
				},
				{
					"ID": "20230423123555-cbxrk99",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20230423123555-cbxrk99",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"ID": "20230423123555-2uweghy",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20230423123555-2uweghy",
								"updated": "20230423123555"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "泛型目前为止的优点：数据类型参数化，编译时自动进行类型检查和转换"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-53uvwqi",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-53uvwqi",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型是如何编译的"
				}
			]
		},
		{
			"ID": "20230423123555-aboeyv2",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-aboeyv2",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "擦除机制"
				}
			]
		},
		{
			"ID": "20230423123555-i41odc7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-i41odc7",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么，泛型到底是怎么编译的？这个问题，也是曾经的一个面试问题。泛型本质是一个非常难的语法，要理解好他还是需要一定的时间打磨。"
				}
			]
		},
		{
			"ID": "20230423123555-2ck35be",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-2ck35be",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过命令："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "javap -c"
				},
				{
					"Type": "NodeText",
					"Data": "​ 查看字节码文件，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "mark strong",
					"TextMarkTextContent": "所有的T都是Object"
				},
				{
					"Type": "NodeText",
					"Data": "。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "image.png"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://image-1311137268.cos.ap-chengdu.myqcloud.com/SiYuan/20230422221343.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "​"
				}
			]
		},
		{
			"ID": "20230423123555-athdmfx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-athdmfx",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "mark",
					"TextMarkTextContent": "在编译的过程当中，将所有的T替换为Object这种机制，我们称为："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "mark strong",
					"TextMarkTextContent": "擦除机制"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "mark",
					"TextMarkTextContent": "。"
				}
			]
		},
		{
			"ID": "20230423123555-mb6kt7p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-mb6kt7p",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "泛型机制是在编译级别实现"
				},
				{
					"Type": "NodeText",
					"Data": "的。编译器生成的字节码在运行期间并不包含泛型的类型信息。\n"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "a",
					"TextMarkAHref": "https://zhuanlan.zhihu.com/p/51452375",
					"TextMarkTextContent": "推荐一篇擦除机制的文章"
				}
			]
		},
		{
			"ID": "20230423123555-shln8rd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-shln8rd",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "提出问题：\n1、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "那为什么，"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "T[] ts = new T[5]; "
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "是不对的，编译的时候，替换为Object，不是相当于："
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong code",
					"TextMarkTextContent": "Object[] ts = new Object[5]"
				},
				{
					"Type": "NodeText",
					"Data": "​"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "吗？"
				}
			]
		},
		{
			"ID": "20230423123555-3yhvwji",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123555-3yhvwji",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123555-otqrvig",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-otqrvig",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "这个问题涉及到Java泛型的擦除机制。在Java中，泛型是在编译期间实现的，编译器会将泛型类型擦除，替换为Object类型。所以，在运行时，"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "T[] ts = new T[5]"
						},
						{
							"Type": "NodeText",
							"Data": "​会被替换为"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "Object[] ts = new Object[5]"
						},
						{
							"Type": "NodeText",
							"Data": "​。但是，这样做会导致一个问题：如果T是一个具体的类型，那么"
						},
						{
							"Type": "NodeTextMark",
							"TextMarkType": "code",
							"TextMarkTextContent": "Object[] ts = new Object[5]"
						},
						{
							"Type": "NodeText",
							"Data": "​就不能存储T类型的元素了。因此，在Java中，我们不能直接创建泛型数组。"
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-7o4yrtb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-7o4yrtb",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "类型擦除，一定是把T变成Object吗？"
				}
			]
		},
		{
			"ID": "20230423123555-i0ykhwd",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123555-i0ykhwd",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123555-3v9m91p",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-3v9m91p",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "Java 中的类型擦除是指在泛型代码编译期间将泛型类型 T 替换为其边界类型或 Object 类型的过程，因此并不一定是将 T 替换为 Object。"
						}
					]
				},
				{
					"ID": "20230423123555-v2paup8",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-v2paup8",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "具体来说，对于泛型类或泛型方法，编译器会将其中的类型参数 T 擦除为其边界类型或 Object 类型。如果 T 没有指定边界，那么编译器将 T 擦除为 Object 类型。"
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-4y12zrg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-4y12zrg",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "例如，对于以下泛型类的定义："
				}
			]
		},
		{
			"ID": "20230423123555-y5tgc9m",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-y5tgc9m",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class MyList\u003cT\u003e {   \n\tprivate T[] array;   \n\t// ... \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-f2d0kp5",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123555-f2d0kp5",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123555-8y32tsn",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-8y32tsn",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在编译时，T 将被擦除为 Object 类型，因为 T 没有指定边界。"
						}
					]
				},
				{
					"ID": "20230423123555-ktxbmts",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-ktxbmts",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "但是，如果我们指定了 T 的边界类型，例如："
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-s01mi2a",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-s01mi2a",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class MyList\u003cT extends Number\u003e {\n    private T[] array;\n    // ...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-38aogwr",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20230423123555-38aogwr",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20230423123555-2ha312s",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20230423123555-2ha312s",
						"updated": "20230423123555"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在编译时，T 将被擦除为 Number 类型，而不是 Object 类型。\n总之，Java 中的类型擦除将泛型类型替换为边界类型或 Object 类型，具体替换成什么类型取决于泛型类型的定义。"
						}
					]
				}
			]
		},
		{
			"ID": "20230423123555-cycz2q5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-cycz2q5",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为什么不能实例化泛型类型数组"
				}
			]
		},
		{
			"ID": "20230423123555-royl9wt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-royl9wt",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyArray\u003cT\u003e {  \n    public T[] array = (T[])new Object[10];  \n  \n    public T getPos(int pos) {  \n        return this.array[pos];  \n    }  \n    public void setVal(int pos,T val) {  \n        this.array[pos] = val;  将`Object[]`分配给`Integer[]`引用，程序报错。\n    }  \n    public T[] getArray() {  \n        return array;  \n    }  \n}\n\npublic static void main(String[] args) {  \n\tMyArray\u003cInteger\u003e myArray1 = new MyArray\u003c\u003e();  \n\tInteger[] strings = myArray1.getArray();  \n}\n\n/*\nException in thread \"main\" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer; at TestDemo.main(TestDemo.java:31)\n*/\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-yq7cjfi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-yq7cjfi",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原因：替换后的方法为："
				}
			]
		},
		{
			"ID": "20230423123555-2uxep9k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-2uxep9k",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public Object[] getArray() {\n\treturn array;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-qfvu2c4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-qfvu2c4",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "将"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Object[]"
				},
				{
					"Type": "NodeText",
					"Data": "​分配给"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Integer[]"
				},
				{
					"Type": "NodeText",
					"Data": "​引用，程序报错。\n通俗讲就是：返回的Object数组里面，可能存放的是任何的数据类型，可能是String，可能是Person，运行的时候，直接转给Integer类型的数组，编译器认为是不安全的。"
				}
			]
		},
		{
			"ID": "20230423123555-pafbvcs",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20230423123555-pafbvcs",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运用反射的方式 (了解即可)"
				}
			]
		},
		{
			"ID": "20230423123555-pr60hv9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-pr60hv9",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyArray\u003cT\u003e {  \n    public T[] array;  \n    public MyArray() {  \n    }  \n    /**  \n     * 通过反射创建，指定类型的数组  \n     * @param clazz  \n     * @param capacity  \n     */  \n    public MyArray(Class\u003cT\u003e clazz, int capacity) {  \n        array = (T[]) Array.newInstance(clazz, capacity);  \n    }  \n    public T getPos(int pos) {  \n        return this.array[pos];  \n    }  \n    public void setVal(int pos,T val) {  \n        this.array[pos] = val;  \n    }  \n    public T[] getArray() {  \n        return array;  \n    }  \n}  \npublic class test {  \n    public static void main(String[] args) {  \n        MyArray\u003cInteger\u003e myArray1 = new MyArray\u003c\u003e();  \n        Integer[] strings = myArray1.getArray();  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-lbygnqq",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-lbygnqq",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型的上界"
				}
			]
		},
		{
			"ID": "20230423123555-zqs17p3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-zqs17p3",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在定义泛型类时，有时需要对传入的类型变量做一定的约束，可以通过类型边界来约束。"
				}
			]
		},
		{
			"ID": "20230423123555-btwjrdv",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-btwjrdv",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "语法"
				}
			]
		},
		{
			"ID": "20230423123555-zauykif",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-zauykif",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class 类名称\u003c类型形参 extends 类型边界\u003e {\n\t...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-9nt91ci",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-9nt91ci",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class MyArray\u003cE extends Number\u003e {\n\t...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-h2iplwn",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-h2iplwn",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "这个类就只接受 Number 的子类型作为 E 的类型实参"
				}
			]
		},
		{
			"ID": "20230423123555-x93acp7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-x93acp7",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "MyArray\u003cInteger\u003e l1; // 正常，因为 Integer 是 Number 的子类型\nMyArray\u003cString\u003e l2; // 编译错误，因为 String 不是 Number 的子类型\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-wyu205d",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-wyu205d",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "error: type argument String is not within bounds of type-variable E\n\tMyArrayList\u003cString\u003e l2;\n\t\t^\nwhere E is a type-variable:\nE extends Number declared in class MyArrayList\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-dukaxeu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-dukaxeu",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "了解"
				},
				{
					"Type": "NodeText",
					"Data": "： 没有指定类型边界 E，可以视为 E extends Object"
				}
			]
		},
		{
			"ID": "20230423123555-znq4oxd",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-znq4oxd",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "复杂示例"
				}
			]
		},
		{
			"ID": "20230423123555-uk19sd8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-uk19sd8",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class MyArray\u003cE extends Comparable\u003cE\u003e\u003e {\n\t...\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-9pmgryq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-9pmgryq",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "E必须是实现了Comparable接口的"
				}
			]
		},
		{
			"ID": "20230423123555-ue2098d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-ue2098d",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "看以下案例："
				}
			]
		},
		{
			"ID": "20230423123555-86q7p0w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-86q7p0w",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Alg\u003cE\u003e {  \n    public E findMax(E[] array) {  \n        E max = array[0];  \n        for(int i = 1; i \u003c array.length;i++) {  \n            if(max \u003c array[i]) {   //这里会报错\n                max = array[i];  \n            }  \n        }  \n        return max;  \n    }  \n}  \n  \npublic class test {  \n    public static void main(String[] args) {  \n        MyArray\u003cInteger\u003e myArray1 = new MyArray\u003c\u003e();  \n        int i = myArray1.getPos(1);  \n        System.out.println(i);  \n    }  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-c4dfm3g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-c4dfm3g",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这段代码会报错，因为 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "max \u0026lt; array[i]"
				},
				{
					"Type": "NodeText",
					"Data": "​ 中的 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "\u0026lt;"
				},
				{
					"Type": "NodeText",
					"Data": "​ 操作符并不能用于任意类型 E。在 Java 中， "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "\u0026lt;"
				},
				{
					"Type": "NodeText",
					"Data": "​ 操作符只能用于基本数据类型（如 int、float 等）和实现了 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Comparable"
				},
				{
					"Type": "NodeText",
					"Data": "​ 接口的对象。但是在这段代码中，类型参数 E 并没有被限定为实现 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "Comparable"
				},
				{
					"Type": "NodeText",
					"Data": "​ 接口，因此编译器无法确定是否可以使用 "
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "\u0026lt;"
				},
				{
					"Type": "NodeText",
					"Data": "​ 操作符。"
				}
			]
		},
		{
			"ID": "20230423123555-vsy49i5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20230423123555-vsy49i5",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "更改如下："
				}
			]
		},
		{
			"ID": "20230423123555-jztktzh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-jztktzh",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "class Alg\u003cE extends Comparable\u003cE\u003e\u003e {\n    public E findMax(E[] array) {\n        E max = array[0];\n        for (int i = 1; i \u003c array.length; i++) {\n            if (max.compareTo(array[i]) \u003c 0) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-dy2c6oo",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20230423123555-dy2c6oo",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "泛型方法"
				}
			]
		},
		{
			"ID": "20230423123555-saub5hv",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-saub5hv",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "定义语法"
				}
			]
		},
		{
			"ID": "20230423123555-uojyuk8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-uojyuk8",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "方法限定符 \u003c类型形参列表\u003e 返回值类型 方法名称(形参列表) { ... }\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-1gzcjqx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-1gzcjqx",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Util {\n\t//静态的泛型方法 需要在static后用\u003c\u003e声明泛型类型参数\n\tpublic static \u003cE\u003e void swap(E[] array, int i, int j) {\n\t\tE t = array[i];\n\t\tarray[i] = array[j];\n\t\tarray[j] = t;\n\t}\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-vtpk54y",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-vtpk54y",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例-可以类型推导"
				}
			]
		},
		{
			"ID": "20230423123555-1cfcujx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-1cfcujx",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Integer[] a = { ... };\nswap(a, 0, 9);\n\nString[] b = { ... };\nswap(b, 0, 9);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20230423123555-ixk704f",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20230423123555-ixk704f",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用示例-不使用类型推导"
				}
			]
		},
		{
			"ID": "20230423123555-dn7qys0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20230423123555-dn7qys0",
				"updated": "20230423123555"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Integer[] a = { ... };\nUtil.\u003cInteger\u003eswap(a, 0, 9);\n\nString[] b = { ... };\nUtil.\u003cString\u003eswap(b, 0, 9);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}