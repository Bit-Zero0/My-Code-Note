{
	"ID": "20221013224045-bzs9pkf",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20221013224045-bzs9pkf",
		"title": "C++线程库",
		"updated": "20221213141553"
	},
	"Children": [
		{
			"ID": "20221013224051-zxo6qa8",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221013224051-zxo6qa8",
				"updated": "20221013224051"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "thread类的简单介绍"
				}
			]
		},
		{
			"ID": "20221013224051-a2nmd9b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221013224051-a2nmd9b",
				"updated": "20221013224051"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在C++11之前，涉及到多线程问题，都是和平台相关的，比如windows和linux下各有自己的接口，这使得代码的可移植性比较差。C++11中最重要的特性就是对线程进行支持了，使得C++在 并行编程时不需要依赖第三方库，而且在原子操作中还引入了原子类的概念。要使用标准库中的\n线程，必须包含"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "\u003cthread\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "头文件。\n"
				},
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "C++11中线程类"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "http://www.cplusplus.com/reference/thread/thread/?kw=thread"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20221013224056-tj3btwi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221013224056-tj3btwi"
			}
		},
		{
			"ID": "20221013224051-d1hepx3",
			"Type": "NodeTable",
			"TableAligns": [
				2,
				1
			],
			"Properties": {
				"colgroup": "|",
				"id": "20221013224051-d1hepx3",
				"updated": "20221013224101"
			},
			"Children": [
				{
					"Type": "NodeTableHead",
					"Data": "thead",
					"Children": [
						{
							"Type": "NodeTableRow",
							"Data": "tr",
							"Children": [
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"TableCellAlign": 2,
									"Children": [
										{
											"Type": "NodeText",
											"Data": "函数名"
										}
									]
								},
								{
									"Type": "NodeTableCell",
									"Data": "th",
									"TableCellAlign": 1,
									"Children": [
										{
											"Type": "NodeText",
											"Data": "功能"
										}
									]
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "thread()"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "构造一个线程对象，没有关联任何线程函数，即没有启动任何线程"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "thread(fn,args1, args2,...)"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "构造一个线程对象，并关联线程函数fn,args1,args2，...为线程函数的参数"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "get_id()"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "获取线程id"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "joinable()"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "线程是否还在执行，joinable代表的是一个正在执行中的线程。"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "join()"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "该函数调用后会阻塞住线程，当该线程结束后，主线程继续执行"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "detach()"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在创建线程对象后马上调用，用于把被创建线程与线程对象分离开，分离的线程变为后台线程，创建的线程的\"死活\"就与主线程无关"
								}
							]
						}
					]
				},
				{
					"Type": "NodeTableRow",
					"Data": "tr",
					"Children": [
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 2,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "用法和[[多线程"
								}
							]
						},
						{
							"Type": "NodeTableCell",
							"Data": "td",
							"TableCellAlign": 1,
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Linux的多线程]]差不多。不过linux中的更多是面向过程的，C++中则是面向对象。"
								},
								{
									"Type": "NodeBr",
									"Data": "br"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221013224153-xryl4rr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221013224153-xryl4rr"
			}
		},
		{
			"ID": "20221017225147-jxkvdvt",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221017225147-jxkvdvt",
				"updated": "20221017225147"
			},
			"Children": [
				{
					"ID": "20221017225147-2w5wu0j",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221017225147-2w5wu0j",
						"updated": "20221017225147"
					},
					"Children": [
						{
							"ID": "20221017225147-75qg059",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225147-75qg059",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "线程是操作系统中的一个概念，线程对象可以关联一个线程，用来控制线程以及获取线程的状态。"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225147-dq70uel",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221017225147-dq70uel",
						"updated": "20221017225147"
					},
					"Children": [
						{
							"ID": "20221017225147-ar62wm1",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225147-ar62wm1",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "当创建一个线程对象后，没有提供线程函数，该对象实际没有对应任何线程。"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20221017225147-m20eov5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221017225147-m20eov5",
						"updated": "20221017225147"
					},
					"Children": [
						{
							"ID": "20221017225147-r5z9z7b",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225147-r5z9z7b",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "创建一个线程对象后"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，并且给"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "线程关联线程函数"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，该线程就被启动，与主线程一起运行。线程函数一般情况下可按照以下三种方式提供："
								}
							]
						},
						{
							"ID": "20221017225147-i3ftdo0",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20221017225147-i3ftdo0",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"ID": "20221017225147-8pjsxnu",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-8pjsxnu",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-82iqgc6",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-82iqgc6",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "函数指针"
												}
											]
										}
									]
								},
								{
									"ID": "20221017225147-knm6gjg",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-knm6gjg",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-s1vyhki",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-s1vyhki",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "lambda表达式"
												}
											]
										}
									]
								},
								{
									"ID": "20221017225147-acscyll",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-acscyll",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-4hyxv28",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-4hyxv28",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "函数对象"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20221017225147-bf258u0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221017225147-bf258u0",
						"updated": "20221017225147"
					},
					"Children": [
						{
							"ID": "20221017225147-1ty4k4l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225147-1ty4k4l",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"Type": "NodeMark",
									"Data": "mark",
									"Children": [
										{
											"Type": "NodeMark2OpenMarker"
										},
										{
											"Type": "NodeText",
											"Data": "thread类是"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "防拷贝"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "的"
										},
										{
											"Type": "NodeMark2CloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "不允许拷贝构造以及赋值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，但是"
								},
								{
									"Type": "NodeStrong",
									"Data": "strong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "可以移动构造和移动赋值"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，即将一个线程对象关联线程的状态转移给其他线程对象，转移期间不意向线程的执行。"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225147-npz5wr0",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NS4=",
						"Num": 5
					},
					"Properties": {
						"id": "20221017225147-npz5wr0",
						"updated": "20221017225147"
					},
					"Children": [
						{
							"ID": "20221017225147-eeb0249",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225147-eeb0249",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "可以通过joinable()函数判断线程是否是有效的，如果是以下任意情况，则线程无效"
								}
							]
						},
						{
							"ID": "20221017225147-xwaynit",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20221017225147-xwaynit",
								"updated": "20221017225147"
							},
							"Children": [
								{
									"ID": "20221017225147-jq4y789",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-jq4y789",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-f2jqwyr",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-f2jqwyr",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "采用无参构造函数构造的线程对象"
												}
											]
										}
									]
								},
								{
									"ID": "20221017225147-03nrvbb",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-03nrvbb",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-cpklwe8",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-cpklwe8",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "线程对象的状态已经转移给其他线程对象"
												}
											]
										}
									]
								},
								{
									"ID": "20221017225147-3bhpbrv",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225147-3bhpbrv",
										"updated": "20221017225147"
									},
									"Children": [
										{
											"ID": "20221017225147-fwheuil",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225147-fwheuil",
												"updated": "20221017225147"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "线程已经调用join或者detach结束"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225146-wuiap4c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225146-wuiap4c"
			}
		},
		{
			"ID": "20221013224145-yvzke6r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221013224145-yvzke6r",
				"updated": "20221013224222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用法和"
				},
				{
					"Type": "NodeBlockRef",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeBlockRefID",
							"Data": "20220913223533-jqys64s"
						},
						{
							"Type": "NodeBlockRefSpace"
						},
						{
							"Type": "NodeBlockRefText",
							"Data": "Linux多线程"
						},
						{
							"Type": "NodeCloseParen"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "差不多。不过Linux中的更多是面向过程的，C++中则是面向对象。"
				}
			]
		},
		{
			"ID": "20221013224051-lbjrrlj",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221013224051-lbjrrlj",
				"updated": "20221013224051"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cthread\u003e\n#include \u003cvector\u003e\nvoid Print(int x)\n{\n\tfor (int i = 0; i \u003c x; ++i) {\n\t\tcout \u003c\u003c i \u003c\u003c endl;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin \u003e\u003e n;\n\tvector\u003cthread\u003evthds;\n\tvthds.resize(n);\n\n\tfor (auto\u0026 t : vthds)\n\t{\n\t\tt = thread(Print, 100);\n\t}\n\n\tfor (auto\u0026 t : vthds)\n\t{\n\t\tt.join();\n\t}\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225221-d5k6r7m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225221-d5k6r7m"
			}
		},
		{
			"ID": "20221017225222-jr6ridt",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-jr6ridt",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线程函数参数"
				}
			]
		},
		{
			"ID": "20221017225222-0scxqvl",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-0scxqvl",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线程函数的参数是以"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "值拷贝"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的方式拷贝到线程栈空间中的，因此："
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为其实际引用的是线程栈中的拷贝，而不是外部实参"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221017225240-1kw19yd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225240-1kw19yd"
			}
		},
		{
			"ID": "20221017225222-xbk79jt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-xbk79jt",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果想要通过形参改变外部实参时，必须借助"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "std::ref()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "函数"
				}
			]
		},
		{
			"ID": "20221017225222-m9g9qdk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-m9g9qdk",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cthread\u003e\nvoid ThreadFunc1(int\u0026 x)//引用 是不起作用的\n{\n\tx += 10;\n}\n\nvoid ThreadFunc2(int* x)\n{\n\t*x += 10;\n}\n\nint main()\n{\n\tint a = 10;\n\n\t// 在线程函数中对a修改，不会影响外部实参，因为：线程函数参数虽然是引用方式，但其实际引用的是线程栈中的拷贝\n\tthread t1(ThreadFunc1, a);\n\tt1.join();\n\tcout \u003c\u003c a \u003c\u003c endl;\n\n\t// 如果想要通过形参改变外部实参时，必须借助std::ref()函数\n\tthread t2(ThreadFunc1, std::ref(a); \n\tt2.join();\n\tcout \u003c\u003c a \u003c\u003c endl;\n\n\tthread t3(ThreadFunc2, \u0026a);// 地址的拷贝\n\tt3.join();\n\tcout \u003c\u003c a \u003c\u003c endl;\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-ssea180",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-ssea180",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果是类成员函数作为线程参数时，必须将this作为线程函数参数。"
				}
			]
		},
		{
			"ID": "20221017225254-pn5y3d7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225254-pn5y3d7"
			}
		},
		{
			"ID": "20221017225222-ngi0drd",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-ngi0drd",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "mutex"
				}
			]
		},
		{
			"ID": "20221017225222-ogahsw3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-ogahsw3",
				"updated": "20221017225353"
			},
			"Children": [
				{
					"Type": "NodeBlockRef",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeBlockRefID",
							"Data": "20220913223533-jqys64s"
						},
						{
							"Type": "NodeBlockRefSpace"
						},
						{
							"Type": "NodeBlockRefDynamicText",
							"Data": "Linux多线程"
						},
						{
							"Type": "NodeCloseParen"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n在多线程环境下，如果想要保证某个变量的安全性，只要将其设置成对应的"
				},
				{
					"Type": "NodeBlockRef",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeBlockRefID",
							"Data": "20221017225222-wb190fz"
						},
						{
							"Type": "NodeBlockRefSpace"
						},
						{
							"Type": "NodeBlockRefText",
							"Data": "原子类型"
						},
						{
							"Type": "NodeCloseParen"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "即可，即高效又不容易出现死锁问题。但是有些情况下，我们可能需要保证一段代码的安全性，那么就只能通过锁的方式来进行控制。"
				}
			]
		},
		{
			"ID": "20221017225324-3sxtd1v",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225324-3sxtd1v"
			}
		},
		{
			"ID": "20221017225222-4eqnbbo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-4eqnbbo",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如：一个线程对变量number进行加一100次，另外一个减一100次，每次操作加一或者减一之后，输出number的结果，要求：number最后的值为1。"
				}
			]
		},
		{
			"ID": "20221017225222-p6nd9uq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-p6nd9uq",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cthread\u003e\n#include \u003cmutex\u003e\nint number = 0;\nmutex g_lock;\nint ThreadProc1()\n{\n\tfor (int i = 0; i \u003c 100; i++)\n\t{\n\t\tg_lock.lock();\n\t\t++number;\n\t\tcout \u003c\u003c \"thread 1 :\" \u003c\u003c number \u003c\u003c endl;\n\t\tg_lock.unlock();\n\t}\n\treturn 0;\n}\n\nint ThreadProc2()\n{\n\tfor (int i = 0; i \u003c 100; i++)\n\t{\n\t\tg_lock.lock();\n\t\t--number;\n\t\tcout \u003c\u003c \"thread 2 :\" \u003c\u003c number \u003c\u003c endl;\n\t\tg_lock.unlock();\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tthread t1(ThreadProc1);\n\tthread t2(ThreadProc2);\n\tt1.join();\n\tt2.join();\n\tcout \u003c\u003c \"number:\" \u003c\u003c number \u003c\u003c endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-gzb54p3",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221017225222-gzb54p3",
				"updated": "20221017225406"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": " mutex的种类"
				}
			]
		},
		{
			"ID": "20221017225222-hv9mkax",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-hv9mkax",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在C++11中，Mutex总共包了四个互斥量的种类："
				}
			]
		},
		{
			"ID": "20221017225452-dbayvai",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225452-dbayvai"
			}
		},
		{
			"ID": "20221017225222-d3vbr2e",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221017225222-d3vbr2e",
				"updated": "20221017225605"
			},
			"Children": [
				{
					"ID": "20221017225222-7vd929a",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20221017225222-7vd929a",
						"updated": "20221017225605"
					},
					"Children": [
						{
							"ID": "20221017225222-i6yax5h",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-i6yax5h",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "std::mutex"
								},
								{
									"Type": "NodeBr",
									"Data": "br"
								},
								{
									"Type": "NodeText",
									"Data": "C++11提供的最基本的互斥量，该类的对象之间不能拷贝，也不能进行移动。mutex最常用"
								},
								{
									"Type": "NodeBr",
									"Data": "br"
								},
								{
									"Type": "NodeText",
									"Data": "的三个函数："
								}
							]
						},
						{
							"ID": "20221017225605-r18jw7v",
							"Type": "NodeTable",
							"TableAligns": [
								2,
								1
							],
							"Properties": {
								"colgroup": "|",
								"id": "20221017225605-r18jw7v",
								"updated": "20221017225605"
							},
							"Children": [
								{
									"Type": "NodeTableHead",
									"Data": "thead",
									"Children": [
										{
											"Type": "NodeTableRow",
											"Data": "tr",
											"Children": [
												{
													"Type": "NodeTableCell",
													"Data": "th",
													"TableCellAlign": 2,
													"Children": [
														{
															"Type": "NodeMark",
															"Data": "mark",
															"Children": [
																{
																	"Type": "NodeMark2OpenMarker"
																},
																{
																	"Type": "NodeStrong",
																	"Data": "strong",
																	"Children": [
																		{
																			"Type": "NodeStrongA6kOpenMarker",
																			"Data": "**"
																		},
																		{
																			"Type": "NodeText",
																			"Data": "函数名"
																		},
																		{
																			"Type": "NodeStrongA6kCloseMarker",
																			"Data": "**"
																		}
																	]
																},
																{
																	"Type": "NodeMark2CloseMarker"
																}
															]
														}
													]
												},
												{
													"Type": "NodeTableCell",
													"Data": "th",
													"TableCellAlign": 1,
													"Children": [
														{
															"Type": "NodeMark",
															"Data": "mark",
															"Children": [
																{
																	"Type": "NodeMark2OpenMarker"
																},
																{
																	"Type": "NodeStrong",
																	"Data": "strong",
																	"Children": [
																		{
																			"Type": "NodeStrongA6kOpenMarker",
																			"Data": "**"
																		},
																		{
																			"Type": "NodeText",
																			"Data": "函数功能"
																		},
																		{
																			"Type": "NodeStrongA6kCloseMarker",
																			"Data": "**"
																		}
																	]
																},
																{
																	"Type": "NodeMark2CloseMarker"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"Type": "NodeTableRow",
									"Data": "tr",
									"Children": [
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 2,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "lock()"
												}
											]
										},
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 1,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "上锁：锁住互斥量"
												}
											]
										}
									]
								},
								{
									"Type": "NodeTableRow",
									"Data": "tr",
									"Children": [
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 2,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "unlock()"
												}
											]
										},
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 1,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "解锁：释放对互斥量的所有权"
												}
											]
										}
									]
								},
								{
									"Type": "NodeTableRow",
									"Data": "tr",
									"Children": [
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 2,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "try_lock()"
												}
											]
										},
										{
											"Type": "NodeTableCell",
											"Data": "td",
											"TableCellAlign": 1,
											"Children": [
												{
													"Type": "NodeText",
													"Data": "尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞"
												}
											]
										}
									]
								}
							]
						},
						{
							"ID": "20221017225605-mtmyvpc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225605-mtmyvpc",
								"updated": "20221017225605"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "注意，线程函数调用lock()时，可能会发生以下三种情况："
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-6bnaavi",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221017225222-6bnaavi",
				"updated": "20221017225623"
			},
			"Children": [
				{
					"ID": "20221017225222-q0rbfqq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-q0rbfqq",
						"updated": "20221017225623"
					},
					"Children": [
						{
							"ID": "20221017225222-y1leyqh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-y1leyqh",
								"updated": "20221017225623"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "unlock"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "之前，该线程一直拥有该锁"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-9o2crpo",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-9o2crpo",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-30mtmrh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-30mtmrh",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-7c5pxqx",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-7c5pxqx",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-xzm77dl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-xzm77dl",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-sv5m9l2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-sv5m9l2",
				"updated": "20221017225620"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线程函数调用"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "try_lock()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "时，可能会发生以下三种情况："
				}
			]
		},
		{
			"ID": "20221017225222-yxled7i",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221017225222-yxled7i",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"ID": "20221017225222-t69whrz",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-t69whrz",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-ttpq6td",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-ttpq6td",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock释放互斥量"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-n8jweum",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-n8jweum",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-kl6zfmv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-kl6zfmv",
								"updated": "20221017225628"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前互斥量被其他线程锁住，则当前调用线程返回 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "false"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，而并不会被阻塞掉"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-1ttoriq",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-1ttoriq",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-6z79yoa",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-6z79yoa",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225636-xdi9ggr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225636-xdi9ggr",
				"updated": "20221017225636"
			}
		},
		{
			"ID": "20221017225222-d5jftjx",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221017225222-d5jftjx",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"ID": "20221017225222-tp050dw",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20221017225222-tp050dw",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-922xcjm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-922xcjm",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "std::recursive_mutex"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "\n其允许同一个线程对互斥量多次上锁（即"
								},
								{
									"Type": "NodeMark",
									"Data": "mark",
									"Children": [
										{
											"Type": "NodeMark2OpenMarker"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "递归上锁"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeMark2CloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "），来获得对互斥量对象的多层所有权，释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，除此之外，"
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "std::recursive_mutex"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 的特性和 "
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "std::mutex"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " 大致相同。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225639-xrw5bnf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225639-xrw5bnf",
				"updated": "20221017225640"
			}
		},
		{
			"ID": "20221017225222-nzanqtz",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221017225222-nzanqtz",
				"updated": "20221017225657"
			},
			"Children": [
				{
					"ID": "20221017225646-7dvun31",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20221017225646-7dvun31",
						"updated": "20221017225657"
					},
					"Children": [
						{
							"ID": "20221017225646-kax3dy2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225646-kax3dy2",
								"updated": "20221017225653"
							},
							"Children": [
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "std::timed_mutex"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								}
							]
						},
						{
							"ID": "20221017225655-2g975fr",
							"Type": "NodeList",
							"ListData": {},
							"Properties": {
								"id": "20221017225655-2g975fr",
								"updated": "20221017225657"
							},
							"Children": [
								{
									"ID": "20221017225657-q7188xg",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225657-q7188xg",
										"updated": "20221017225657"
									},
									"Children": [
										{
											"ID": "20221017225657-8t4l5dr",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225657-8t4l5dr",
												"updated": "20221017225657"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "比"
												},
												{
													"Type": "NodeCodeSpan",
													"Data": "code",
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "std::mutex"
														},
														{
															"Type": "NodeCodeSpanCloseMarker"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "多了两个成员函数，"
												},
												{
													"Type": "NodeCodeSpan",
													"Data": "code",
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "try_lock_for()"
														},
														{
															"Type": "NodeCodeSpanCloseMarker"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "，"
												},
												{
													"Type": "NodeCodeSpan",
													"Data": "code",
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "try_lock_until()"
														},
														{
															"Type": "NodeCodeSpanCloseMarker"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": " 。"
												}
											]
										}
									]
								},
								{
									"ID": "20221017225704-3wigh5r",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225704-3wigh5r"
									},
									"Children": [
										{
											"ID": "20221017225704-eqhpjtf",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225704-eqhpjtf"
											},
											"Children": [
												{
													"Type": "NodeCodeSpan",
													"Data": "code",
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "try_lock_for()"
														},
														{
															"Type": "NodeCodeSpanCloseMarker"
														}
													]
												}
											]
										},
										{
											"ID": "20221017225708-ci4wwe9",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20221017225708-ci4wwe9"
											},
											"Children": [
												{
													"ID": "20221017225707-001judx",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20221017225707-001judx"
													},
													"Children": [
														{
															"ID": "20221017225707-xwvp523",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20221017225707-xwvp523"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与"
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": "std::mutex "
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": "的 "
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": "try_lock()"
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": " 不同，"
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": "try_lock"
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": "如果被调用时没有获得锁则直接返回"
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": "false"
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": "），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回"
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": " false"
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": "。"
																}
															]
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20221017225742-jnfgupp",
									"Type": "NodeListItem",
									"ListData": {
										"BulletChar": 42,
										"Marker": "Kg=="
									},
									"Properties": {
										"id": "20221017225742-jnfgupp"
									},
									"Children": [
										{
											"ID": "20221017225742-e4yv00l",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20221017225742-e4yv00l"
											},
											"Children": [
												{
													"Type": "NodeCodeSpan",
													"Data": "code",
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "try_lock_until()"
														},
														{
															"Type": "NodeCodeSpanCloseMarker"
														}
													]
												}
											]
										},
										{
											"ID": "20221017225800-lln7nxa",
											"Type": "NodeList",
											"ListData": {},
											"Properties": {
												"id": "20221017225800-lln7nxa"
											},
											"Children": [
												{
													"ID": "20221017225759-wqzpmcf",
													"Type": "NodeListItem",
													"ListData": {
														"BulletChar": 42,
														"Marker": "Kg=="
													},
													"Properties": {
														"id": "20221017225759-wqzpmcf"
													},
													"Children": [
														{
															"ID": "20221017225759-9qc77fk",
															"Type": "NodeParagraph",
															"Properties": {
																"id": "20221017225759-9qc77fk"
															},
															"Children": [
																{
																	"Type": "NodeText",
																	"Data": "接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 "
																},
																{
																	"Type": "NodeCodeSpan",
																	"Data": "code",
																	"Children": [
																		{
																			"Type": "NodeCodeSpanOpenMarker"
																		},
																		{
																			"Type": "NodeCodeSpanContent",
																			"Data": "false"
																		},
																		{
																			"Type": "NodeCodeSpanCloseMarker"
																		}
																	]
																},
																{
																	"Type": "NodeText",
																	"Data": "。"
																}
															]
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225821-k1xk5bu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225821-k1xk5bu",
				"updated": "20221017225822"
			}
		},
		{
			"ID": "20221017225817-bnitatv",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20221017225817-bnitatv",
				"updated": "20221017225824"
			},
			"Children": [
				{
					"ID": "20221017225824-zyy19b5",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20221017225824-zyy19b5",
						"updated": "20221017225824"
					},
					"Children": [
						{
							"ID": "20221017225824-w542m74",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225824-w542m74",
								"updated": "20221017225824"
							},
							"Children": [
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "std::recursive_timed_mutex"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-kom5o4y",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221017225222-kom5o4y",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "锁加在何处？"
				}
			]
		},
		{
			"ID": "20221017225222-2sngewj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-2sngewj",
				"updated": "20221017225830"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "但我们遇到需要加锁的环境，且这个环境中有循环，我们应该怎么加锁？为什么？"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-guyomes",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221017225222-guyomes",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221017225222-clk0bbk",
					"Type": "NodeList",
					"ListData": {},
					"Properties": {
						"id": "20221017225222-clk0bbk",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-te7wxv3",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20221017225222-te7wxv3",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"ID": "20221017225222-746oaax",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221017225222-746oaax",
										"updated": "20221017225222"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "锁加在何处其实是需要根据代码量来进行调整的，如果临界区只有一两条语句，锁应该加在循环外(串行)，若语句比较多，则加在循环内(并行)。"
										}
									]
								}
							]
						},
						{
							"ID": "20221017225222-wjgo07s",
							"Type": "NodeListItem",
							"ListData": {
								"BulletChar": 42,
								"Marker": "Kg=="
							},
							"Properties": {
								"id": "20221017225222-wjgo07s",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"ID": "20221017225222-bgbscej",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20221017225222-bgbscej",
										"updated": "20221017225222"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "原因如下"
										}
									]
								},
								{
									"ID": "20221017225222-1z827tr",
									"Type": "NodeList",
									"ListData": {},
									"Properties": {
										"id": "20221017225222-1z827tr",
										"updated": "20221017225222"
									},
									"Children": [
										{
											"ID": "20221017225222-9tjxwao",
											"Type": "NodeListItem",
											"ListData": {
												"BulletChar": 42,
												"Marker": "Kg=="
											},
											"Properties": {
												"id": "20221017225222-9tjxwao",
												"updated": "20221017225222"
											},
											"Children": [
												{
													"ID": "20221017225222-2nzc4p6",
													"Type": "NodeParagraph",
													"Properties": {
														"id": "20221017225222-2nzc4p6",
														"updated": "20221017225222"
													},
													"Children": [
														{
															"Type": "NodeMark",
															"Data": "mark",
															"Children": [
																{
																	"Type": "NodeMark2OpenMarker"
																},
																{
																	"Type": "NodeStrong",
																	"Data": "strong",
																	"Children": [
																		{
																			"Type": "NodeStrongA6kOpenMarker",
																			"Data": "**"
																		},
																		{
																			"Type": "NodeText",
																			"Data": "并行"
																		},
																		{
																			"Type": "NodeStrongA6kCloseMarker",
																			"Data": "**"
																		}
																	]
																},
																{
																	"Type": "NodeMark2CloseMarker"
																}
															]
														},
														{
															"Type": "NodeText",
															"Data": "：如果临界区只有一两条语句，cpu的处理速度是十分快速的，如果我们的锁加在循环内，多个线程需要频繁的切换线程的上下文，而保存线程的上下文是需要时间的，切换时，线程不一定准备好了，需要等线程准备完毕，所以时间的比较耗时的，如果临界区的资源多，就不会出现此问题，就可以将锁加在循环内。"
														}
													]
												}
											]
										},
										{
											"ID": "20221017225222-59av3qn",
											"Type": "NodeListItem",
											"ListData": {
												"BulletChar": 42,
												"Marker": "Kg=="
											},
											"Properties": {
												"id": "20221017225222-59av3qn",
												"updated": "20221017225222"
											},
											"Children": [
												{
													"ID": "20221017225222-9g2mwyl",
													"Type": "NodeParagraph",
													"Properties": {
														"id": "20221017225222-9g2mwyl",
														"updated": "20221017225222"
													},
													"Children": [
														{
															"Type": "NodeMark",
															"Data": "mark",
															"Children": [
																{
																	"Type": "NodeMark2OpenMarker"
																},
																{
																	"Type": "NodeStrong",
																	"Data": "strong",
																	"Children": [
																		{
																			"Type": "NodeStrongA6kOpenMarker",
																			"Data": "**"
																		},
																		{
																			"Type": "NodeText",
																			"Data": "串行"
																		},
																		{
																			"Type": "NodeStrongA6kCloseMarker",
																			"Data": "**"
																		}
																	]
																},
																{
																	"Type": "NodeMark2CloseMarker"
																}
															]
														},
														{
															"Type": "NodeText",
															"Data": "：如果临界区的只有一两条语句，将锁加在循环外，就避免了多线程之间的频繁切换上下文，当我们准确切换线程时，另一线程也已准备就绪，所以效率在此环境下比并行高。"
														}
													]
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-h5et380",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20221017225222-h5et380",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "锁在循环内部"
				}
			]
		},
		{
			"ID": "20221017225222-h5pp4yh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-h5pp4yh",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cmutex\u003e  \n#include \u003cthread\u003e  \nint x = 0;  \nmutex mtx;  \nvoid Func(int n)  \n{  \n   // 加锁，加再循环里面还是循环外面？为什么？  \n   // 2  \n   for (int i = 0; i \u003c n; ++i)  \n   {  \n\t   mtx.lock();  \n   \n      //cout \u003c\u003c std::this_thread::get_id() \u003c\u003c\"-\u003e\"\u003c\u003c x \u003c\u003c endl;    \n      ++x;  \n    \n\t   mtx.unlock();  \n   }  \n}  \nint main()  \n{  \n   thread t1(Func, 5000000);  \n   thread t2(Func, 5000000);  \n  \n   t1.join();  \n   t2.join();  \n  \n   cout \u003c\u003c x \u003c\u003c endl;  \n  \n   return 0;  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225839-c2m5szs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225839-c2m5szs"
			}
		},
		{
			"ID": "20221017225222-l8zy6bg",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20221017225222-l8zy6bg",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "锁在循环内部"
				}
			]
		},
		{
			"ID": "20221017225222-nwrty85",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-nwrty85",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cmutex\u003e  \n#include \u003cthread\u003e  \nint x = 0;  \nmutex mtx;  \nvoid Func(int n)  \n{  \n   mtx.lock();  \n   for (int i = 0; i \u003c n; ++i)  \n   {  \n      //cout \u003c\u003c std::this_thread::get_id() \u003c\u003c\"-\u003e\"\u003c\u003c x \u003c\u003c endl;    \n      ++x;  \n   }\n   mtx.unlock();  \n   \n}  \nint main()  \n{  \n   thread t1(Func, 5000000);  \n   thread t2(Func, 5000000);  \n  \n   t1.join();  \n   t2.join();  \n  \n   cout \u003c\u003c x \u003c\u003c endl;  \n  \n   return 0;  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-wb190fz",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-wb190fz",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原子性操作库(atomic)"
				}
			]
		},
		{
			"ID": "20221017225222-0npnts2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-0npnts2",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "多线程最主要的问题是共享数据带来的问题(即线程安全)。"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "如果共享数据都是只读的，那么没问题，因为只读操作不会影响到数据，更不会涉及对数据的修改，所以所有线程都会获得同样的数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。但是，当一个或多个线程要修改共享数据时，就会产生很多潜在的麻烦。"
				}
			]
		},
		{
			"ID": "20221017225222-3vw9oaq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-3vw9oaq",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "虽然加锁可以解决，但是"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "加锁有一个缺陷"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "就是：只要一个线程在对"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "sum++"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "时，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "其他线程就会被阻塞，会影响程序运行的效率，而且锁如果控制不好，还容易造成"
						},
						{
							"Type": "NodeMark",
							"Data": "mark",
							"Children": [
								{
									"Type": "NodeMark2OpenMarker"
								},
								{
									"Type": "NodeText",
									"Data": "死锁"
								},
								{
									"Type": "NodeMark2CloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221017225222-7djefw2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-7djefw2",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因此C++11中引入了原子操作。所谓原子操作：即不可被中断的一个或一系列操作，C++11引入的原子操作类型，使得线程间数据的同步变得非常高效。"
				}
			]
		},
		{
			"ID": "20221017225222-adocn9k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-adocn9k",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在C++11中，程序员不需要对原子类型变量进行加锁解锁操作，线程能够对原子类型变量互斥的访问。\n更为普遍的，程序员可以使用 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "atomic"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 类模板，定义出需要的任意原子类型"
				}
			]
		},
		{
			"ID": "20221017225222-53wb6gy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-53wb6gy",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "atmoic\u003cT\u003e t;   // 声明一个类型为T的原子类型变量t\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-mbuvliw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-mbuvliw",
				"updated": "20221017225925"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "原子类型通常属于\"资源型\"数据，多个线程只能访问单个原子类型的拷贝，因此在C++11中，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "原子类型只能从其模板参数中进行构造，不允许原子类型进行拷贝构造、移动构造以及operator=等"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，为了防止意外，标准库已经将atmoic模板类中的拷贝构造、移动构造、赋值运算符重载默认删除掉了。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221016224938"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221016224938-20221017225925-rz3xard.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n注意：需要使用以上原子操作变量时，必须添加头文件"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "\u003catomic\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225948-amiwhhy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225948-amiwhhy"
			}
		},
		{
			"ID": "20221017225222-do0kscs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-do0kscs",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但临界区的数据很少时，可以将数据设置为原子操作变量。"
				}
			]
		},
		{
			"ID": "20221017225222-jfy6gbx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-jfy6gbx",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003ciostream\u003e \nusing namespace std; \n#include \u003cthread\u003e \n#include \u003catomic\u003e\n\natomic_long sum{ 0 }; //定义sum为原子变量\n\nvoid fun(size_t num)\n{\n\tfor (size_t i = 0; i \u003c num; ++i) \n\tsum ++;   // 原子操作\n}\n\nint main() \n{\n\tcout \u003c\u003c \"Before joining, sum = \" \u003c\u003c sum \u003c\u003c std::endl; \n\tthread t1(fun, 1000000);\n\tthread t2(fun, 1000000); \n\tt1.join();\n\tt2.join();\n\tcout \u003c\u003c \"After joining, sum = \" \u003c\u003c sum \u003c\u003c std::endl; \n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-krbc23o",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-krbc23o",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "lock_guard"
				}
			]
		},
		{
			"ID": "20221017225222-q0cwjfk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-q0cwjfk",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在多线程环境下，如果想要保证某个变量的安全性，只要将其设置成对应的原子类型即可，即高效又不容易出现死锁问题。但是有些情况下，我们可能需要保证一段代码的安全性，那么就只能通过锁的方式来进行控制。"
				}
			]
		},
		{
			"ID": "20221017225222-l1cr9kj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-l1cr9kj",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_guard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 对象的"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "拷贝构造和移动构造"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "(move construction)均"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "被禁用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，因此 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_guard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对象不可被拷贝构造或移动构造"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20221017230044-r5p3f5d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017230044-r5p3f5d"
			}
		},
		{
			"ID": "20221017225222-kdschih",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-kdschih",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "比如：一个线程对变量number进行加一100次，另外一个减一100次，每次操作加一或者减一之后，输出number的结果，要求：number最后的值为1。"
				}
			]
		},
		{
			"ID": "20221017225222-itgzur8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-itgzur8",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在我们写代码的实际过程中，直接将一段代码加锁保护其实是不安全的，距举例以下的例子"
				}
			]
		},
		{
			"ID": "20221017225222-jwenml0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-jwenml0",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "mutex mtx;\nmtx.lock();\n//代码段......\nmtx.unlock();\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-0r6trbt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-0r6trbt",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "为什么说他是不安全的呢？"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n1、从两个角度出发，如果代码在执行的过程中被突然中断了return后那么原来lock了之后锁是没有被释放的，如果是在多线程环境下这就会导致死锁，"
				}
			]
		},
		{
			"ID": "20221017225222-kqd1d91",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-kqd1d91",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "先看"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "malloc"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的表现，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "malloc"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "失败后会返回null, 那么if判断之后，会直接返回"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "-1"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": ", 整个程序就结束了，可是如果是多线程环境下，那么还是会死锁，一个线程拿到锁之后并没有释放，另外一个线程就会被卡在执行处."
				}
			]
		},
		{
			"ID": "20221017225222-lw6t3mk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-lw6t3mk",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "mutex mtx;\nint func2() \n{\n\n\tmtx.lock();\n\n\tint* p = (int*)malloc(sizeof(int) * 10);\n\tif (!p) return -1; //内存申请失败后返回\n\tfor (int i = 0; i \u003c 10; i++) {\n\t\t*(p + i) = i;\n\t}\n\tfor (int i = 0; i \u003c 10; i++) cout \u003c\u003c p[i] \u003c\u003c \" \";\n\n\tmtx.unlock();\n}\n\nint main()\n{\n\tthread t1(func2);\n\tthread t2(func2);\n\n\tt1.join();\n\tt2.join();\n\treturn 0;\n}\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-7vkpcya",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-7vkpcya",
				"updated": "20221017230114"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "2、如果抛"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "异常"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "了之后，跳转到catch处，可是"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "catch"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "并不能为你释放锁资源，那么也会导致死锁的问题"
				}
			]
		},
		{
			"ID": "20221017225222-2jt6kp9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-2jt6kp9",
				"updated": "20221017230127"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果代码是正常执行的话，那么并没有什么问题，可以如果是在多线程的环境下"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "new"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "一旦失败了，就会抛异常而"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "try"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 捕捉到了之后就会交给"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "catch"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "处理，可是"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "catch"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "也并没有去释放锁。"
				}
			]
		},
		{
			"ID": "20221017225222-p66hz63",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-p66hz63",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下代码已做catch处理。"
				}
			]
		},
		{
			"ID": "20221017225222-xn4avrq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-xn4avrq",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "#include \u003cmutex\u003e  \n#include \u003cthread\u003e  \n#include \u003catomic\u003e  \n  \nvoid func(vector\u003cint\u003e\u0026 v, int n, int base, mutex\u0026 mtx)  \n{  \n   try  \n   {  \n      // 死锁  \n      for (int i = 0; i \u003c n; ++i)  \n      {  \n         mtx.lock();  \n         cout \u003c\u003c this_thread::get_id() \u003c\u003c \":\" \u003c\u003c base + i \u003c\u003c endl;  \n  \n         // 失败了 抛异常 -- 异常安全的问题  \n         v.push_back(base+i);  \n         // 模拟push_back失败抛异常  \n         if (base == 1000 \u0026\u0026 i == 888)  \n            throw bad_alloc();  \n  \n         mtx.unlock();  \n      }  \n   }  \n   catch (const exception\u0026 e)  \n   {  \n      cout \u003c\u003c e.what() \u003c\u003c endl;  \n      mtx.unlock();  \n   }  \n}  \n  \nint main()  \n{  \n   thread t1, t2;  \n   vector\u003cint\u003e vec;  \n   mutex mtx;  \n  \n   try   {  \n      t1 = thread(func, std::ref(vec), 1000, 1000, std::ref(mtx));  \n      t2 = thread(func, std::ref(vec), 1000, 2000, std::ref(mtx));  \n   }  \n   catch (const exception\u0026 e)  \n   {  \n      cout \u003c\u003c e.what() \u003c\u003c endl;  \n   }  \n  \n   t1.join();  \n   t2.join();  \n  \n   for (auto e : vec)  \n   {  \n      cout \u003c\u003c e \u003c\u003c \" \";  \n   }  \n   cout \u003c\u003c endl \u003c\u003c endl;  \n   cout \u003c\u003c vec.size() \u003c\u003c endl;  \n  \n  \n   return 0;  \n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-o8guoa8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-o8guoa8",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "锁控制不好时，可能会造成死锁，最常见的比如在锁中间代码返回，或者在锁的范围内抛异常。因此：C++11采用"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "RAII（ RAII (Resource Acquisition Is Initialization)是一种利用对象生命周期来控制程序资源(如内存、文件句 柄r网络连接、斥量等等)的简单技术"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。 ）的方式对锁进行了封装，即 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "lock_guard"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 和 "
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "unique_lock"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " ，引入"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_guard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "之后，并不会出现这样的问题"
				}
			]
		},
		{
			"ID": "20221017230154-sb8b1f9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017230154-sb8b1f9"
			}
		},
		{
			"ID": "20221017225222-xvhgfkq",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221017225222-xvhgfkq",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "lock_guard的实现"
				}
			]
		},
		{
			"ID": "20221017225222-dtxmhrf",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-dtxmhrf",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "template\u003cclass Lock\u003e\n\nclass LockGuard // 锁的守卫\n{\npublic:\n\tLockGuard(Lock\u0026 lock)\n\t\t:_lock(lock)\n\t{\n\t\t_lock.lock();\n\t}\n\n\t~LockGuard()\n\t{\n\t\t_lock.unlock();\n\t}\n\nprivate:\n\tLock\u0026 _lock;\n};\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-0op5v98",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-0op5v98",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此时我们可以发现，在使用"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_guard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "之后，无论是抛异常还是程序中间返回，都会被处理。\n通过上述代码可以看到，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_guard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "类模板主要是通过"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "RAII"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的方式，对其管理的互斥量进行了封装，在需要加锁的地方，只需要用上述介绍的任意互斥体实例化一个lock_guard，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "调用构造函数成功上锁，出作用域前, lock_guard对象要被销毁，调用析构函数自动解锁"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，可以有效避免死锁问题。"
				}
			]
		},
		{
			"ID": "20221017225222-k6wfmca",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221017225222-k6wfmca",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "lock_guard的使用"
				}
			]
		},
		{
			"ID": "20221017225222-f17ggmz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-f17ggmz",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "// 模拟lock_guard的实现过程\nnamespace mzt \n{\n\ttemplate\u003cclass T\u003e\n\tclass lock_guard\n\t{\n\tpublic:\n\t\tlock_guard(T\u0026 lock) : _lock(lock)\n\t\t{\n\t\t\t_lock.lock();\n\t\t}\n\t\t~lock_guard() { _lock.unlock(); }\n\t\n\n\t\tlock_guard(lock_guard\u003cT\u003e\u0026 lock) = delete;\n\t\tlock_guard\u003cT\u003e\u0026 operator=(lock_guard\u003cT\u003e\u0026 lock) = delete;\n\tprivate:\n\t\tT\u0026 _lock;\n\t};\n\n}\nmutex mtx;\nint func2() \n{\n\tmzt::lock_guard\u003cmutex\u003e lg (mtx);\n\t//mtx.lock();\n\n\tint* p = (int*)malloc(sizeof(int) * 10);\n\tif (!p) return -1; //内存申请失败后返回\n\tfor (int i = 0; i \u003c 10; i++) {\n\t\t*(p + i) = i;\n\t}\n\tfor (int i = 0; i \u003c 10; i++) cout \u003c\u003c p[i] \u003c\u003c \" \";\n\n\t//mtx.unlock();\n\treturn 0;\n}\n\nint main()\n{\n\tthread t1(func2);\n\tthread t2(func2);\n\t//test();\n\n\tt1.join();\n\tt2.join();\n\treturn 0;\n}\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-g66hb61",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-g66hb61",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "lock_guard的缺陷：太单一，用户没有办法对该锁进行控制，因此C++11又提供了unique_lock。"
				}
			]
		},
		{
			"ID": "20221017225222-ske8dlk",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-ske8dlk",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "unique_lock"
				}
			]
		},
		{
			"ID": "20221017225222-8fobglv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-8fobglv",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "与"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lock_gard"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "类似，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "unique_lock"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "类模板也是采用"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeText",
							"Data": "RAII"
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的方式对锁进行了封装，并且也是以独占所有权的方式，管理mutex对象的上锁和解锁操作，即"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "其对象之间不能发生拷贝"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。\n在"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "构造"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "(或"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "移动(move)赋值"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": ")时，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "unique_lock"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 对象需要传递一个 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "Mutex"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 对象作为它的参数，"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "新创建的 unique_lock 对象负责传入的 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "Mutex"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "对象的上锁和解锁操作"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。\n使用以上类型互斥量实例化"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "unique_lock"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的对象时，自动调用构造函数上锁，unique_lock对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题。\n与lock_guard不同的是，"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "unique_lock"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "更加的灵活，提供了更多的成员函数"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "："
				}
			]
		},
		{
			"ID": "20221017225222-p0qxykt",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221017225222-p0qxykt",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"ID": "20221017225222-23i4g68",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-23i4g68",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-qw3qdk7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-qw3qdk7",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeMark",
									"Data": "mark",
									"Children": [
										{
											"Type": "NodeMark2OpenMarker"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "上锁/解锁操作"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeMark2CloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "：lock、try_lock、try_lock_for、try_lock_until和unlock"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-r5orvju",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-r5orvju",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-k889n8i",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-k889n8i",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeMark",
									"Data": "mark",
									"Children": [
										{
											"Type": "NodeMark2OpenMarker"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "修改操作"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeMark2CloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放(release：返回它所管理的互斥量对象的指针，并释放所有权)"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-0780f5s",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-0780f5s",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-gx7glq3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-gx7glq3",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeMark",
									"Data": "mark",
									"Children": [
										{
											"Type": "NodeMark2OpenMarker"
										},
										{
											"Type": "NodeStrong",
											"Data": "strong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "获取属性"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeMark2CloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、mutex(返回当前unique_lock所管理的互斥量的指针)。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221213132301-gzwy4e1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221213132301-gzwy4e1"
			}
		},
		{
			"ID": "20221017225222-ht81x9a",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221017225222-ht81x9a",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "lock_guard 和 unique_lock详解链接"
				}
			]
		},
		{
			"ID": "20221017225222-kkxptc3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-kkxptc3",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeLink",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "lock_guard/unique_lock详解"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "https://blog.csdn.net/zzhongcy/article/details/85230200"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-z37uo7d",
			"Type": "NodeHeading",
			"HeadingLevel": 1,
			"Properties": {
				"id": "20221017225222-z37uo7d",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线程同步"
				}
			]
		},
		{
			"ID": "20221017225222-81nwlv0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-81nwlv0",
				"updated": "20221017230245"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221017172529"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221017172529-20221017230245-v444fyq.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20221017230310-bbibn1a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017230310-bbibn1a"
			}
		},
		{
			"ID": "20221017225222-bm9s54x",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221017225222-bm9s54x",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "条件变量函数"
				}
			]
		},
		{
			"ID": "20221017225222-wly6sil",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221017225222-wly6sil",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "wait()"
				}
			]
		},
		{
			"ID": "20221017225222-lysuzes",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-lysuzes",
				"updated": "20221017230301"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221017171307"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221017171307-20221017230301-c58wvra.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-yrzofoi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-yrzofoi",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "参数："
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-xt5ve8i",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20221017225222-xt5ve8i",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e"
				},
				{
					"ID": "20221017225222-934awu5",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20221017225222-934awu5",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"Type": "NodeMark",
							"Data": "mark",
							"Children": [
								{
									"Type": "NodeMark2OpenMarker"
								},
								{
									"Type": "NodeText",
									"Data": "lck"
								},
								{
									"Type": "NodeMark2CloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": ": 传递unique_lock类型的对象\n"
						},
						{
							"Type": "NodeMark",
							"Data": "mark",
							"Children": [
								{
									"Type": "NodeMark2OpenMarker"
								},
								{
									"Type": "NodeText",
									"Data": "Predicate"
								},
								{
									"Type": "NodeMark2CloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "： 模板参数，传递对应的可调用对象（lanmda表达式、函数指针、仿函数）, 可调用对象必须是具有返回值的，并且"
						},
						{
							"Type": "NodeMark",
							"Data": "mark",
							"Children": [
								{
									"Type": "NodeMark2OpenMarker"
								},
								{
									"Type": "NodeText",
									"Data": "返回值必须是一个bool类型"
								},
								{
									"Type": "NodeMark2CloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "。"
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-v2dcoc2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-v2dcoc2",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "等到通知当前线程（应该已经锁定了 lck 的互斥锁）的执行被阻塞，直到得到通知。"
				}
			]
		},
		{
			"ID": "20221017225222-dbi716c",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-dbi716c",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "阻塞线程的那一刻"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，函数"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "自动调用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "lck.unlock()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，允许其他被锁定的线程继续。"
				}
			]
		},
		{
			"ID": "20221017225222-g80ov6a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-g80ov6a",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "一旦通知（明确地，由某个其他线程），该函数将解除阻塞并调用 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "lck.lock()"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，使 lck 处于与调用函数时相同的状态。然后函数返回（注意最后一个互斥锁可能会在返回之前再次阻塞线程）。"
				}
			]
		},
		{
			"ID": "20221017225222-dabwz9u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-dabwz9u",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通常，函数通过调用另一个线程中的成员 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "notify_one"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 或成员 "
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "notify_all"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 来通知唤醒。但是某些实现可能会在没有调用任何这些函数的情况下产生虚假的唤醒呼叫。因此，该功能的用户应确保满足其恢复条件。"
				}
			]
		},
		{
			"ID": "20221017225222-7b7bdm6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-7b7bdm6",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "如果指定了 pred (2)，则该函数仅在 pred 返回 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "false"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 时阻塞，并且通知只能在它变为 "
						},
						{
							"Type": "NodeCodeSpan",
							"Data": "code",
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "true"
								},
								{
									"Type": "NodeCodeSpanCloseMarker"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 时解除阻塞线程（这对于检查虚假唤醒调用特别有用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "）。就像如此："
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "while (!pred()) wait(lck);"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				}
			]
		},
		{
			"ID": "20221213141553-fftd25x",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221213141553-fftd25x"
			}
		},
		{
			"ID": "20221017225222-1t2swnc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20221017225222-1t2swnc",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "notify_one() 和 notify_all()"
				}
			]
		},
		{
			"ID": "20221017225222-5eql17u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-5eql17u",
				"updated": "20221017230344"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221017171834"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221017171834-20221017230344-79lodc2.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n"
				},
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "notify_one()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "通知一个"
				}
			]
		},
		{
			"ID": "20221017225222-7akvhq4",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20221017225222-7akvhq4",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"ID": "20221017225222-ir2y8hb",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-ir2y8hb",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-ifa09i2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-ifa09i2",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "解除阻塞"
								},
								{
									"Type": "NodeCodeSpan",
									"Data": "code",
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "当前等待（这属于一个条件）"
										},
										{
											"Type": "NodeCodeSpanCloseMarker"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "这个条件的线程之一。"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-282znh4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-282znh4",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-t76fggk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-t76fggk",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果没有线程在等待，该函数什么也不做。"
								}
							]
						}
					]
				},
				{
					"ID": "20221017225222-i5elnjr",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20221017225222-i5elnjr",
						"updated": "20221017225222"
					},
					"Children": [
						{
							"ID": "20221017225222-cvhh0i7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20221017225222-cvhh0i7",
								"updated": "20221017225222"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果多于一个，则未指定选择哪个线程。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20221017225222-dvirq9q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-dvirq9q",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"Data": "code",
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "notify_all()"
						},
						{
							"Type": "NodeCodeSpanCloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 通知所有线程."
				}
			]
		},
		{
			"ID": "20221017230355-y4vy335",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017230355-y4vy335"
			}
		},
		{
			"ID": "20221017225222-08i9ngc",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20221017225222-08i9ngc",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "线程同步案例"
				}
			]
		},
		{
			"ID": "20221017225222-xc8yddw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-xc8yddw",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "看一个题了解线程同步\n"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "支持两个线程交替打印，一个打印奇数，一个打印偶数"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\nt1打印奇数，t2打印偶数。"
				}
			]
		},
		{
			"ID": "20221017225222-ha9u862",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-ha9u862",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "目前代码中只加入了互斥锁。"
				}
			]
		},
		{
			"ID": "20221017225222-skg9zi2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-skg9zi2",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main()\n{\n\tint n = 100;\n\tint i = 0;\n\tmutex mtx;\n\n\t//打印奇数\n\tthread t1([n ,\u0026i , \u0026mtx] {\n\t\twhile(i \u003c n)\n\t\t{\n\t\t\tunique_lock\u003cmutex\u003e lock(mtx);\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \" -\u003e \" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\t\t}\n\t});\n\n\t//打印偶数\n\tthread t2([n , \u0026i, \u0026mtx] {\n\t\twhile (i \u003c n)\n\t\t{\n\t\t\tunique_lock\u003cmutex\u003e lock(mutex);\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \" -\u003e \" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\t\t}\n\t});\n\n\tt1.join();\n\tt2.join();\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-kylmqne",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-kylmqne",
				"updated": "20221017230412"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不仅没有交替打印，而且出现了线程安全问题。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221017165427"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221017165427-20221017230412-at4c6c9.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "\n没有交替打印是因为"
				},
				{
					"Type": "NodeMark",
					"Data": "mark",
					"Children": [
						{
							"Type": "NodeMark2OpenMarker"
						},
						{
							"Type": "NodeStrong",
							"Data": "strong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "时间片"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeMark2CloseMarker"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的原因，每个线程的时间片是不同的，所有这是没有出现交替打印的原因。"
				}
			]
		},
		{
			"ID": "20221017225222-vblawn1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-vblawn1",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "需要完美的实现这个案例，这就需要我们加入"
				},
				{
					"Type": "NodeStrong",
					"Data": "strong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "条件变量"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "了"
				}
			]
		},
		{
			"ID": "20221017225222-mfxvl78",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-mfxvl78",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main()\n{\n\tint n = 100;\n\tint i = 0;\n\tmutex mtx;\n\tcondition_variable cv;//定义条件变量\n\tbool flag = false;\n\n\n\t//打印奇数\n\tthread t1([n ,\u0026i , \u0026mtx ,\u0026cv , \u0026flag] {\n\t\twhile(i \u003c n)\n\t\t{\n\t\t\tunique_lock\u003cmutex\u003e lock(mtx);\n\t\t\t// flag是false的时候，这里会一直阻塞，直到flag变成true\n\t\t\tcv.wait(lock, [\u0026flag] {return flag; });\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \" :-\u003e \" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\n\t\t\tflag = false;\n\t\t\tcv.notify_one();\n\t\t}\n\t});\n\n\t//打印偶数\n\tthread t2([n , \u0026i, \u0026mtx ,\u0026cv , \u0026flag] {\n\t\twhile (i \u003c n)\n\t\t{\n\t\t\tunique_lock\u003cmutex\u003e lock(mtx);\n\n\t\t\t// !flag是true,那么这里获取侯不会阻塞，优先运行了\n\t\t\tcv.wait(lock, [\u0026flag] {return !flag; });\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \" :-\u003e \" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\n\t\t\tflag = true;// 保证下一个打印运行一定是t1，也可以防止t2连续打印运行\n\t\t\tcv.notify_one();\n\t\t}\n\t});\n\n\tt1.join();\n\tt2.join();\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20221017225222-sc7eo3d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-sc7eo3d",
				"updated": "20221017230435"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行此时运行就没有问题了。\n​"
				},
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "Pasted image 20221017170421"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "assets/Pasted image 20221017170421-20221017230435-yxro863.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				},
				{
					"Type": "NodeBr",
					"Data": "br"
				}
			]
		},
		{
			"ID": "20221017230426-9zyvhfi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017230426-9zyvhfi"
			}
		},
		{
			"ID": "20221017225222-1kserbt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20221017225222-1kserbt",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "以下代码多此案例进行了多添加了一些测试,t1打印偶数，t2打印奇数。"
				}
			]
		},
		{
			"ID": "20221017225222-bxq9ar6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20221017225222-bxq9ar6",
				"updated": "20221017225222"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "Y3Bw"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "int main()\n{\n\tint n = 100;\n\tint i = 0;\n\tmutex mtx;\n\tcondition_variable cv;\n\tbool flag = false;\n\n\t// 奇数-后打印\n\tthread t2([n, \u0026i, \u0026mtx, \u0026cv, \u0026flag] {\n\t\twhile (i \u003c n)\n\t\t{\n\t\t\t// 模拟中间某次t2时间片用完了，竞争大，排队很，多休眠了一会\n\t\t\t/*if (i == 50)\n\t\t\t{\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \"休眠3s\" \u003c\u003c endl;\n\t\t\tthis_thread::sleep_for(chrono::seconds(3));\n\t\t\t}*/\n\n\t\t\tunique_lock\u003cmutex\u003e lock(mtx);\n\t\t\t// flag是false的时候，这里会一直阻塞，知道flag变成true\n\t\t\tcv.wait(lock, [\u0026flag]() {return flag; });\n\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \":-\u003e\" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\n\t\t\tflag = false;\n\n\t\t\tcv.notify_one();\n\t\t}\n\t\t});\n\n\t// 偶数-先打印\n\tthread t1([n, \u0026i, \u0026mtx, \u0026cv, \u0026flag] {\n\t\twhile (i \u003c n)\n\t\t{\n\t\t\tunique_lock\u003cmutex\u003e lock(mtx);\n\t\t\t// !flag是true,那么这里获取侯不会阻塞，优先运行了\n\t\t\tcv.wait(lock, [\u0026flag]() {return !flag; });\n\n\t\t\tcout \u003c\u003c this_thread::get_id() \u003c\u003c \"-\u003e:\" \u003c\u003c i \u003c\u003c endl;\n\t\t\t++i;\n\n\t\t\t// 保证下一个打印运行一定是t1，也可以防止t1连续打印运行\n\t\t\tflag = true;\n\n\t\t\tcv.notify_one();\n\t\t}\n\t\t});\n\n\t// 交替走\n\n\tt1.join();\n\tt2.join();\n\n\treturn 0;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		}
	]
}