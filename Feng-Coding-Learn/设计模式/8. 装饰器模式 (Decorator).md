---
Type: Note
tags:
  - 设计模式
  - CPP
Status: writing
Start-date: 2025-08-02 20:59
Finish-date: 
Modified-date: 2025-08-02 21:02
Publish: false
---


在上一讲[[7. 组合模式(Composite)|组合模式]]中，我们学会了如何将“部分”与“整体”统一对待，优雅地处理树形结构。今天，我们将学习一个极富创意和弹性的模式，它能让你像玩乐高积木一样，在**运行时**为一个对象动态地“拼装”上新的功能。它就是——**装饰器模式 (Decorator Pattern)**。

---

## 装饰器模式 (Decorator) - 动态扩展功能的艺术

> [!INFO] 前言
> 
> 想象一下你在一家咖啡店点单。你的基础选择是一杯“黑咖啡”。但你还想要加点东西：
> 
> - 加一份奶？好的，现在它是“黑咖啡 + 奶”。
>     
> - 再加一份糖？好的，现在它是“黑咖啡 + 奶 + 糖”。
>     
> - 最后再来点奶油？没问题，现在它是“黑咖啡 + 奶 + 糖 + 奶油”。
>     
> 
> 每一项“加料”（奶、糖、奶油）都为原始的“黑咖啡”增加了新的特性（和成本）。而且，这些“加料”的组合和顺序可以是任意的。
> 
> 如果我们用传统的**继承**来模拟这个场景，将会陷入一场灾难。我们可能需要 `CoffeeWithMilk`, `CoffeeWithSugar`, `CoffeeWithMilkAndSugar`... 类的数量会随着“加料”选项的增多而呈指数级爆炸。更重要的是，继承是**静态**的，在编译时就确定了，我们无法在程序运行时为一个已存在的咖啡对象动态地添加或移除“加料”。
> 
> ==装饰器模式，就是为了解决这个问题而生的。它提供了一种比继承更灵活的方式来扩展对象的功能。==

### 装饰器模式精解

> [!QUOTE] GoF 经典定义
> 
> ==动态地给一个对象添加一些额外的职责==。就扩展功能而言，装饰器模式相比生成子类更为灵活。

==**核心思想**==：
采用“包装”的方式。装饰器模式创建一个“包装类”（即装饰器），这个包装类持有被包装的原始对象，并且和原始对象实现相同的接口。当客户端调用包装类的方法时，包装类可以在执行自己新增的行为之前或之后，再调用被包装的原始对象的核心方法。

由于装饰器和被包装对象实现了相同接口，所以装饰器可以一层又一层地“套娃”——你可以用一个装饰器去包装另一个装饰器，形成一个功能不断增强的链条。

**结构组成**：
1. **组件 (Component)**: (e.g., `INotifier`) 定义了原始对象和装饰器对象的共同接口。
2. **具体组件 (Concrete Component)**: (e.g., `EmailNotifier`) 这是被装饰的原始对象，它实现了 `Component` 接口。
3. **装饰器基类 (Decorator)**: (e.g., `NotifierDecorator`) 这是一个抽象类，它也实现了 `Component` 接口。其内部持有一个 `Component` 对象的指针/引用（指向被包装的对象）。它的核心职责是将所有请求都委托给被包装的对象。
4. **具体装饰器 (Concrete Decorator)**: (e.g., `SMSDecorator`, `SlackDecorator`) 继承自装饰器基类。它们负责为组件添加新的职责。在调用父类（最终会调用到被包装对象）的方法之前或之后，执行自己额外的操作。
    

### C++ 实现装饰器模式 (完整可运行示例)

**场景**：我们要构建一个通知系统。最基础的功能是通过邮件发送通知。我们希望能在不修改核心邮件通知代码的情况下，动态地为其增加通过短信(SMS)、Slack等渠道发送通知的功能。

```cpp
#include <iostream>
#include <string>
#include <memory>

// =================================================================
// 1. 组件 (Component) 接口
// =================================================================
class INotifier {
public:
    virtual ~INotifier() {}
    virtual void send(const std::string& message) const = 0;
};

// =================================================================
// 2. 具体组件 (Concrete Component)
// 这是我们的核心、基础对象。
// =================================================================
class EmailNotifier : public INotifier {
public:
    void send(const std::string& message) const override {
        std::cout << "--- Core Action ---" << std::endl;
        std::cout << "Sending Email with message: '" << message << "'" << std::endl;
    }
};

// =================================================================
// 3. 装饰器基类 (Decorator)
// =================================================================
class NotifierDecorator : public INotifier {
protected:
    // 持有被包装的组件对象
    std::unique_ptr<INotifier> m_wrappedNotifier;

public:
    NotifierDecorator(std::unique_ptr<INotifier> notifier) 
        : m_wrappedNotifier(std::move(notifier)) {}

    // 将请求委托给被包装的对象
    void send(const std::string& message) const override {
        if (m_wrappedNotifier) {
            m_wrappedNotifier->send(message);
        }
    }
};

// =================================================================
// 4. 具体装饰器 (Concrete Decorator)
// =================================================================

// 短信装饰器
class SMSDecorator : public NotifierDecorator {
public:
    // 构造函数接收一个已有的Notifier对象（可能是原始对象，也可能是已被其他装饰器包装过的对象）
    SMSDecorator(std::unique_ptr<INotifier> notifier) : NotifierDecorator(std::move(notifier)) {}

    void send(const std::string& message) const override {
        // **==1. 先执行自己的新增行为==**
        std::cout << "Decorator Action: Sending SMS with message: '" << message << "'" << std::endl;
        // **==2. 再调用被包装对象原来的行为==**
        NotifierDecorator::send(message);
    }
};

// Slack装饰器
class SlackDecorator : public NotifierDecorator {
public:
    SlackDecorator(std::unique_ptr<INotifier> notifier) : NotifierDecorator(std::move(notifier)) {}

    void send(const std::string& message) const override {
        std::cout << "Decorator Action: Sending Slack message: '" << message << "'" << std::endl;
        NotifierDecorator::send(message);
    }
};


// =================================================================
// 5. 客户端 (Client)
// =================================================================
int main() {
    std::cout << "--- Decorator Pattern Demo ---" << std::endl;

    // 场景1: 只发送邮件
    std::cout << "\n===== Scenario 1: Basic Email Notification =====\n";
    auto simpleNotifier = std::make_unique<EmailNotifier>();
    simpleNotifier->send("Hello, World!");
    
    // 场景2: 发送邮件，并增加短信通知功能
    std::cout << "\n===== Scenario 2: Email + SMS Notification =====\n";
    // 创建一个基础邮件通知器
    auto emailNotifierForSms = std::make_unique<EmailNotifier>();
    // 用SMS装饰器包装它
    auto smsAndEmailNotifier = std::make_unique<SMSDecorator>(std::move(emailNotifierForSms));
    smsAndEmailNotifier->send("System Maintenance Alert!");

    // 场景3: 发送邮件，并同时增加短信和Slack通知功能 (链式包装)
    std::cout << "\n===== Scenario 3: Email + SMS + Slack Notification =====\n";
    // **==这就是装饰器模式的魔力：动态地、层层地包装！==**
    auto coreNotifier = std::make_unique<EmailNotifier>();
    auto smsWrapped = std::make_unique<SMSDecorator>(std::move(coreNotifier));
    auto slackAndSmsWrapped = std::make_unique<SlackDecorator>(std::move(smsWrapped));

    // 客户端最终面对的仍然是一个简单的 INotifier 接口
    slackAndSmsWrapped->send("Project Deadline Approaching!");

    std::cout << "\n--- Demo Finished ---" << std::endl;
    return 0;
}
```

> [!TIP] 代码深度解析
> 
> 1. **包装链 (Wrapper Chain)**: 在场景3中，我们创建了一个 `SlackDecorator -> SMSDecorator -> EmailNotifier` 的调用链。当 `slackAndSmsWrapped->send()` 被调用时：
>     
>     - `SlackDecorator::send()` 首先执行（打印Slack信息）。
>         
>     - 然后它调用 `NotifierDecorator::send()`，这个调用被委托给了它包装的 `SMSDecorator`。
>         
>     - `SMSDecorator::send()` 接着执行（打印SMS信息）。
>         
>     - 然后它也调用 `NotifierDecorator::send()`，最终委托给了最内层的 `EmailNotifier`。
>         
>     - `EmailNotifier::send()` 执行核心操作（打印Email信息）。
>         
> 2. **统一接口**: 客户端代码无论面对的是一个简单的 `EmailNotifier`，还是一个被层层包装的 `SlackDecorator`，它看到的都是同一个 `INotifier` 接口。这使得客户端代码极其稳定。
>     
> 3. **动态性**: 我们可以根据运行时的条件（比如用户的配置）来决定是否要用某个装饰器进行包装，这是静态继承完全无法做到的。
>     
> 4. **符合开闭原则**: ==装饰器模式是开闭原则（对扩展开放，对修改关闭）的绝佳范例==。当我们需要增加一种新的通知方式（比如 `WeChatDecorator`），我们只需要增加一个新的装饰器类即可，完全不需要修改任何现有代码。



### 优缺点总结

> [!SUCCESS] 优点
> 
> - **遵循开闭原则**：可以在不修改现有代码的情况下，为对象扩展新功能。
>     
> - **比继承更灵活**：可以在运行时动态地添加或删除功能，并且可以任意组合。
>     
> - **避免“类爆炸”**：相比继承，可以避免因功能的多种组合而导致子类数量激增。
>     
> - **职责分离**：可以将核心职责与附加职责分离开来，每个装饰器只关心自己那部分新增的功能。
>     

> [!FAILURE] 缺点
> 
> - **会产生许多小对象**：使用装饰器模式通常会产生大量细粒度的、功能单一的小对象，增加了系统的复杂性。
>     
> - **调试困难**：对于一个被层层包装的对象，要追踪其行为和调试错误可能会比较困难，因为调用栈会变得很深。
>     
> - **顺序敏感**：装饰器的顺序可能会影响最终结果和行为，需要小心管理。
>     

> [!QUESTION] 装饰器 vs. 代理 (Proxy)
> 
> 这两个模式在结构上惊人地相似（都是包装另一个对象并实现相同接口），但它们的意图截然不同。
> 
> - **装饰器 (Decorator)** 的意图是**增强功能**。它为对象**添加**新的职责，并且总是会执行被包装对象的核心行为。
>     
> - **代理 (Proxy)** 的意图是**控制访问**。它作为原对象的“守门员”或“替身”，可以决定**是否**将请求传递给原对象。例如，一个`缓存代理`可能会直接返回缓存数据而根本不访问原对象；一个`权限代理`可能会在检查权限失败后直接拒绝请求。
>     

#### 本章小结

**==当你想在不修改对象自身代码的前提下，于运行时动态地、可组合地为对象添加新功能时，装饰器模式是无与伦比的解决方案。==**

它通过一种巧妙的“套娃”式的包装机制，为我们提供了一种极其灵活的对象功能扩展方案。从 Java 的 I/O 流到各种GUI框架中的组件，装饰器模式的身影无处不在，是面向对象设计武库中的一件利器。

---

> [!TODO] 下一讲预告
> 
> 装饰器模式通过“包装”为对象增加了功能。而下一讲，我们将学习一个反其道而行之的模式——外观模式 (Facade Pattern)。它不增加功能，而是致力于简化！外观模式将一个复杂的、由许多子系统构成的庞大系统，用一个简洁明了的“外观”接口包装起来，让客户端可以轻松地使用这个复杂系统。敬请期待！

