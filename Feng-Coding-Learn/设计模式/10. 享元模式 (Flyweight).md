---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-08 21:41
Finish-date: 
Modified-date: 2025-08-08 22:30
Publish: false
---
在上一讲[[9. 外观模式 (Facade)|外观模式]]中，我们学会了如何用一个简洁的“门面”来隐藏和简化一个复杂的子系统。今天，我们将把目光投向一个与性能和效率息息相关的领域，学习一个旨在**极致优化内存使用**的模式——**享元模式 (Flyweight Pattern)**。


### **C++ 设计模式学习之旅 (10): 享元模式 (Flyweight) - 极致的内存优化之道**

> [!INFO] 前言
> 
> 想象一下，你要开发一款即时战略游戏，屏幕上可能有成千上万棵树木、石头和草丛来构成宏大的战场环境。如果每一个“树”对象都包含了它自己的3D模型数据、纹理贴图、碰撞体积等所有信息，那么内存的消耗将是惊人的。10000棵树，就意味着10000份完整的模型和纹理数据，这足以让任何现代计算机的内存不堪重负。
> 
> 但是，仔细观察你会发现，虽然战场上有成千上万棵树，但它们的**种类**可能只有几种，比如“橡树”、“松树”和“白桦树”。这些同种类的树，它们的模型和纹理是完全一样的。真正让它们看起来不同的是它们各自的**位置(x, y, z坐标)、大小、生长朝向**等属性。
> 
> ==享元模式的核心思想，就是将对象中可以共享的部分（模型、纹理）与不可以共享的部分（位置、大小）分离开来==，然后让所有同类对象共享那一份不变的数据，从而极大地减少内存占用。

#### **享元模式精解**

> [!QUOTE] GoF 经典定义
> 
> ==运用共享技术来有效地支持大量细粒度的对象。== (Use sharing to support large numbers of fine-grained objects efficiently.)

==**核心思想**==：**内在状态 vs. 外在状态**
为了实现共享，享元模式将一个对象的状态划分为两个部分：

1. **内在状态 (Intrinsic State)**:
    - 这是存储在**享元对象内部**的，**不随环境改变而改变**的信息。
    - 它是可以被**共享**的。
    - 在我们的例子中，树的种类（“橡树”）、3D模型、纹理贴图就是内在状态。
        
2. **外在状态 (Extrinsic State)**:
    - 这是**依赖于具体场景**的，**随环境改变而改变**的信息。
    - 它**不可以被共享**，必须由客户端在每次调用享元对象时传递给它。
    - 在我们的例子中，一棵具体树的坐标、大小、颜色深浅就是外在状态。
        

**结构组成**：
1. **享元 (Flyweight)**: (e.g., `ITreeType`) 定义了享元对象的接口。通过这个接口，享元可以接收并作用于外在状态。
2. **具体享元 (Concrete Flyweight)**: (e.g., `TreeType`) 实现了享元接口，并存储了内在状态。**具体享元**的对象必须是可共享的。
3. **享元工厂 (Flyweight Factory)**: (e.g., `TreeFactory`) 负责创建和管理享元对象。当客户端请求一个享元时，工厂会检查池中是否已有可用的实例。如果有，就返回它；如果没有，就创建一个新的实例，存入池中，然后返回。这保证了享元实例的唯一性。
4. **客户端 (Client)**: (e.g., `Forest`) 负责计算或存储所有对象的外在状态。它从享元工厂获取享元对象，并在调用其方法时，将外在状态传递进去。

#### **C++ 实现享元模式 (完整可运行示例)**

我们将以刚刚的“森林”场景为例，来展示享元模式如何节省内存。

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>

// =================================================================
// 1. 享元 (Flyweight) 接口与具体享元 (Concrete Flyweight)
// TreeType 代表了可共享的部分。
// =================================================================
class TreeType {
private:
    // **== 内在状态 (Intrinsic State) ==**
    std::string m_name;
    std::string m_color;
    std::string m_texture;

public:
    TreeType(const std::string& name, const std::string& color, const std::string& texture)
        : m_name(name), m_color(color), m_texture(texture) {
        // 为了演示效果，每次创建新的享元对象时打印信息
        std::cout << "Creating new flyweight tree type: " << m_name << std::endl;
    }

    // 享元的操作方法，它接收外在状态作为参数
    void draw(const std::string& canvas, int x, int y) const {
        std::cout << "Drawing a " << m_name << " (" << m_color << ", " << m_texture << ") at (" << x << ", " << y << ") on canvas." << std::endl;
    }
};

// =================================================================
// 2. 享元工厂 (Flyweight Factory)
// 负责创建和管理享元对象。
// =================================================================
class TreeFactory {
private:
    // 使用 map 来存储已创建的享元池
    std::unordered_map<std::string, std::shared_ptr<TreeType>> m_treeTypes;

public:
    std::shared_ptr<TreeType> getTreeType(const std::string& name, const std::string& color, const std::string& texture) {
        // 使用一个组合键来唯一标识一种享元
        std::string key = name + "_" + color + "_" + texture;
        if (m_treeTypes.find(key) == m_treeTypes.end()) {
            m_treeTypes[key] = std::make_shared<TreeType>(name, color, texture);
        }
        return m_treeTypes[key];
    }
    
    void listStoredTypes() const {
        std::cout << "\nTreeFactory has " << m_treeTypes.size() << " flyweight types stored:" << std::endl;
        for (const auto& pair : m_treeTypes) {
            std::cout << "- " << pair.first << std::endl;
        }
    }
};

// =================================================================
// 3. 上下文 (Context)
// Tree 类存储了外在状态，并持有一个指向享元对象的引用。
// =================================================================
class Tree {
private:
    // **== 外在状态 (Extrinsic State) ==**
    int m_x;
    int m_y;
    // 指向共享的享元对象
    std::shared_ptr<const TreeType> m_type;
public:
    Tree(int x, int y, std::shared_ptr<const TreeType> type) : m_x(x), m_y(y), m_type(type) {}

    void draw(const std::string& canvas) const {
        m_type->draw(canvas, m_x, m_y);
    }
};

// =================================================================
// 4. 客户端 (Client)
// Forest 类负责管理所有的 Tree 对象。
// =================================================================
class Forest {
private:
    std::vector<Tree> m_trees;
    TreeFactory m_factory;

public:
    void plantTree(int x, int y, const std::string& name, const std::string& color, const std::string& texture) {
        // 从工厂获取共享的享元对象
        auto type = m_factory.getTreeType(name, color, texture);
        // 创建包含外在状态的上下文对象
        m_trees.emplace_back(x, y, type);
    }

    void draw(const std::string& canvas) const {
        std::cout << "\n--- Drawing forest on canvas ---" << std::endl;
        for (const auto& tree : m_trees) {
            tree.draw(canvas);
        }
    }

    void listTreeTypes() const {
        m_factory.listStoredTypes();
    }
};


int main() {
    Forest forest;
    
    std::cout << "--- Planting trees... ---" << std::endl;

    // 种植了5棵树，但只有2种类型
    forest.plantTree(10, 20, "Oak", "Green", "OakTexture.jpg");
    forest.plantTree(30, 50, "Pine", "Dark Green", "PineTexture.png");
    forest.plantTree(15, 80, "Oak", "Green", "OakTexture.jpg");
    forest.plantTree(100, 40, "Oak", "Green", "OakTexture.jpg");
    forest.plantTree(120, 150, "Pine", "Dark Green", "PineTexture.png");
    
    // 尽管我们创建了5个Tree对象，但实际上只创建了2个重量级的TreeType享元对象。
    forest.listTreeTypes();

    forest.draw("MainGameCanvas");
    
    return 0;
}
```

> [!TIP] 代码深度解析
> 
> 1. **状态分离**: 代码清晰地展示了状态的分离。`TreeType` 类只存储了共享的内在状态（名称、颜色、纹理）。而 `Tree` 类只存储了不共享的外在状态（x, y坐标），并持有一个指向共享 `TreeType` 对象的指针。
>     
> 2. **工厂的核心作用**: `TreeFactory` 是整个模式的关键。它的 `getTreeType` 方法确保了对于相同的内在状态组合（"Oak_Green_OakTexture.jpg"），永远只返回同一个 `std::shared_ptr<TreeType>` 实例。你可以从输出中看到 "Creating new flyweight tree type" 只被打印了两次。
>     
> 3. **巨大的内存节省**: 想象一下，如果 `TreeType` 是一个占用10MB内存的大家伙（包含模型、高清贴图等），我们种植10,000棵树。
>     
>     - **不使用享元模式**：内存占用 = 10,000 * 10MB = 100,000MB (约97GB) -> **灾难**。
>         
>     - 使用享元模式（假设只有2种树）：内存占用 ≈ (2 * 10MB) + (10,000 * sizeof(Tree)) -> 微不足道。sizeof(Tree) 只包含两个整数和一个共享指针的大小。
>         
>         这就是享元模式的威力所在。
>         

#### **优缺点总结**

> [!SUCCESS] 优点
> 
> - **极大地减少内存占用**：这是该模式最主要、最核心的优点。当系统中存在大量相似对象时，效果立竿见影。
>     
> - **提升性能**：由于减少了对象的创建数量，也可能带来CPU和时间的节省。
>     

> [!FAILURE] 缺点
> 
> - **增加了代码的复杂性**：你需要将对象的状态分解为内在和外在两部分，这会使得代码的逻辑比正常情况更复杂，也更难理解。
>     
> - **对客户端的要求更高**：客户端需要自己维护外在状态，并在调用享元方法时正确地传递它们。
>     
> - **适用场景有限**：`==享元模式是一种高度优化的模式，不应滥用==`。只有当“需要实例化的对象数量巨大”且“这些对象中大部分状态可以被外部化和共享”这两个条件同时满足时，才应该考虑使用它。
>     

#### **本章小结**

**==当你的程序需要创建大量相似的对象，并因此面临内存压力时，享元模式是解决问题的关键。==**

它通过一种精巧的状态分离和共享机制，用少量的共享对象（享元）来支撑海量的逻辑对象，是典型的用“时间”（每次调用时传递外在状态）换“空间”（节省大量内存）的设计典范。在游戏开发、图形处理、文本编辑器等领域，享元模式是不可或-缺的性能优化利器。

---

> [!TODO] 下一讲预告
> 
> 至此，我们已经学习了多个结构型模式。下一讲，我们将学习GoF结构型模式中的最后一个，也是非常重要的一个——代理模式 (Proxy Pattern)。它将为我们引入一个“替身”或“中介”的概念，来控制对另一个对象的访问。无论是实现懒加载、访问控制还是网络通信，代理模式都将为你提供一个优雅而强大的解决方案。敬请期待！