---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-08 14:26
Finish-date: 
Modified-date: 2025-08-08 14:36
Publish: false
---

在C/C++中计算一个结构体或类的大小，我们主要使用 `sizeof` 运算符。但这背后远不止一个简单的数字相加，它遵循着一套复杂但非常重要的规则，其中最核心的就是**内存对齐（Memory Alignment）**。

我的讲解会分为三个部分：
1. **基本工具：`sizeof` 运算符**

2. **核心规则：内存对齐的三大原则**

3. **特殊情况：类相关的其他因素（如虚函数、继承等）**



### 1. 基本工具：`sizeof` 运算符

`sizeof` 是一个在**编译时**进行求值的运算符，而不是一个函数。它返回一个对象或类型在内存中所占用的字节数，其结果类型是 `size_t`。

对于一个简单的结构体，我们可能会直观地认为其大小就是所有成员大小的总和，但事实并非如此。

例如：
```cpp
struct S {
    char c; // 1字节
    int i;  // 4字节
};
```

直观计算是 `1 + 4 = 5` 字节。但如果你在大部分平台（如x86/x64）上执行 `sizeof(S)`，会发现结果是 **8**。这就是由内存对齐导致的。

---

### 2. 核心规则：内存对齐 (Memory Alignment)

编译器为了提升CPU访问内存的效率，会按照一定的规则对结构体成员进行对齐。CPU访问一个未对齐的数据可能需要两次或更多的内存总线周期，而对齐的数据通常只需要一次。这就是对齐的根本原因。

对齐规则通常可以总结为以下三条黄金原则：

==原则1：成员对齐==
结构体中每个成员的起始地址，必须是该成员自身对齐值的整数倍。
- 一个成员的“自身对齐值”通常是其数据类型的大小。例如 `char` 是1，`short` 是2，`int` 是4，`double` 是8。
- 在某些平台上，也可以通过 `#pragma pack(n)` 或编译选项来指定一个“指定对齐值”，此时成员的对齐值取其**自身对齐值**和**指定对齐值**中的**较小者**。


==原则2：整体对齐==
结构体最终的总大小，必须是其所有成员中最大对齐值的整数倍。这个最大的对齐值也称为该结构体的“对齐模数”。


==原则3：填充 (Padding)==
为了满足以上两个原则，编译器会在成员之间以及结构体的末尾填充一些空白字节（Padding Bytes）。

我们来手动计算一下刚才的例子 struct S：

假设在x64系统上，默认对齐。
```cpp
struct S {
    char c; // 占1字节，对齐值为1
    int i;  // 占4字节，对齐值为4
};
```

1. **处理 `char c`**:
    - 大小为1，对齐值为1。放置在偏移量0处。当前结构体大小为1。
        
2. **处理 `int i`**:
    - 大小为4，对齐值为4。下一个可用的偏移量是1，但1不是4的整数倍。
    - **触发填充**：编译器必须填充3个字节，使得 `i` 的起始偏移量达到4。
    - `i` 被放置在偏移量4处，占用4、5、6、7四个字节。当前结构体大小为 `1 (c) + 3 (padding) + 4 (i) = 8`。

3. **应用原则2（整体对齐）**:
    - 所有成员中，最大的对齐值是 `int` 的4。
    - 当前总大小为8，8是4的整数倍，满足整体对齐原则。
    - 因此，`sizeof(S)` 的最终结果是 **8**。


**一个更复杂的例子：**
```cpp
struct Example {
    char a;    // 1字节，对齐1
    double d;  // 8字节，对齐8
    int i;     // 4字节，对齐4
};
```

1. `char a`: 放在偏移0处。当前大小1。
2. `double d`: 对齐值为8。下一个偏移量是1，不是8的倍数。需填充7个字节。`d` 放在偏移8处。当前大小 `1 + 7 + 8 = 16`。
3. `int i`: 对齐值为4。下一个偏移量是16，是4的倍数。`i` 放在偏移16处。当前大小 `16 + 4 = 20`。
4. **整体对齐**: 最大对齐值是 `double` 的8。当前大小20不是8的倍数。需在末尾填充4个字节，凑够24。
5. 最终大小为 **24** 字节。


**优化提示**：合理安排成员顺序可以减小结构体大小。将对齐值大的成员放在前面，通常能减少填充。如果将 `Example` 重新排序为 `double, int, char`，其大小会是 `8 + 4 + 1 + 3(padding) = 16` 字节。



### 3. 特殊情况：类 (Class)

对于C++的 `class`，计算大小的规则与 `struct` 基本相同，但需要额外考虑几个C++特有的因素：

1. **成员函数与静态成员**：
    - **普通成员函数**：不占用对象的内存空间。它们存储在代码段，所有对象共享。
    - **静态成员变量 (static)**：不占用对象的内存空间。它们存储在全局/静态数据区。
    - 因此，这两者都**不计入** `sizeof` 的结果。

2. **空类/空结构体**：
    - `sizeof(EmptyClass)` 的结果通常是 **1**。这是为了确保空类的两个不同实例在内存中有不同的地址，否则无法将它们区分开。

3. **虚函数 (Virtual Functions)**：
    - 如果一个类包含任何虚函数（无论是自己声明的还是继承的），编译器会为该类的每个对象实例添加一个**虚函数指针 (vptr)**。
    - 这个vptr的大小等于一个指针的大小（32位系统下4字节，64位系统下8字节）。
    - 所以，`sizeof` 的结果会**至少增加一个指针的大小**。

4. **继承**：
    - **单继承**：派生类的大小约等于基类大小 + 派生类新增成员大小（同样要考虑内存对齐）。
    - **多继承**：情况更复杂，可能包含多个vptr（如果多个基类都有虚函数），且基类成员的布局顺序和对齐会更复杂。
    - **虚继承**：为了解决菱形继承问题，虚继承会引入一个**虚基类指针 (vbptr)**，这会进一步增加对象的大小，其具体大小和实现方式是编译器相关的，通常比普通继承更复杂。


### 总结
面试官，总结一下，计算C/C++结构体或类的大小，核心是理解`sizeof`背后的**内存对齐**机制，并牢记**成员对齐**和**整体对齐**两大原则。在此基础上，对于类还需要考虑**vptr**带来的额外开销，同时要明确**成员函数和静态成员不计入对象大小**。这是一个综合性的考察点，体现了对C++内存模型和对象布局的深入理解。