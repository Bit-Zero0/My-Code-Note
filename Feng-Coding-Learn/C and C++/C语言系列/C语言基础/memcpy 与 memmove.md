---
Modified-date: 2025-08-08 15:10
---


### 1. `memcpy`：最直接的内存复制

`memcpy` 的设计思想是“快”，它不做任何多余的检查，只是简单地、一个字节一个字节地把数据从源头 `src` 搬到目的地 `dest`。

#### `memcpy` 的一种简单实现：

C

```
// 一个简化的 memcpy 实现
void* my_memcpy(void* dest, const void* src, size_t count) {
    // 把 void* 指针转成 char*，方便按字节操作
    char* p_dest = (char*)dest;
    const char* p_src = (const char*)src;

    // 从前向后，一个字节一个字节地复制
    for (size_t i = 0; i < count; ++i) {
        p_dest[i] = p_src[i];
    }
    
    return dest;
}
```

讲解：

这个实现非常直接，就是一个 for 循环，从 i = 0 开始，把 src 的第 i 个字节，复制到 dest 的第 i 个字节，直到复制完 count 个字节。我们称之为“从前向后”的复制。

#### 这种实现什么时候会出问题？—— 内存重叠

“内存重叠”指的是，你要复制的目标地址 `dest` 和源地址 `src` 在内存上有一部分是交叉的。

让我们来看一个失败的例子：

假设我们有一个数组 char data[] = {'A', 'B', 'C', 'D', 'E'};，我们想把前3个元素 'A', 'B', 'C' 复制到 data[2] 的位置，也就是把 'C', 'D', 'E' 替换掉。

- 源地址 `src` 是 `&data[0]`。
    
- 目标地址 `dest` 是 `&data[2]`。
    
- 复制长度 `count` 是 `3`。
    

**内存初始状态**：

```
地址:  0   1   2   3   4
内容: 'A' 'B' 'C' 'D' 'E'
       ^-------^         (这是源 src)
           ^-------^     (这是目标 dest)
```

你可以看到，`src` 的一部分（`'C'`）和 `dest` 的一部分重叠了。

现在，我们用上面的 `my_memcpy` 来执行这个操作：

- **第1步 (i=0)**:
    - `p_dest[0] = p_src[0]`，也就是 `data[2] = data[0]`。
    - 内存变为: `'A' 'B' 'A' 'D' 'E'`
    - **问题出现！** 我们把原来的 `'C'` 覆盖掉了，但我们后面还需要用到它（因为它是 `src` 的一部分）。

- **第2步 (i=1)**:
    - `p_dest[1] = p_src[1]`，也就是 `data[3] = data[1]`。
    - 内存变为: `'A' 'B' 'A' 'B' 'E'`

- **第3步 (i=2)**:
    - `p_dest[2] = p_src[2]`，也就是 `data[4] = data[2]`。
    - **关键错误！** 我们现在要读取 `p_src[2]` (也就是原来的 `'C'`)，但是这个位置在第1步已经被我们修改成了 `'A'`。所以我们读取到的是 `'A'`。
    - `data[4]` 被赋值为 `'A'`。
    - 内存变为: `'A' 'B' 'A' 'B' 'A'`

**最终结果是 `{'A', 'B', 'A', 'B', 'A'}`，而我们期望的结果是 `{'A', 'B', 'A', 'B', 'C'}`。**

这就是 `memcpy` 在内存重叠时会失败的原因：**它在复制过程中，可能会把后面需要用到的“源数据”给提前覆盖掉。**



### 2. `memmove`：更安全的内存移动

`memmove` 的设计思想是“安全”，它要确保即使在内存重叠的情况下，结果依然是正确的。

#### `memmove` 的一种简单实现：

它的实现精髓在于，它会先**判断内存是否重叠以及如何重叠**，然后**选择不同的复制方向**。

```cpp
// 一个简化的 memmove 实现
void* my_memmove(void* dest, const void* src, size_t count) {
    char* p_dest = (char*)dest;
    const char* p_src = (const char*)src;

    // 判断：如果目标地址在源地址之后，并且发生了重叠
    // 那么从后向前复制
    if (p_dest > p_src && p_dest < p_src + count) {
        // 从后向前复制
        for (size_t i = count; i > 0; --i) {
            p_dest[i-1] = p_src[i-1];
        }
    } else {
        // 否则，从前向后复制（和memcpy一样）
        for (size_t i = 0; i < count; ++i) {
            p_dest[i] = p_src[i];
        }
    }
    
    return dest;
}
```

讲解：
memmove 的核心是一个 if 判断。
1. `p_dest > p_src`: 检查目标地址是否在源地址的后面。
2. `p_dest < p_src + count`: 检查目标地址是否“侵入”了源数据块的范围。

只有当这两个条件**同时满足**时（这正是我们上面那个失败的例子的情况），`memmove` 就会选择“**从后向前**”的复制策略。

#### 让我们用 `my_memmove` 重新执行失败的例子：

**内存初始状态**：
```
地址:  0   1   2   3   4
内容: 'A' 'B' 'C' 'D' 'E'
```

`my_memmove` 检测到 `p_dest > p_src` 且有重叠，于是选择**从后向前**复制：
- **第1步 (i=3)**:
    - `p_dest[2] = p_src[2]`，也就是 `data[4] = data[2]`。
    - `'C'` 被复制到了 `data[4]` 的位置。
    - 内存变为: `'A' 'B' 'C' 'D' 'C'`
    - **安全**：我们先复制了源数据的最后一个字节，没有影响到前面的源数据。

- **第2步 (i=2)**:
    - `p_dest[1] = p_src[1]`，也就是 `data[3] = data[1]`。
    - `'B'` 被复制到了 `data[3]` 的位置。
    - 内存变为: `'A' 'B' 'C' 'B' 'C'`

- **第3步 (i=1)**:
    - `p_dest[0] = p_src[0]`，也就是 `data[2] = data[0]`。
    - `'A'` 被复制到了 `data[2]` 的位置。
    - 内存变为: `'A' 'B' 'A' 'B' 'C'`


**最终结果是 `{'A', 'B', 'A', 'B', 'C'}`，完全正确！**

通过选择正确的复制方向，`memmove` 保证了在复制完成前，任何需要被读取的源数据都不会被提前覆盖。


### 三、总结

|对比项|`memcpy`|`memmove`|
|---|---|---|
|**核心思想**|**快**，性能优先|**安全**，结果正确性优先|
|**内存重叠**|**不允许**。如果发生重叠，结果是未定义的（很可能会出错）。|**允许**。可以安全地处理内存重叠。|
|**实现方式**|总是从一个方向复制（通常是从前向后）。|会先判断内存是否重叠，然后根据情况选择从前向后，还是从后向前复制。|
|**使用场景**|当你**100%确定**源和目标内存**不会重叠**时使用，可以获得最佳性能。|当你**不确定**内存是否会重叠，或者**明确知道会重叠**时，**必须**使用它来保证程序的正确性。|

简单来说，`memmove` 是 `memcpy` 的一个更安全、更“聪明”的版本。为了这点安全性，它增加了一个小小的判断，可能会有微不足道的性能损失。在现代软件开发中，除非是在对性能要求极致且能保证无重叠的场景，否则**优先考虑使用 `memmove` 是一个更稳妥的选择**。