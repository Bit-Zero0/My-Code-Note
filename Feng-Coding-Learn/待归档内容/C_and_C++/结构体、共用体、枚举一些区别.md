---
Type: Note
tags:
  - C
Status: writing
Start-date: 2025-08-08 15:19
Finish-date: 
Modified-date: 2025-08-08 15:50
Publish: false
---
好的，我们来详细梳理一下C/C++中结构体（`struct`）、共用体（`union`，也叫联合体）和枚举（`enum`）这三者的区别。它们是三种完全不同的用户自定义类型，各自有清晰的用途和内存模型。

我将通过一个对比表格和详细的讲解来阐述。

### 核心区别对比表

|特性|结构体 (struct)|共用体 (union)|枚举 (enum)|
|---|---|---|---|
|**核心功能**|将**不同类型**的数据捆绑成一个逻辑单元。|在**同一块内存**中存储**不同类型**的数据（但任一时刻只有一个有效）。|创建一组有名称的**整数常量**。|
|**数据存储**|所有成员**同时存在**，各自拥有独立的内存空间。|所有成员**共享同一块**起始内存地址。|定义一组命名的整数值，本身不聚合存储不同数据。|
|**内存分配**|“与”关系（AND）：一个对象包含成员A **和** 成员B **和** ...|“或”关系（OR）：一个对象是成员A **或** 成员B **或** ...|“是”关系（IS）：一个对象的值**是**常量A **或** 常量B **或** ...|
|**大小计算 (`sizeof`)**|所有成员大小之和（需要考虑内存对齐的填充字节）。|**最大成员**的大小。|通常等于一个`int`的大小（具体由编译器决定）。|
|**典型用途**|描述一个具有多个属性的复杂实体，如“学生”（有学号、姓名、年龄）。|为节省内存，在多个类型中只选择一个使用，如解析数据包；进行底层类型转换。|定义一组有限的状态、选项或类别，如“颜色”（红、绿、蓝）。|

---

### 详细讲解与示例

#### 1. 结构体 (struct) - “打包”

结构体的目的是将一堆相关的变量“打包”成一个单一的、有逻辑意义的整体。它的所有成员都是**同时有效**的。

内存模型：

结构体的每个成员在内存中都有自己专属的位置，它们按顺序排列（但中间可能因内存对齐被编译器插入一些填充字节）。

**代码示例**：
```cpp
#include <iostream>

// 定义一个“学生”结构体
struct Student {
    int id;
    char name[20];
    float gpa;
};

int main() {
    Student s;
    s.id = 101;
    strcpy(s.name, "Alice");
    s.gpa = 3.8f;

    // 所有成员都可以同时访问，它们的值互不影响
    std::cout << "ID: " << s.id << std::endl;
    std::cout << "Name: " << s.name << std::endl;
    std::cout << "GPA: " << s.gpa << std::endl;

    // 大小是所有成员大小之和 + 填充字节
    // 可能是 4 (id) + 20 (name) + 4 (gpa) = 28，或因对齐更大
    std::cout << "sizeof(Student): " << sizeof(Student) << std::endl;
}
```

**总结**：`struct` 是为了表示一个包含**多个属性**的“对象”。



#### 2. 共用体 (union) - “共享”

共用体的核心特点是其所有成员**共享同一块内存空间**。这意味着，你可以在这块内存里存一个`int`，或者存一个`float`，或者存一个`char`数组，但你**不能同时存**。给一个成员赋值会**覆盖**掉其他成员的值。

内存模型：

共用体的大小由其最大的成员决定。所有成员的地址都是从同一个起始点开始的。

**代码示例**：
```cpp
#include <iostream>

// 定义一个可以存储不同类型值的共用体
union Data {
    int i;
    float f;
    char str[4];
};

int main() {
    Data data;
    
    data.i = 65; // 存入一个整数
    std::cout << "As integer: " << data.i << std::endl;
    // 此时，如果以char的形式访问，会得到整数65的内存表示
    // 65 在ASCII码中是 'A'
    std::cout << "As char[0]: " << data.str[0] << std::endl; 

    std::cout << "---" << std::endl;

    data.f = 3.14f; // 存入一个浮点数，这会覆盖掉原来的整数
    std::cout << "As float: " << data.f << std::endl;
    // 此时，如果以整数形式访问，会得到一个无意义的值
    // 因为你正在解释浮点数的二进制位
    std::cout << "As integer (after float assignment): " << data.i << std::endl;

    // 大小由最大的成员决定，这里是 float（4字节）和 char[4]（4字节）
    // 所以大小是4
    std::cout << "sizeof(Data): " << sizeof(Data) << std::endl;
}
```

编程实践：

因为无法知道当前哪个成员是有效的，所以 union 通常会和一个 enum 配合使用，用一个额外的标签来记录当前存储的是哪种类型的数据，这是一种非常常见的模式。

**总结**：`union` 是为了在**多个类型中选一个**来使用，核心目的是**节省内存**或进行底层位操作。


#### 3. 枚举 (enum) - “常量集合”

枚举与前两者完全不同，它**不是用来聚合数据的**。它的目的是创建一种新的**整数类型**，并为该类型定义一组有意义的、可读性强的**命名常量**。

内存模型：

一个枚举变量的大小就是一个整数的大小（通常是sizeof(int)）。它本身不存储复杂结构。

**代码示例（传统 vs. 现代C++）**：

在C++11之后，强烈推荐使用**作用域枚举 `enum class`**，因为它更安全。
```cpp
#include <iostream>

// 传统 C 风格枚举
enum Color { RED, GREEN, BLUE }; // RED=0, GREEN=1, BLUE=2

// C++11 作用域枚举 (推荐)
enum class Shape { CIRCLE, SQUARE, TRIANGLE };

void printColor(Color c) {
    if (c == RED) {
        std::cout << "Color is RED" << std::endl;
    }
}

int main() {
    Color myColor = RED;
    printColor(myColor);

    // 传统枚举的常量会污染全局命名空间
    // int x = GREEN; // 可以隐式转换为int

    // 作用域枚举的常量必须通过作用域访问，更安全
    Shape myShape = Shape::CIRCLE;
    // int y = Shape::SQUARE; // 编译错误！不能隐式转换为int
    
    if (myShape == Shape::CIRCLE) {
        std::cout << "Shape is CIRCLE" << std::endl;
    }
}
```

**总结**：`enum` 是为了定义一组相关的**命名常量**，以增强代码的可读性和类型安全，常用于表示**状态**或**类别**。