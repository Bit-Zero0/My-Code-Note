---
Type: Note
tags:
  - 计组
Status: writing
Start-date: 2024-06-26 21:28
Finish-date: 
Modified-date: 2024-06-26 21:29
Publish: false
---

# 进位计数制

![[Pasted image 20240626204735.png]]


## 十进制计数法

$$975.36$$
$$
9×100 + 7×10 + 5×1 + 3×0.1+6×0.01$$
$$ 9×10^2 + 7×10^1 + 5× 10^0 + 3× 10^{-1} + 3× 10^{-2}$$

十进制：
$$ 
\begin{multline}
K_{n} K_{n-1}... K_2 K_1 K_0 K_{-1} K_{-2} ... K_{-m} \\
==K_{n} \times 10^{n} + K_{n-1} \times 10^{n-1} + ... + K_2\times 10^{2}+ K_1\times 10^{1} +  K_0 \times 10^{0} + K_{-1} \times 10^{-1}+  K_{-2}\times 10^{-2}+ ... + K_{-m} \times 10^{-m} 
\end{multline}
$$


有0~9，共十种符号。
> 逢十进一

## r 进制计数法
![[Pasted image 20240626211412.png]]

二进制: 0, 1

八进制： 0,1,2,3,4,5,6,7
十进制： 0,1,2,3,4,5,6,7,8,9
十六进制： 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F

> [!info]+ 二进制只有0和1的好处
> 1. 可使用两个稳定状态的物理器件表示
> 2. `0`，`1` 正好对应逻辑值假、真。方便实现逻辑运算
> 3. 可很方便地使用逻辑门电路实现算术运算


> 二进制： $101.1 —> 1 × 2^{2} + 0 × 2^{1} + 1 × 2^{0} + 1 × 2^{-1} = 5.5$
>八进制： $5.4 —> 5 × 8^{0} + 4 × 8^{-1} = 5.5$
>十进制： $5.5 —> 5 × 10^{0} + 5 × 10^{-1} = 5.5$
>十六进制：5.8 —> 5 × 16^{0} + 8 × 16^{-1} = 5.5


## 任意进制转换十进制

![[Pasted image 20240626211900.png]]


![[Pasted image 20240626211918.png]]


## 二进制转换八进制, 十六进制

![[Pasted image 20240626211956.png]]


## 各种进制的常见书写方法

![[Pasted image 20240626212129.png]]


## 十进制转换任意进制

方法：
整数部分采用“除基取余法”
小数部分采用“乘基取整法”
![[Pasted image 20240626212300.png]]
![[Pasted image 20240626212537.png]]


### 十进制转换二进制(拼凑法)

十进制：260.75、533.125

![[Pasted image 20240626212630.png]]


## 真值和机器数
真值：符合人类习惯的数字
机器数：数字实际存到机器里的形式，正负号需要被“数字化”

![[Pasted image 20240626212736.png]]

## 小结
![[Pasted image 20240626212756.png]]
> [!warning]+ 注意
> 注意：有的十进制小数无法用二进制精确表示，如：0.3


# 定点数的表示
定点数：小数点的位置固定
浮点数：小数点的位置不固定

>定点数 Eg：996.007 ——常规计数
>浮点数 Eg：$9.96007*10^2$ ——科学计数法


二进制的定点数、浮点数也类似

本节总览
![[Pasted image 20240626214104.png]]

# 无符号数的表示
> [!info]+ 
> 通常只有无符号整数，而没有无符号小数

无符号数：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。

![[Pasted image 20240626214150.png]]

![[Pasted image 20240626214207.png]]

# 有符号数的表示
![[Pasted image 20240626214330.png]]

## 有符号数的定点表示
![[Pasted image 20240626214408.png]]
注：可用<mark style="background: #FF5582A6;">原码</mark>、<mark style="background: #FF5582A6;">反码</mark>、<mark style="background: #FF5582A6;">补码</mark>三种方式来表示定点整数和定点小数。还可用<mark style="background: #FF5582A6;">移码</mark>表示定点整数。

若真值为x，则用 $[x]_原$、$[x]_反$、$[x]_补$、$[x]_移$ 分别表示真值所对应的原码、反码、补码、移码


### 原码
- **作用**：原码是最直观的表示法，它将数字的绝对值直接按照二进制表示，最高位用来表示符号（0表示正，1表示负）。例如，+7和-7在一个字节的系统中分别表示为`0111`和`1111`。
- **应用场景**：虽然原码很直观，但它处理加减运算较为复杂，特别是在考虑到有两个零（+0和-0）的情况下。因此，原码主要用于教学和理论分析。

![[Pasted image 20240626214711.png]]

![[Pasted image 20240626214807.png]]
常写为：$[x]_原$=1,0010011
若未指明机器字长，也可写为：$[x]_原$=1, 10011


![[Pasted image 20240626214923.png]]
常写为：$[x]_原$= 1.1100000



如：机器字长为8位

整数原码
![[Pasted image 20240626215015.png]]


小数原码
![[Pasted image 20240626215051.png]]
### 反码
> [!info]+ 反码
> 若符号位为0，则反码与原码相同
> 若符号位为1，则数值位全部取反
- **作用**：反码用于解决原码表示负数时的一些问题。正数的反码与其原码相同，负数的反码是其原码除符号位外所有位取反。例如，-7的反码是`1000`（假设一个字节系统）。
- **应用场景**：反码简化了负数的表示，但在进行加减运算时仍存在问题，如需要处理端借位和两种零的表示。

> [!tip]+ 
> “反码”只是“原码”转变为“补码”的一个中间状态，实际中并没什么卵用




![[Pasted image 20240626215401.png]]


### 补码
- **作用**：补码是目前计算机系统中最广泛使用的数字表示方法。它不仅解决了反码的问题，还简化了加减运算。补码的获取方式是取其反码然后加1。例如，-7在补码系统中表示为`1001`。
- **应用场景**：补码被广泛用于计算机系统中，因为它使得加减运算可以统一处理，无需考虑操作数的符号，也解决了两种零的问题。
![[Pasted image 20240626215444.png]]


### 移码
- **作用**：移码是另一种表示负数的方法，通过给所有数值加上一个偏移量（或称为偏置）来表示。最常见的例子是浮点数的指数部分使用的编码方式，偏移量通常是2的n-1次方，其中n是指数位数。
- **应用场景**：移码主要用于浮点数的表示，它使得浮点数的指数部分可以使用标准的无符号数排序算法进行比较和排序，简化了浮点数的处理逻辑。
![[Pasted image 20240626215516.png]]


![[Pasted image 20240626220339.png]]

## 用几种码表示定点整数
![[Pasted image 20240626220355.png]]



## 小结
![[Pasted image 20240626220617.png]]

![[Pasted image 20240626220625.png]]


# 各种码的作用

## 加减运算
![[Pasted image 20240626220744.png]]

### 用加法代替减法

![[Pasted image 20240626220912.png]]

### 模运算的性质
![[Pasted image 20240626220929.png]]

![[Pasted image 20240626221428.png]]

溢出的结果
![[Pasted image 20240626221641.png]]



# C语言中的强制类型转换
## 强制类型转换
![[Pasted image 20240626221825.png]]

# 零扩展 与 符号扩展

![[Pasted image 20240626221943.png]]

- ALU的位数是固定的，运算前可能需要把短数据扩展为长数据
- 通用寄存器位数是固定的，把数据存入寄存器时，可能需要进行长度扩展
- 主存内的各种数据长度不一，有时需要把短数据扩展为长数据


> [!question]+ 问题
> 将8bit短数据 -> 16bit长数据，多出来的那些位应该怎么填补？
## 零扩展
零扩展：**适用于==无符号整数==**，用0扩展高位
![[Pasted image 20240626222053.png]]


## 符号扩展
符号扩展：**适用于==带符号整数(补码)==**，用“符号位”扩展高位
![[Pasted image 20240626222245.png]]




































# 总结
