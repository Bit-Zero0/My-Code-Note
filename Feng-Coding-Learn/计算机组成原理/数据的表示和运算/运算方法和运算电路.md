---
Type: Note
tags:
  - 计组
  - 数字电路
Status: writing
Start-date: 2024-06-27 15:02
Finish-date: 
Modified-date: 2024-06-28 22:40
Publish: false
---




# 逻辑门电路 
> [!tip] 这一小节属于补充知识：数字电路基础知识
> 学过数字电路的同学可以跳过本小节


## 本节总览

![[Pasted image 20240627150555.png]]

## 算数运算 V.S 逻辑运算

算数运算——对我们熟悉的数字进行运算，如：加、减、乘、除、幂次方
> 加、减、乘、除 : 基本算数运算
> 幂次方 : 复合算数运算




逻辑运算——对逻辑值真/假（二进制1/0）进行运算，如：与、或、非、异或
> 与、或、非 : 基本逻辑运算
> 异或 : 复合逻辑运算

> [!warning]+ 注意
> 注1：无论是算数运算、还是逻辑运算，都要有输入、输出。
> 注2：《离散数学》是专门研究逻辑运算的一门数学学科。


## 基本逻辑运算：与
![[Pasted image 20240627150846.png]]



## 基本逻辑运算：或
![[Pasted image 20240627150855.png]]


## 基本逻辑运算：非
![[Pasted image 20240627150913.png]]

## 复合逻辑运算：与非

![[Pasted image 20240627150925.png]]

## 复合逻辑运算：或非
![[Pasted image 20240627150933.png]]


## 复合逻辑运算：异或
![[Pasted image 20240627160608.png]]


## 复合逻辑运算：同或
![[Pasted image 20240627151131.png]]


## 逻辑运算的优先级、常见公式
![[Pasted image 20240627151446.png]]



## 额外小知识
异或运算的妙用：n bit进行异或，若有奇数个1，则异或结果为1；若有偶数个1，则异或结果为0
![[Pasted image 20240627151252.png]]


## 门电路的变形画法

![[Pasted image 20240627151344.png]]

> [!note]+ 拓展：芯片制程
> ![[Pasted image 20240627151630.png]]


## 小结

![[Pasted image 20240627160110.png]]


# 多路选择器 和 三态门

## 多路选择器(MUX)
![[Pasted image 20240627155755.png]]
多路选择器（multiplexer，MUX）作用：电路的“守门员”。在多个输入数据中，只允许其中一个数据通过MUX。

图形：通常用“梯形”表示，有多个输入、一个输出、一个控制信号（梯形的更长的一边是输入端、更短的一边是输出端）

若有𝑘 个输入，则控制信号的位数 $m ≥ \left\lceil  log_2 𝑘 \right\rceil$ 𝑏𝑖𝑡

注：在电路图中，控制信号常用英文缩写“XXXop”表示，图形常用“虚线箭头


![[Pasted image 20240627155813.png]]

## 三态门

![[Pasted image 20240627155852.png]]

三态门
作用：电路的“守门员”。根据控制信号决定是否让输入的数据通过。

图形：小三角。有一个输入、一个输出、一个控制信号。

三态门的控制信号通常只需要1bit。op=1表示允许数据通过；op=0表示不允许数据通过。

### 初学者提示：三态门 vs 非门
![[Pasted image 20240627155934.png]]

==核心区别：“非门”没有控制信号！只有输入和输出==


## 小结
![[Pasted image 20240627160029.png]]


# 加法器
![[Pasted image 20240627160214.png]]

## 加法器的基本功能
![[Pasted image 20240627160317.png]]
例：7+12=19
用8bit表示被加数A、加数B、和S

### 如何用门电路实现一位加法？

![[Pasted image 20240627160417.png]]



## 一位全加器

![[Pasted image 20240627161013.png]]


## n bit加法器
![[Pasted image 20240627161046.png]]
串行进位的并行加法器：把n个全加器串接起来，就可进行两个n位数的相加。

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。

> [!info]+ 不足之处
> ![[Pasted image 20240627161316.png]]
> 进位信息是串行产生的，计算速度取决于进位产生和传递的速度。位数越多，运算速度越慢。
> 
> 注1：电信号到达稳态需要一定时间，因此进位产生速度会有延迟。
> 注2：串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。
> 
> 由于两个输入端允许并行输入n bit，因此这种加法器属于：并行加法器
> 由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器
> 综上，很多教材把这种加法器称为“串行进位的并行加法器”


## 并行进位的并行加法器
![[Pasted image 20240627161428.png]]
并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。
特点：运算速度比“串行进位的并行加法器”更快。

## 带标志位的加法器
![[Pasted image 20240627161603.png]]

OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=0 未溢出
SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=0 结果为正
ZF（Zero Flag)零标志，用于判断加减运算结果是否为0。ZF=1 表示结果为0；ZF=0 表示结果不为0
CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出


### 标志位的生成
![[Pasted image 20240627161702.png]]


# 小结
![[Pasted image 20240627162304.png]]



# 并行进位加法器

复习[[运算方法和运算电路#n bit加法器|串行进位的并行加法器]]

![[Pasted image 20240627162723.png]]

## 如何更快的产生进位?

![[Pasted image 20240627162816.png]]

结论：第i位向更高位的进位$C_i$可根据被加数、加数的第1~i位,再结合$C_0$即可确定

### 并行加法器的优化
![[Pasted image 20240627163224.png]]

并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位


# 算术逻辑单元 ALU

![[Pasted image 20240627164035.png]]


## 算术逻辑单元（ALU）的作用

![[Pasted image 20240627164056.png]]

CPU由控制器、运算器组成

控制器负责解析指令，并根据指令功能发出相应的控制信号（将在计组第五章详细学习）

运算器负责对数据进行处理，如：加减乘除等。

ALU是一种组合逻辑电路，实现了加/减/乘/除、与/或/非等功能。因此ALU是运算器的核心。

由于加减乘除等运算都要基于“加法”来实现，因此加法器是ALU的核心。


## ALU的功能
![[Pasted image 20240627164139.png]]


## ALU的实现原理
（简单了解即可）
![[Pasted image 20240627164204.png]]

[[运算方法和运算电路#多路选择器(MUX)]]

## 看懂ALU图示
![[Pasted image 20240627164325.png]]



## 小结
![[Pasted image 20240627164632.png]]



# 定点数的移位运算

![[Pasted image 20240627230135.png]]

## 算术移位
![[Pasted image 20240627230207.png]]

移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法
### 原码的算术移位
右移
![[Pasted image 20240627230249.png]]
![[Pasted image 20240627230415.png]]
原码的算数移位——符号位保持不变，仅对数值位进行移位。
右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度
左移：低位补0，高位舍弃。若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差




![[Pasted image 20240627230529.png]]


### 反码的算术移位
![[Pasted image 20240627230604.png]]
反码的算数移位——正数的反码与原码相同，因此对==正数反码的移位运算也和原码相同==。
右移：高位补0，低位舍弃。
左移：低位补0，高位舍弃。

反码的算数移位——负数的反码数值位与原码相反，因此==负数反码的移位运算==规则如下，
右移：高位补1，低位舍弃。
左移：低位补1，高位舍弃。


### 补码的算术移位
补码的算数移位——正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。
右移：高位补0，低位舍弃。
左移：低位补0，高位舍弃。

补码的算数移位——负数补码=反码末位+1 , 导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。
规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码
负数补码的算数移位规则如下：
右移（同反码）：高位补1，低位舍弃。
左移（同原码）：低位补0，高位舍弃。

![[Pasted image 20240627230825.png]]



算术移位小结
![[Pasted image 20240627230901.png]]


### 算数移位的应用举例
![[Pasted image 20240627231000.png]]


## 逻辑移位
![[Pasted image 20240627231051.png]]
逻辑右移：高位补0，低位舍弃。
逻辑左移：低位补0，高位舍弃。

可以把逻辑移位看作是对“无符号数”的算术移位

### 逻辑移位的应用举例
![[Pasted image 20240627231211.png]]


## 循环移位
![[Pasted image 20240627231429.png]]

## 小结
![[Pasted image 20240627231446.png]]注意：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法

# 定点数的加减运算
![[Pasted image 20240628172240.png]]注：计算机中，不会用“反码”进行加减运算，因此不作探讨

## 原码的加减运算

![[Pasted image 20240628172326.png]]

## 补码的加减运算
![[Pasted image 20240628172351.png]]


对于补码来说，无论加法还是减法，最后都会转变成加法，由加法器实现运算，符号位也参与运算

## 补码加减法的溢出判断
![[Pasted image 20240628172541.png]]
![[Pasted image 20240628172650.png]]


![[Pasted image 20240628173147.png]]

![[Pasted image 20240628173153.png]]


## 小结
![[Pasted image 20240628173213.png]]


# 无符号数的加减运算
![[Pasted image 20240628173246.png]]

## 带符号数(补码)的加减法运算
![[Pasted image 20240628173305.png]]
带符号数（补码）的加法：从最低位开始，按位相加（符号位参与运算），并往更高位进位

![[Pasted image 20240628173449.png]]
带符号数（补码）的减法：
①“被减数”不变，“减数”全部位按位取反、末位+1，减法变加法
② 从最低位开始，按位相加，并往更高位进位


## 无符号数的加减法运算

![[Pasted image 20240628173626.png]]
无符号整数的加法：从最低位开始，按位相加，并往更高位进位

![[Pasted image 20240628173733.png]]
计算机硬件如何做无符号整数的减法：
①“被减数”不变，“减数”全部位按位取反、末位+1，减法变加法
② 从最低位开始，按位相加，并往更高位进位


## 无符号数加减法的溢出判断
![[Pasted image 20240628173817.png]]
手算判断溢出的方法：n bit 无符号整数表示范围$0 \sim 2^n-1$，超出此范围则溢出

计算机判断溢出的方法：
>无符号数加法的溢出判断：最高位产生的进位=1时，发生溢出，否则未溢出。
>无符号数减法的溢出判断：减法变加法，最高位产生的进位=0时，发生溢出，否则未溢出。

![[Pasted image 20240628173921.png]]

![[Pasted image 20240628173930.png]]

## 小结
![[Pasted image 20240628174039.png]]


# 补码加减运算电路
![[Pasted image 20240628174242.png]]

![[Pasted image 20240628174442.png]]

![[Pasted image 20240628174919.png]]


![[Pasted image 20240628174943.png]]

> [!info]+ 回顾以下内容
> [[运算方法和运算电路#标志位的生成|标志位的生成]]   [[运算方法和运算电路#补码加减法的溢出判断|补码加减法的溢出判断]]  [[运算方法和运算电路#无符号数加减法的溢出判断|无符号数加减法的溢出判断]]





# 定点数原码乘法运算
![[Pasted image 20240628223256.png]]

## 手算乘法(十进制)
![[Pasted image 20240628223332.png]]

## 手算乘法(二进制)
![[Pasted image 20240628223446.png]]
考虑用机器实现：
- 实际数字有正负，符号位如何处理？
- 乘积的位数扩大一倍，如何处理？
- 4个位积都要保存下来最后统一相加？

## 原码一位乘法

![[Pasted image 20240628224400.png]]


#todo 复习 [[运算器的基本组成]]


![[Pasted image 20240628224413.png]]

![[Pasted image 20240628224321.png]]

![[Pasted image 20240628224350.png]]

![[Pasted image 20240628224427.png]]


![[Pasted image 20240628224517.png]]

![[Pasted image 20240628224613.png]]

![[Pasted image 20240628224629.png]]

![[Pasted image 20240628224653.png]]

![[Pasted image 20240628224706.png]]

![[Pasted image 20240628224721.png]]

![[Pasted image 20240628224736.png]]

![[Pasted image 20240628224904.png]]


## 原码一位乘法（手算模拟）

![[Pasted image 20240628225015.png]]

> [!tip]+ 
> - 乘数的符号位不参与运算，可以省略
> - 原码一位乘可以只用单符号位
> - 答题时最终结果最好写为原码机器数


# 定点数补码乘法运算

## 补码一位乘法
![[Pasted image 20240628225211.png]]
![[Pasted image 20240628225344.png]]



## 补码一位乘法(手算模拟)
![[Pasted image 20240628225511.png]]
注：一般来说，Booth算法的被乘数、部分积采用双符号位补码


## 小结
![[Pasted image 20240628225858.png]]


# 定点数原码除法运算
![[Pasted image 20240628225921.png]]

## 手算除法(十进制)

![[Pasted image 20240628225946.png]]




## 手算除法(二进制)

![[Pasted image 20240628230226.png]]

#todo 复习 [[运算器的基本组成]]
![[Pasted image 20240628230303.png]]


## 原码除法：恢复余数法

![[Pasted image 20240628230547.png]]
计算机很傻，会先默认上商1，如果
搞错了再改上商0。并“恢复余数”

![[Pasted image 20240628230646.png]]

![[Pasted image 20240628230704.png]]

![[Pasted image 20240628230831.png]]


![[Pasted image 20240628230905.png]]

![[Pasted image 20240628230932.png]]

![[Pasted image 20240628230944.png]]

![[Pasted image 20240628230954.png]]

![[Pasted image 20240628231003.png]]


![[Pasted image 20240628231100.png]]

![[Pasted image 20240628231142.png]]

![[Pasted image 20240628231231.png]]

![[Pasted image 20240628231259.png]]

![[Pasted image 20240628231315.png]]

![[Pasted image 20240628231334.png]]

![[Pasted image 20240628231426.png]]

![[Pasted image 20240628231437.png]]

![[Pasted image 20240628231459.png]]


## 原码除法：恢复余数法（手算）
![[Pasted image 20240628231611.png]]


![[Pasted image 20240628231631.png]]

## 原码除法：加减交替法
![[Pasted image 20240628231720.png]]

![[Pasted image 20240628232019.png]]


# 定点数补码除法运算

## 补码除法：加减交替法
![[Pasted image 20240628232105.png]]


## 除法运算总结回顾
![[Pasted image 20240628232129.png]]








