---
Type: Note
tags:
  - 计组
  - 数字电路
Status: writing
Start-date: 2024-06-27 15:02
Finish-date: 
Modified-date: 2024-06-27 16:48
Publish: false
---




# 逻辑门电路 
> [!tip] 这一小节属于补充知识：数字电路基础知识
> 学过数字电路的同学可以跳过本小节


## 本节总览

![[Pasted image 20240627150555.png]]

## 算数运算 V.S 逻辑运算

算数运算——对我们熟悉的数字进行运算，如：加、减、乘、除、幂次方
> 加、减、乘、除 : 基本算数运算
> 幂次方 : 复合算数运算




逻辑运算——对逻辑值真/假（二进制1/0）进行运算，如：与、或、非、异或
> 与、或、非 : 基本逻辑运算
> 异或 : 复合逻辑运算

> [!warning]+ 注意
> 注1：无论是算数运算、还是逻辑运算，都要有输入、输出。
> 注2：《离散数学》是专门研究逻辑运算的一门数学学科。


## 基本逻辑运算：与
![[Pasted image 20240627150846.png]]



## 基本逻辑运算：或
![[Pasted image 20240627150855.png]]


## 基本逻辑运算：非
![[Pasted image 20240627150913.png]]

## 复合逻辑运算：与非

![[Pasted image 20240627150925.png]]

## 复合逻辑运算：或非
![[Pasted image 20240627150933.png]]


## 复合逻辑运算：异或
![[Pasted image 20240627160608.png]]


## 复合逻辑运算：同或
![[Pasted image 20240627151131.png]]


## 逻辑运算的优先级、常见公式
![[Pasted image 20240627151446.png]]



## 额外小知识
异或运算的妙用：n bit进行异或，若有奇数个1，则异或结果为1；若有偶数个1，则异或结果为0
![[Pasted image 20240627151252.png]]


## 门电路的变形画法

![[Pasted image 20240627151344.png]]

> [!note]+ 拓展：芯片制程
> ![[Pasted image 20240627151630.png]]


## 小结

![[Pasted image 20240627160110.png]]


# 多路选择器 和 三态门

## 多路选择器(MUX)
![[Pasted image 20240627155755.png]]
多路选择器（multiplexer，MUX）作用：电路的“守门员”。在多个输入数据中，只允许其中一个数据通过MUX。

图形：通常用“梯形”表示，有多个输入、一个输出、一个控制信号（梯形的更长的一边是输入端、更短的一边是输出端）

若有𝑘 个输入，则控制信号的位数 $m ≥ \left\lceil  log_2 𝑘 \right\rceil$ 𝑏𝑖𝑡

注：在电路图中，控制信号常用英文缩写“XXXop”表示，图形常用“虚线箭头


![[Pasted image 20240627155813.png]]

## 三态门

![[Pasted image 20240627155852.png]]

三态门
作用：电路的“守门员”。根据控制信号决定是否让输入的数据通过。

图形：小三角。有一个输入、一个输出、一个控制信号。

三态门的控制信号通常只需要1bit。op=1表示允许数据通过；op=0表示不允许数据通过。

### 初学者提示：三态门 vs 非门
![[Pasted image 20240627155934.png]]

==核心区别：“非门”没有控制信号！只有输入和输出==


## 小结
![[Pasted image 20240627160029.png]]


# 加法器
![[Pasted image 20240627160214.png]]

## 加法器的基本功能
![[Pasted image 20240627160317.png]]
例：7+12=19
用8bit表示被加数A、加数B、和S

### 如何用门电路实现一位加法？

![[Pasted image 20240627160417.png]]



## 一位全加器

![[Pasted image 20240627161013.png]]


## n bit加法器
![[Pasted image 20240627161046.png]]
串行进位的并行加法器：把n个全加器串接起来，就可进行两个n位数的相加。

串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。

> [!info]+ 不足之处
> ![[Pasted image 20240627161316.png]]
> 进位信息是串行产生的，计算速度取决于进位产生和传递的速度。位数越多，运算速度越慢。
> 
> 注1：电信号到达稳态需要一定时间，因此进位产生速度会有延迟。
> 注2：串行进位又称为行波进位，每一级进位直接依赖于前一级的进位，即进位信号是逐级形成的。
> 
> 由于两个输入端允许并行输入n bit，因此这种加法器属于：并行加法器
> 由于进位信息是串行产生的，因此从“进位方式”看，这种加法器属于：串行进位加法器
> 综上，很多教材把这种加法器称为“串行进位的并行加法器”


## 并行进位的并行加法器
![[Pasted image 20240627161428.png]]
并行进位的并行加法器：所有进位信息都是同时产生的，几乎没有延迟。
特点：运算速度比“串行进位的并行加法器”更快。

## 带标志位的加法器
![[Pasted image 20240627161603.png]]

OF（Overflow Flag)溢出标志，用于判断带符号数加减运算是否溢出。OF=1 溢出；OF=0 未溢出
SF（Sign Flag）符号标志，用于判断带符号数加减运算结果的正负性。SF=1 结果为负；SF=0 结果为正
ZF（Zero Flag)零标志，用于判断加减运算结果是否为0。ZF=1 表示结果为0；ZF=0 表示结果不为0
CF（Carry Flag)进位/借位标志，用于判断无符号数加减运算是否溢出。CF=1 溢出；CF=0 未溢出


### 标志位的生成
![[Pasted image 20240627161702.png]]


# 小结
![[Pasted image 20240627162304.png]]



# 并行进位加法器

复习[[运算方法和运算电路#n bit加法器|串行进位的并行加法器]]

![[Pasted image 20240627162723.png]]

## 如何更快的产生进位?

![[Pasted image 20240627162816.png]]

结论：第i位向更高位的进位$C_i$可根据被加数、加数的第1~i位,再结合$C_0$即可确定

### 并行加法器的优化
![[Pasted image 20240627163224.png]]

并行进位的并行加法器：各级进位信号同时形成，又称为先行进位、同时进位


# 算术逻辑单元 ALU

![[Pasted image 20240627164035.png]]


## 算术逻辑单元（ALU）的作用

![[Pasted image 20240627164056.png]]

CPU由控制器、运算器组成

控制器负责解析指令，并根据指令功能发出相应的控制信号（将在计组第五章详细学习）

运算器负责对数据进行处理，如：加减乘除等。

ALU是一种组合逻辑电路，实现了加/减/乘/除、与/或/非等功能。因此ALU是运算器的核心。

由于加减乘除等运算都要基于“加法”来实现，因此加法器是ALU的核心。


## ALU的功能
![[Pasted image 20240627164139.png]]


## ALU的实现原理
（简单了解即可）
![[Pasted image 20240627164204.png]]

[[运算方法和运算电路#多路选择器(MUX)]]

## 看懂ALU图示
![[Pasted image 20240627164325.png]]



## 小结
![[Pasted image 20240627164632.png]]



# 定点数的移位运算

![[Pasted image 20240627230135.png]]

## 算术移位
![[Pasted image 20240627230207.png]]

移位：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法
### 原码的算术移位
右移
![[Pasted image 20240627230249.png]]
![[Pasted image 20240627230415.png]]
原码的算数移位——符号位保持不变，仅对数值位进行移位。
右移：高位补0，低位舍弃。若舍弃的位=0，则相当于÷2；若舍弃的位≠0，则会丢失精度
左移：低位补0，高位舍弃。若舍弃的位=0，则相当于×2；若舍弃的位≠0，则会出现严重误差




![[Pasted image 20240627230529.png]]


### 反码的算术移位
![[Pasted image 20240627230604.png]]
反码的算数移位——正数的反码与原码相同，因此对==正数反码的移位运算也和原码相同==。
右移：高位补0，低位舍弃。
左移：低位补0，高位舍弃。

反码的算数移位——负数的反码数值位与原码相反，因此==负数反码的移位运算==规则如下，
右移：高位补1，低位舍弃。
左移：低位补1，高位舍弃。


### 补码的算术移位
补码的算数移位——正数的补码与原码相同，因此对正数补码的移位运算也和原码相同。
右移：高位补0，低位舍弃。
左移：低位补0，高位舍弃。

补码的算数移位——负数补码=反码末位+1 , 导致反码最右边几个连续的1都因进位而变为0，直到进位碰到第一个0为止。
规律——负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码
负数补码的算数移位规则如下：
右移（同反码）：高位补1，低位舍弃。
左移（同原码）：低位补0，高位舍弃。

![[Pasted image 20240627230825.png]]



算术移位小结
![[Pasted image 20240627230901.png]]


### 算数移位的应用举例
![[Pasted image 20240627231000.png]]


## 逻辑移位
![[Pasted image 20240627231051.png]]
逻辑右移：高位补0，低位舍弃。
逻辑左移：低位补0，高位舍弃。

可以把逻辑移位看作是对“无符号数”的算术移位

### 逻辑移位的应用举例
![[Pasted image 20240627231211.png]]


## 循环移位
![[Pasted image 20240627231429.png]]

## 小结
![[Pasted image 20240627231446.png]]注意：由于原、反、补码位数有限，因此某些时候算数移位不能精确等效乘法、除法