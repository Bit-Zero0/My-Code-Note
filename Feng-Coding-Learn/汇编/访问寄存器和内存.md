---
Type: Note
tags:
  - 汇编
Status: writing
start-date: 2024-06-09 11:34
Finish-date: 
Modified-date: 2024-06-09 21:34
---

# 寄存器及数据存储

## CPU的组成
**运算器**进行信息处理；

**寄存器**进行信息存储；

**控制器**协调各种器件进行工作；

**内部总线**实现CPU内各个器件之间的联系。

![[Pasted image 20240609113813.png]]


寄存器是CPU内部的信息存储单元
- 8086CPU有14个寄存器：
	- 通用寄存器：`AX`、`BX`、`CX`、`DX`
	- 变址寄存器：`SI`、`DI`
	- 指针寄存器：`SP`、`BP`
	- 指令指针寄存器： `IP`
	- 段寄存器：`CS`、`SS`、`DS`、`ES`
	- 标志寄存器：`PSW`
- 共性
	- 8086CPU所有的寄存器都是16位的，可以存放两个字节。

## 通用寄存器

> [!info] 数字后 D , H , B 的含义
> - ==B==: 表示该数字为二进制表示, `10011B` , 表示二进制 `10011` , 转换为十进制为`17D`, 转换为十六进制为`11H`.
> - ==D==: 表示十进制, `20D` , 表示十进制中的 20, 转换为二进制为`10100D`, 转换为十六进制为`14H`.
> - ==H==: 表示十六进制, `12H` , 表示十六进制中的 12 , 转换为十进制为 `18D` , 转换为二进制为`00010010B`或可以写为`10010B` .

- 16位寄存器存储一个16位的数据
	- ![[Pasted image 20240609114419.png]]
	- 最大值: $2^{16}-1$
- 例1：在AX中存储18D
	- ![[Pasted image 20240609114410.png]]
	- 18D
	- 12H
	- 10010B
- 例2：在AX中存储20000D
	- ![[Pasted image 20240609114444.png]]
	- 20000D
	- 4E20H
	-  0100111000100000B

## CPU与程序的兼容性

> [!question]+ 8086的上一代CPU中的寄存器都是8位的，如何保证程序的兼容性？
> - 方案
> 	- 通用寄存器均可以分为两个独立的8位寄存器使用
> - 细化
> 	- AX可以分为AH和AL
> 	- BX可以分为BH和BL
> 	- CX可以分为CH和CL
> 	- DX可以分为DH和DL

![[Pasted image 20240609115602.png]]


| 寄存器 | 寄存器中的数据                           | 所表示的值         |
| --- | --------------------------------- | ------------- |
| AX  | `0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0` | 20000D(4E20H) |
| AH  | `0 1 0 0 1 1 1 0`                 | 78D(4EH)      |
| AL  | `0 0 1 0 0 0 0 0`                 | 32D (20H)     |
用十六进制可以直观的看出这个数据是由哪些8位数据构成。

## 字在寄存器中的存储
- 8086是16位CPU
	-  8086的==**字长**==(word size)为==**16bit**== , 也就是2个字节(Byte).
- 一个==**字**==(word)可以存在一个16位寄存器中
	-  这个字的**高位字节**存在这个寄存器的**高8位寄存器**
	-  这个字的**低位字节**存在这个寄存器的**低8位寄存器**
![[Pasted image 20240609120044.png]]

## mov 和 add 指令



### 汇编用中学 - 例1

| 汇编指令          | 控制CPU完成的操作           | 用高级语言的语法描述  |
| ------------- | -------------------- | ----------- |
| `mov ax, 18`  | 将 18 送入              | AX = 18     |
| `mov ah , 78` | 将 78 送               | AH = 78     |
| `add ax, 8`   | 将寄存器中AX中的数值加上 8  加上8 | AX = AX +8  |
| `mov ax,bx`   | 将寄存器BX中的数据送入寄存器AX    | AX = BX     |
| `add ax,bx`   | 将AX，BX中的内容相加，结果存在AX中 | AX = AX+ BX |
>注：**汇编指令不区分大小写**


### 汇编用中学 - 例2
设原AX、BX中的值均为0000H

| 程序段中的指令       | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| ------------- | :---------: | :---------: |
| mov ax, 4E20H |    4E20H    |    0000H    |
| add ax, 1406H |    6226H    |    000OH    |
| mov bx, 2000H |    6226H    |    2000H    |
| add ax, bx    |    8226H    |    2000H    |
| mov bx, ax    |    8226H    |    8226H    |
| add ax, bx    |    044CH    |    8226H    |
### 汇编用中学 - 例3
设原AX、BX中的值均为0000H

| 程序段中的指令       | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| ------------- | :---------: | :---------: |
| mov ax, 001AH |    001AH    |    0000H    |
| mov bx, 0026H |    001AH    |    0026H    |
| add al, bl    |    0040H    |    0026H    |
| add ah, bl    |    2640H    |    0026H    |
| add bh, al    |    2640H    |    4026H    |
| mov ah, 0     |    0040H    |    4026H    |
| add al, 85H   |    00C5H    |    4026H    |
| add al, 93H   |    0058H    |    4026H    |
> [!question]+ 现在AX中的数据为`0058H` , 若执行add ax, 93H?
> AX结果为EBH.
> 注意这里是两个十六进制数相加, 逢16才进 1 .


# 确认物理地址的方法

## 物理地址
- CPU访问内存单元时要给出内存单元的地址。
- 所有的内存单元构成的存储空间是一个一维的线性空间。
- 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为==物理地址==。
- 事实
	-  8086有20位地址总线，可传送20位地址，==寻址能力为1M==。
	-  8086是16位结构的CPU
		-  运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。
		-  在8086内部处理的、传输、暂存的地址也是16位，==**寻址能力也只有64KB**==！


### 8086CPU给出物理地址的方法

> [!question]+ 8086如何处理在寻址空间上的这个矛盾？
>8086CPU的解决方法: 用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。
>- 地址加法器合成物理地址的方法(物理地址=段地址×16+偏移地址)
>- ![[Pasted image 20240609131736.png]]
>- ![[Pasted image 20240609131819.png]]


#todo 物理地址=段地址×16+偏移地址
#todo 8086CPU访问地址为123C8H的内存单元


### “段地址×16+偏移地址=物理地址”的本质含义

要解决的问题
>用两个16位的地址（段地址、偏移地址），相加得到一个20位的物理地址

本质含义
>CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

# 内存的分段表示法

## 用分段的方式管理内存
8086CPU用“（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址。

<mark style="background: #FF5582A6;">内存并没有分段，段的划分来自于CPU.</mark>

![[内存地址分段图.png]]


## 同一段内存, 多种分段方案


![[Pasted image 20240609132809.png|391]]
起始地址（ 基础地址）为10000H，段地址为1000H，大小为100H


![[Pasted image 20240609132928.png|385]]
起始地址（ 基础地址 ）为10000H和10080H，段地址为1000H和1008H，大小均为80H

>1. 段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；
>2. 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。


## 用不同的段地址和偏移地址形成同一个物理地址
同一个物理地址可以使用不同段地址和偏移地址构成.

如: 寻找物理地址为: `21F60H`的地址
![[Pasted image 20240609133550.png]]
> 偏移地址16位，变化范围为`0~FFFFH`，用偏移地址最多寻址64KB。
> >例：给定 **段地址**`2000H`，用偏移地址寻址的范围是：20000H~2FFFFFH，共64K
> >段地址`2000H * 16 = 20000H` + 偏移地址`0~FFFFH`

以上地址的段地址+偏移地址都可以找到物理地址`21F60H` .

所以段地址很重要, 那专门存放段地址的寄存器有哪些?
> [!info] 四个段寄存器
> CS - 代码段寄存器　　　DS - 数据段寄存器
> SS - 栈段寄存器　　　　ES - 附加段寄存器
> 
> 以上寄存器在后续的内容中都会重点介绍

而偏移地址也可以用多种方法提供.

# CS, IP 与代码段

## 两个关键的寄存器
CS ：代码段寄存器
IP： 指令指针寄存器

CS:IP：CPU将内存中CS:IP指向的内容当作指令执行。


## 在CS和IP指示下代码的执行
8086CPU当前状态：CS中内容为2000H，IP中内容为0000H
内存20000H~20009H处存放着可执行的机器代码
![[Pasted image 20240609155528.png]]
用debug程序执行下面的代码
```z80
-a cs:ip   ;写入汇编代码
mov ax, 0123H
mov bx, 0003H
mov ax, bx
add ax, bx

-u cs:ip   ;查看代码
-t         ;执行CS:IP处代码
```


#todo 8086PC读取和执行指令演示
8086PC工作过程的简要描述：
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
2. IP = IP + 所读取指令的长度，从而指向下一条指令；
3. 执行指令。 转到步骤1，重复这个过程。


> [!question]+ 内存中有数据 B8 23 01 BB 03 00 89 D8 01 D8， 究竟用作一般数据，还是用作指令？
>  CPU将CS:IP指向的内存单元中的内容看作指令！


## 修改CS , IP 指令
事实：执行何处的指令，取决于CS:IP

应用：可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令

> [!NOTE]+ 如何改变CS、IP的值？
>-  方法1：Debug 中的 [[Debug的使用#R 指令|R 命令]]可以改变寄存器的值 cs, ip
> 	-  Debug是调试手段，并非程序方式！
>-  方法2：用指令修改
>-  方法3：转移指令 jmp ^ut16sn

## jmp 指令

> [!important] 同时修改CS、IP的内容
> jmp 段地址：偏移地址
> ```z80
> jmp 2AE3:3
> jmp 3:0B16
> ```
> >==功能==：用指令中给出的段地址**修改CS**，偏移地址**修改IP**。


> [!important] 仅修改IP的内容
> jmp 某一合法寄存器
>```z80
> jmp ax  ;类似于 mov ip, ax
> jmp bx
>```
> >==功能==：用寄存器中的值修改IP。


### 问题分析
![[jmp指令分析图.excalidraw|644]]