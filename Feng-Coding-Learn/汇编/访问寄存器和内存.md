---
Type: Note
tags:
  - 汇编
Status: writing
start-date: 2024-06-09 11:34
Finish-date: 
Modified-date: 2024-06-13 17:04
---

# 寄存器及数据存储

## CPU的组成
**运算器**进行信息处理；

**寄存器**进行信息存储；

**控制器**协调各种器件进行工作；

**内部总线**实现CPU内各个器件之间的联系。

![[Pasted image 20240609113813.png]]

寄存器是CPU内部的信息存储单元
- 8086CPU有14个寄存器：
	- 通用寄存器：`AX`、`BX`、`CX`、`DX`
	- 变址寄存器：`SI`、`DI`
	- 指针寄存器：`SP`、`BP`
	- 指令指针寄存器： `IP`
	- 段寄存器：`CS`、`SS`、`DS`、`ES`
	- 标志寄存器：`PSW`
- 共性
	- 8086CPU所有的寄存器都是16位的，可以存放两个字节。

## 通用寄存器

> [!info] 数字后 D , H , B 的含义
> - ==B==: 表示该数字为二进制表示, `10011B` , 表示二进制 `10011` , 转换为十进制为`17D`, 转换为十六进制为`11H`.
> - ==D==: 表示十进制, `20D` , 表示十进制中的 20, 转换为二进制为`10100D`, 转换为十六进制为`14H`.
> - ==H==: 表示十六进制, `12H` , 表示十六进制中的 12 , 转换为十进制为 `18D` , 转换为二进制为`00010010B`或可以写为`10010B` .

- 16位寄存器存储一个16位的数据
	- ![[Pasted image 20240609114419.png]]
	- 最大值: $2^{16}-1$
- 例1：在AX中存储18D
	- ![[Pasted image 20240609114410.png]]
	- 18D
	- 12H
	- 10010B
- 例2：在AX中存储20000D
	- ![[Pasted image 20240609114444.png]]
	- 20000D
	- 4E20H
	-  0100111000100000B

## CPU与程序的兼容性

> [!question]+ 8086的上一代CPU中的寄存器都是8位的，如何保证程序的兼容性？
> - 方案
> 	- 通用寄存器均可以分为两个独立的8位寄存器使用
> - 细化
> 	- AX可以分为AH和AL
> 	- BX可以分为BH和BL
> 	- CX可以分为CH和CL
> 	- DX可以分为DH和DL

![[Pasted image 20240609115602.png]]


| 寄存器 | 寄存器中的数据                           | 所表示的值         |
| --- | --------------------------------- | ------------- |
| AX  | `0 1 0 0 1 1 1 0 0 0 1 0 0 0 0 0` | 20000D(4E20H) |
| AH  | `0 1 0 0 1 1 1 0`                 | 78D(4EH)      |
| AL  | `0 0 1 0 0 0 0 0`                 | 32D (20H)     |
用十六进制可以直观的看出这个数据是由哪些8位数据构成。

## 字在寄存器中的存储
- 8086是16位CPU
	-  8086的==**字长**==(word size)为==**16bit**== , 也就是2个字节(Byte).
- 一个==**字**==(word)可以存在一个16位寄存器中
	-  这个字的**高位字节**存在这个寄存器的**高8位寄存器**
	-  这个字的**低位字节**存在这个寄存器的**低8位寄存器**
![[Pasted image 20240609120044.png]]

## mov 和 add 指令



### 汇编用中学 - 例1

| 汇编指令          | 控制CPU完成的操作           | 用高级语言的语法描述  |
| ------------- | -------------------- | ----------- |
| `mov ax, 18`  | 将 18 送入              | AX = 18     |
| `mov ah , 78` | 将 78 送               | AH = 78     |
| `add ax, 8`   | 将寄存器中AX中的数值加上 8  加上8 | AX = AX +8  |
| `mov ax,bx`   | 将寄存器BX中的数据送入寄存器AX    | AX = BX     |
| `add ax,bx`   | 将AX，BX中的内容相加，结果存在AX中 | AX = AX+ BX |
>注：**汇编指令不区分大小写**


### 汇编用中学 - 例2
设原AX、BX中的值均为0000H

| 程序段中的指令       | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| ------------- | :---------: | :---------: |
| mov ax, 4E20H |    4E20H    |    0000H    |
| add ax, 1406H |    6226H    |    000OH    |
| mov bx, 2000H |    6226H    |    2000H    |
| add ax, bx    |    8226H    |    2000H    |
| mov bx, ax    |    8226H    |    8226H    |
| add ax, bx    |    044CH    |    8226H    |
### 汇编用中学 - 例3
设原AX、BX中的值均为0000H

| 程序段中的指令       | 指令执行后AX中的数据 | 指令执行后BX中的数据 |
| ------------- | :---------: | :---------: |
| mov ax, 001AH |    001AH    |    0000H    |
| mov bx, 0026H |    001AH    |    0026H    |
| add al, bl    |    0040H    |    0026H    |
| add ah, bl    |    2640H    |    0026H    |
| add bh, al    |    2640H    |    4026H    |
| mov ah, 0     |    0040H    |    4026H    |
| add al, 85H   |    00C5H    |    4026H    |
| add al, 93H   |    0058H    |    4026H    |
> [!question]+ 现在AX中的数据为`0058H` , 若执行add ax, 93H?
> AX结果为EBH.
> 注意这里是两个十六进制数相加, 逢16才进 1 .


# 确认物理地址的方法

## 物理地址
- CPU访问内存单元时要给出内存单元的地址。
- 所有的内存单元构成的存储空间是一个一维的线性空间。
- 每一个内存单元在这个空间中都有唯一的地址，这个唯一的地址称为==物理地址==。
- 事实
	-  8086有20位地址总线，可传送20位地址，==寻址能力为1M==。
	-  8086是16位结构的CPU
		-  运算器一次最多可以处理16位的数据，寄存器的最大宽度为16位。
		-  在8086内部处理的、传输、暂存的地址也是16位，==**寻址能力也只有64KB**==！


### 8086CPU给出物理地址的方法

> [!question]+ 8086如何处理在寻址空间上的这个矛盾？
>8086CPU的解决方法: 用两个16位地址(段地址、偏移地址)合成一个20位的物理地址。
>- 地址加法器合成物理地址的方法(物理地址=段地址×16+偏移地址)
>- ![[Pasted image 20240609131736.png]]
>- ![[Pasted image 20240609131819.png]]


#todo 物理地址=段地址×16+偏移地址
#todo 8086CPU访问地址为123C8H的内存单元


### “段地址×16+偏移地址=物理地址”的本质含义

要解决的问题
>用两个16位的地址（段地址、偏移地址），相加得到一个20位的物理地址

本质含义
>CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

# 内存的分段表示法

## 用分段的方式管理内存
8086CPU用“（段地址×16）+偏移地址=物理地址”的方式给出内存单元的物理地址。

<mark style="background: #FF5582A6;">内存并没有分段，段的划分来自于CPU.</mark>

![[内存地址分段图.png]]


## 同一段内存, 多种分段方案


![[Pasted image 20240609132809.png|391]]
起始地址（ 基础地址）为10000H，段地址为1000H，大小为100H


![[Pasted image 20240609132928.png|385]]
起始地址（ 基础地址 ）为10000H和10080H，段地址为1000H和1008H，大小均为80H

>1. 段地址×16 必然是 16的倍数，所以一个段的起始地址也一定是16的倍数；
>2. 偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。


## 用不同的段地址和偏移地址形成同一个物理地址
同一个物理地址可以使用不同段地址和偏移地址构成.

如: 寻找物理地址为: `21F60H`的地址
![[Pasted image 20240609133550.png]]
> 偏移地址16位，变化范围为`0~FFFFH`，用偏移地址最多寻址64KB。
> >例：给定 **段地址**`2000H`，用偏移地址寻址的范围是：20000H~2FFFFFH，共64K
> >段地址`2000H * 16 = 20000H` + 偏移地址`0~FFFFH`

以上地址的段地址+偏移地址都可以找到物理地址`21F60H` .

所以段地址很重要, 那专门存放段地址的寄存器有哪些?
> [!info] 四个段寄存器
> CS - 代码段寄存器　　　DS - 数据段寄存器
> SS - 栈段寄存器　　　　ES - 附加段寄存器
> 
> 以上寄存器在后续的内容中都会重点介绍

而偏移地址也可以用多种方法提供.

# CS, IP 与代码段

## 两个关键的寄存器
CS ：代码段寄存器
IP： 指令指针寄存器

CS:IP：CPU将内存中CS:IP指向的内容当作指令执行。


## 在CS和IP指示下代码的执行
8086CPU当前状态：CS中内容为2000H，IP中内容为0000H
内存20000H~20009H处存放着可执行的机器代码
![[Pasted image 20240609155528.png]]
用debug程序执行下面的代码
```z80
-a cs:ip   ;写入汇编代码
mov ax, 0123H
mov bx, 0003H
mov ax, bx
add ax, bx

-u cs:ip   ;查看代码
-t         ;执行CS:IP处代码
```


#todo 8086PC读取和执行指令演示
8086PC工作过程的简要描述：
1. 从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
2. IP = IP + 所读取指令的长度，从而指向下一条指令；
3. 执行指令。 转到步骤1，重复这个过程。


> [!question]+ 内存中有数据 B8 23 01 BB 03 00 89 D8 01 D8， 究竟用作一般数据，还是用作指令？
>  CPU将CS:IP指向的内存单元中的内容看作指令！


## 修改CS , IP 指令
事实：执行何处的指令，取决于CS:IP

应用：可以通过改变CS、IP中的内容，来控制CPU要执行的目标指令

> [!NOTE]+ 如何改变CS、IP的值？
>-  方法1：Debug 中的 [[Debug的使用#R 指令|R 命令]]可以改变寄存器的值 cs, ip
> 	-  Debug是调试手段，并非程序方式！
>-  方法2：用指令修改
>-  方法3：转移指令 jmp ^ut16sn

## jmp 指令

> [!important] 同时修改CS、IP的内容
> jmp 段地址：偏移地址
> ```z80
> jmp 2AE3:3
> jmp 3:0B16
> ```
> >==功能==：用指令中给出的段地址**修改CS**，偏移地址**修改IP**。


> [!important] 仅修改IP的内容
> jmp 某一合法寄存器
>```z80
> jmp ax  ;类似于 mov ip, ax
> jmp bx
>```
> >==功能==：用寄存器中的值修改IP。


### 问题分析
![[jmp指令分析图.excalidraw|644]]

# 内存中字的存储
对8086CPU，16位作为一个字

>[!question] 16位的字存储在一个16位的寄存器中，如何存储？
>高8位放高字节，低8位放低字节
>![[Pasted image 20240610160049.png]]


>[!question]+ 16位的字在内存中需要2个连续字节存储，怎么存放？
>低位字节存在低地址单元，高位字节存在高地址单元
> >例：20000D(4E20H)存放0、1两个单元，18D(0012H)存放在2、3两个单元
> >![[Pasted image 20240610160110.png]]

## 字单元
字单元：由两个地址连续的内存单元组成，存放一个字型数据（16位）
> 原理：在一个字单元中，低地址单元存放低位字节，高地址单元存放高位字节
>	- 在起始地址为0的单元中，存放的是4E20H
>	- 在起始地址为2的单元中，存放的是0012H

********
> [!note]+ 
> ![[Pasted image 20240610160306.png|112]]
> - 0 **地址单元**中存放的字节型数据是（ `20H` ）
> - 0 **地址字单元**中存放的字型数据是（ `4E20H` ）
> - 2 **地址单元**中存放的字节型数据是（ `12H` ）
> - 2 **地址字单元**中存放的字型数据是（`0012H`）

# 用DS和[address]实现字的传送
CPU要读取一个内存单元的时候，必须先给出这个内存单元的地址；

原理
	 在8086PC中，内存地址由段地址和偏移地址组成（段地址:偏移地址）

解决方案：`DS`和`[address]`配合
	 用 DS寄存器存放要访问的数据的段地址
	 偏移地址用`[...]`形式直接给出

例1
```z80
mov bx,1000H
mov ds,bx
mov al, [0]  ;[0] = ds:0 = 1000:0 
```
将10000H(1000:0)中的数据读到al中

例2
```z80
mov bx,1000H
mov ds,bx
mov [0],al   ;
```
将al中的数据写到
10000H(1000:0)中


> [!warning]+ 注意事项
> 将段地址送入DS的两种方式
> `mov ds, 1000H` 不支持直接将数据放入寄存器.
> `mov bx, 1000H`      `mov ds, bx` 支持由其他寄存器进行中转.
> ==8086CPU不支持将数据直接送入段寄存器== (硬件设计的问题)
> 套路：数据 -> 一般的寄存器  -> 段寄存器


## 字的传送
8086CPU可以一次性传送一个字(16位的数据)

先用Debug 中 的 [[Debug的使用#E 指令|E指令]] 更改 1000:0处的数据为
![[Pasted image 20240610163800.png]]
```z80
-e 1000:0 23 11 22 66
```
![[Pasted image 20240610164011.png]]

将以下数据用的 [[Debug的使用#A指令|A指令]] 输入
```z80
mov bx, 1000H
mov ds, bx
mov ax, [0] ;1000:0处的字型数据送入ax
mov [0], cx ;cx中的16位数据送到1000:0处
```

使用 [[Debug的使用#T指令|T指令]]执行
![[Pasted image 20240610163036.png]]

看看 `[0]` 代表的 `1000:0` 地址处数据是否更改
![[Pasted image 20240610163451.png]]
可以看到已经被更改了

### 案例1
数据和之前的一样
![[Pasted image 20240610163800.png]]

这是指令
```z80
mov ax, 1000H
mov ds, ax
mov ax, [0]
mov bx, [2]
mov cx, [1]
add bx, [1]
add cx, [2]
```

![[DS与[address]转送 例1图.excalidraw|600]]

# 案例2
数据与案例1时一样
![[Pasted image 20240610163800.png]]

指令
```z80
mov ax, 1000H
mov ds, ax
mov ax, 2C31
mov [0], ax
mov bx, [0]
sub bx, [2] 
mov [2], bx
```

![[Drawing 2024-06-11 16.07.57.excalidraw|600]]

> [!info]+ sub指令
> sub指令的作用: 减法指令
> sub指令的用法: `SUB 目的操作数, 源操作数`
> ```z80
> mov ax, 1000
> mov bx, 200
> sub ax, bx  ; ax 现在是 1000 - 200 = 800
> ```

# DS与数据段

## 对内存单元中数据的访问
- 对于8086PC机，可以根据需要将一组内存单元定义为一个段。
	-  物理地址=段地址×16+偏移地址
	-  将一组长度为N（N≤64K）、地址连续、起始地址为16的倍数的内存单元当作专门存储数的内存空间，从而定义了一个数据段。

> [!example]+ 举个栗子
> - 例：用123B0H~123B9H的空间来存放数据
> 	-  段地址：123BH　起始偏移地址：0000H　长度：10字节
> 	-  段地址：1230H　起始偏移地址：00B0H　长度：10字节


- 处理方法：`(DS):([address])`
	-  用DS存放数据段的段地址
	-  用相关指令访问数据段中的具体单元，单元地址由`[address]`指出

## 用 mov 指令操作数据


| 指令形式         | 例示            |
| ------------ | ------------- |
| mov 寄存器，数据   | `mov ax, 8`   |
| mov 寄存器，寄存器  | `mov ax, bx`  |
| mov 寄存器，内存单元 | `mov ax, [0]` |
| mov 内存单元，寄存器 | `mov[0],ax`   |
| mov 段寄存器，寄存器 | `mov ds, ax`  |

- 已知：mov 段寄存器，寄存器
	- ==推测1== `mov 寄存器，段寄存器`
		- 验证:
		- ![[Pasted image 20240613152333.png]]
- 已知：mov 内存单元，寄存器
	- ==推测2== `mov 内存单元，段寄存器`
		- 验证: **可行**
			- ![[Pasted image 20240613152518.png]]
	- ==推测3== `mov 段寄存器，内存单元`
		- 验证: **可行**
		- ![[Pasted image 20240613152557.png]]
- 已知：mov 寄存器，数据
	- ==推测4== `mov 段寄存器，数据`
	- 验证: <mark style="background: #FF5582A6;">不可行</mark>
		- ![[Pasted image 20240613152712.png]]

## 加法 add 和减法 sub 指令
| add 指令形式     | 例示            |
| ------------ | ------------- |
| add 寄存器，数据   | `add ax, 8`   |
| add 寄存器，寄存器  | `add ax, bx`  |
| add 寄存器，内存单元 | `add ax, [0]` |
| add 内存单元，寄存器 | `add[0],ax`   |

| sub 指令形式     | 例示            |
| ------------ | ------------- |
| sub 寄存器，数据   | `sub ax, 8`   |
| sub 寄存器，寄存器  | `sub ax, bx`  |
| sub 寄存器，内存单元 | `sub ax, [0]` |
| sub 内存单元，寄存器 | `sub[0],ax`   |

> [!failure]+ 错误指令
> 错误使用1: `add 段寄存器，寄存器`
> 错误使用2:`add 内存单元，内存单元`
> 错误使用3:`add 寄存器,  段寄存器`
> ![[Pasted image 20240613153432.png]]

## 小结
1. 字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。
2. 用 mov 指令要访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
3. [address]表示一个偏移地址为address的内存单元。
4. 在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
5. mov、add、sub是具有两个操作对象的指令，访问内存中的数据段（对照：jmp是具有一个操作对象的指令，对应内存中的代码段）。
6. 可以根据自己的推测，在Debug中实验指令的新格式。


# 栈及栈操作的实现

## 栈结构
- 栈是一种只能在一端进行插入或删除操作的数据结构。

- 栈有两个基本的操作：入栈和出栈。
	-  入栈：将一个新的元素放到栈顶；
	-  出栈：从栈顶取出一个元素。

- 栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。

- 栈的操作规则：LIFO（Last In First Out，后进先出）

- CPU提供的栈机制
	-  现今的CPU中都有栈的设计。
	-  8086CPU提供相关的指令，支持用栈的方式访问内存空间。
	-  基于8086CPU的编程，可以将一段内存当作栈来使用。


> [!info]+ PUSH(入栈)和 POP(出栈)指令
> ```z80
> push ax ;将ax中的数据送入栈中
> pop ax ;从栈顶取出数据送入ax
> ```
> 以字为单位对栈进行操作
> 

#todo 设将10000H~1000FH内存当作栈来使用动态图

> [!question]+ CPU如何知道一段内存空间被当作栈使用？如何知道哪个单元是栈顶单元?
> - 8086CPU中，有两个与栈相关的寄存器：
> 	- 栈段寄存器`SS`: 　　存放栈顶的段地址
> 	- 栈顶指针寄存器`SP` : 存放栈顶的偏移地址
> 
> 任意时刻，`SS:SP`指向栈顶元素。

![[汇编 栈的操作图.excalidraw|600]]

push ax
1. SP=SP–2；
2. 将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。

pop ax
1. 将SS:SP指向的内存单元处的数据送入ax中；
2. SP = SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

但是会存在栈顶超界问题, 如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

#todo 栈顶越界图
当栈满的时候再使用push指令入栈， 将发生栈顶超界问题。

> [!warning]+ 注意
> 栈顶越界是危险的。可能会使程序带来带来意想不到的数据混乱.


> [!tip]+ 栈顶越界问题的解决
> 8086CPU不保证对栈的操作不会超界。8086CPU 只知道栈顶在何处（由SS:SP指示），不知道程序安排的栈空间有多大。
> 我们在编程的时候要自己操心栈顶超界的问题 ，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；防止出栈时栈空了仍然继续出栈而导致的超界。

## 栈的小结
push、pop 实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的。

执行push和pop指令时，`SP` 中的内容自动改变。

8086CPU提供的栈操作机制：
在SS，SP中存放栈顶的段地址和偏移地址，入栈和出栈指令根据SS:SP指示的地址，按照栈的方式访问内存单元。
`push`指令的执行步骤：
1. SP=SP-2；
2. 向SS:SP指向的字单元中送入数据。
`pop`指令的执行步骤：
1. 从SS:SP指向的字单元中读取数据；
2. SP=SP-2。

# 段的总结

基础: 物理地址=段地址×16+偏移地址
做法: 
- 编程时，可以根据需要将一组内存单元定义为一个段。
- 可以将起始地址为16的倍数，长度为N（N ≤64K ）的一组地址连续的内存单元，定义为一个段。
- 将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元——在程序中可以完全由程序员安排。

三种段
- 数据段
	- 将段地址放在 DS中
	- 用mov、add、sub等访问内存单元的指令时，CPU将我们定义的数据段中的内容当作数据段来访问；
- 代码段
	- 将段地址放在 CS中，将段中第一条指令的偏移地址放在IP中
	- CPU将执行我们定义的代码段中的指令；
- 栈段
	- 将段地址放在SS中，将栈顶单元的偏移地置放在 SP 中
	- CPU在需要进行栈操作(push、pop)时，就将我们定义的栈段当作栈空间来用。

## 综合案列
![[Pasted image 20240613160859.png]]

三个段地址是可以一样的
![[Pasted image 20240613161008.png]]