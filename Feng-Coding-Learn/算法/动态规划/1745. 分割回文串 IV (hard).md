---
Type: Note
tags:
  - 算法
  - hard
  - 动态规划
Status: writing
Start-date: 2025-03-16 14:30
Finish-date: 
Modified-date: 2025-03-16 14:36
Publish: false
---


# 1745. 分割回文串 IV
[1745. 分割回文串 IV](https://leetcode.cn/problems/palindrome-partitioning-iv/)

> [!note]+ 前置题目
> - [[647. 回文子串 (medium)]]
> - [[5. 最长回文子串 (medium)#动态规划解法]]

## 题目描述
给你一个字符串 `s` ，如果可以将它分割成三个 **非空** 回文子字符串，那么返回 `true` ，否则返回 `false` 。

当一个字符串正着读和反着读是一模一样的，就称其为 **回文字符串** 。

**示例 1：**
**输入：** s = "abcbdd"
**输出：** true
**解释：**"abcbdd" = "a" + "bcb" + "dd"，三个子字符串都是回文的。

**示例 2：**
**输入：** s = "bcbddxy"
**输出：** false
**解释：** s 没办法被分割成 3 个回文子字符串。

**提示：**
- `3 <= s.length <= 2000`
- `s`​​​​​​ 只包含小写英文字母。

## 解题思路




### 解题思路

**问题分析**  
给定一个字符串 `s`，判断是否能将其分割为三个非空回文子串。例如，`s = "abcbdd"` 可分割为 `["a", "bcb", "dd"]`，返回 `true`。

**核心挑战**  
1. **高效判断所有可能的回文子串**：预处理回文信息以避免重复计算。  
2. **正确枚举分割点**：确保三个子串均为非空且回文。


### 算法设计  
1. **预处理回文信息**  
   - 构建二维数组 `dp[i][j]`，表示子串 `s[i...j]` 是否为回文。  
   - **状态转移方程**：  
     - `i == j` → `dp[i][j] = true`（单字符）。  
     - `s[i] == s[j]` 且 `i+1 == j` → `dp[i][j] = true`（双字符）。  
     - `s[i] == s[j]` 且 `dp[i+1][j-1] == true` → `dp[i][j] = true`（长字符）。

2. **枚举分割点**  
   - **第一个分割点** `i`：范围 `0 ≤ i ≤ n-3`，确保第一部分非空。  
   - **第二个分割点** `j`：范围 `i+1 ≤ j ≤ n-2`，确保第二、三部分非空。  
   - **验证条件**：`dp[0][i]`、`dp[i+1][j]`、`dp[j+1][n-1]` 均为 `true`。



> [!tip]+ 关键点解释
> 1. **预处理回文信息**  
>    - 反向遍历 `i` 确保在计算 `dp[i][j]` 时，`dp[i+1][j-1]` 已确定。  
>    - 处理单字符、双字符及长字符情况，覆盖所有可能的回文子串。
> 
> 2. **分割点枚举条件**  
>    - **i的范围**：`0 ≤ i ≤ n-3`，确保第一部分 `s[0..i]` 非空且剩余部分至少可分割两次。  
>    - **j的范围**：`i+1 ≤ j ≤ n-2`，确保第二部分 `s[i+1..j]` 非空，第三部分 `s[j+1..n-1]` 非空。
> 
> 3. **正确性验证**  
>    - 三个子串必须均为回文，通过 `dp` 数组快速验证，避免重复计算。



## 代码实现

```cpp
class Solution {
public:
    bool checkPartitioning(string s) {
        int n = s.size();
        if (n < 3) return false; // 无法分割为三个非空子串

        vector<vector<bool>> dp(n, vector<bool>(n, false));
        // 预处理回文子串信息
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] == s[j]) {
                    if (i + 1 <= j - 1) {
                        dp[i][j] = dp[i + 1][j - 1];
                    } else {
                        dp[i][j] = true; // 单字符或双字符相等
                    }
                }
            }
        }

        // 枚举所有合法的分割点i和j
        for (int i = 0; i <= n - 3; i++) {          // 第一部分结束于i（至少0~i有1个字符）
            for (int j = i + 1; j <= n - 2; j++) {  // 第二部分结束于j（至少i+1~j有1个字符）
                if (dp[0][i] && dp[i + 1][j] && dp[j + 1][n - 1]) {
                    return true;
                }
            }
        }
        return false;
    }
};
```




### 示例分析

以 `s = "abcbdd"` 为例：  
1. **预处理**：  
   - `dp[0][0] = true`（单字符 `"a"`）。  
   - `dp[1][3] = true`（子串 `"bcb"`）。  
   - `dp[4][5] = true`（子串 `"dd"`）。  
2. **枚举分割点**：  
   - `i=0`，`j=3` → `dp[0][0] = true`，`dp[1][3] = true`，`dp[4][5] = true` → 返回 `true`。


