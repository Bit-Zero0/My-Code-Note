---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-10 12:40
Finish-date: 
Modified-date: 2025-03-10 15:22
Publish: false
---


# 978. 最长湍流子数组
[978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/)

## 题目描述
给定一个整数数组 `arr` ，返回 `arr` 的 _最大湍流子数组的**长度**_ 。

如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是 **湍流子数组** 。

更正式地来说，当 `arr` 的子数组 `A[i], A[i+1], ..., A[j]` 满足仅满足下列条件时，我们称其为**湍流子数组**：

- 若 `i <= k < j` ：
    - 当 `k` 为奇数时， `A[k] > A[k+1]`，且
    - 当 `k` 为偶数时，`A[k] < A[k+1]`；
- **或** 若 `i <= k < j` ：
    - 当 `k` 为偶数时，`A[k] > A[k+1]` ，且
    - 当 `k` 为奇数时， `A[k] < A[k+1]`。

**示例 1：**
**输入：** arr = `[9,4,2,10,7,8,8,1,9]`
**输出：** 5
**解释：** `arr[1] > arr[2] < arr[3] > arr[4] < arr[5]`

**示例 2：**
**输入：** arr = `[4,8,12,16]`
**输出：** 2

**示例 3：**
**输入：** arr = `[100]`
**输出：** 1

**提示：**
- `1 <= arr.length <= 4 * 10^4`
- `0 <= arr[i] <= 10^9`

## 解题思路

### 问题性质与核心矛盾
**湍流子数组定义**：相邻元素比较符号交替变化（如 `> < > <` 或 `< > < >` 模式）

**关键难点**：
1. **方向交替性**：必须严格保证相邻比较符号不同
2. **连续性要求**：子数组必须是连续元素
3. **单元素突变**：当出现相等元素时立即中断当前湍流

**暴力解法缺陷**：
- 检查所有子数组的湍流性需要 O(n²) 时间复杂度
- 无法通过剪枝优化效率

#### 动态规划状态设计的数学原理
**双状态定义的必要性**：
- `up[i]`：以i结尾且最后操作为上升（`arr[i] > arr[i-1]`）的最长湍流长度
- `low[i]`：以i结尾且最后操作为下降（`arr[i] < arr[i-1]`）的最长湍流长度

**状态转移方程的推导**：
1. **上升情况 (`arr[i] > arr[i-1]`)**：
   - 必须接在前一个下降操作之后：`up[i] = low[i-1] + 1`
   - 重置上升序列长度（不能延续之前的上升趋势）

2. **下降情况 (`arr[i] < arr[i-1]`)**：
   - 必须接在前一个上升操作之后：`low[i] = up[i-1] + 1`
   - 重置下降序列长度

3. **相等情况**：
   - 同时重置两个状态：`up[i] = low[i] = 1`
   - 任何包含这两个相等元素的子数组都不满足条件

**状态转移矩阵**：

| 当前比较 | 前一状态类型 | 新状态更新规则    | 数学表达式                |
| ---- | ------ | ---------- | -------------------- |
| >    | 下降     | 上升状态继承下降长度 | `up[i] = low[i-1]+1` |
| <    | 上升     | 下降状态继承上升长度 | `low[i] = up[i-1]+1` |
| =    | 任意     | 双状态重置为1    | `up=low=1`           |

**状态初始化**：
    - `up` 和 `low` 初始为1，表示单个元素的默认长度。


### 边界条件与特殊测试用例
1. **全等数组**：`arr = [5,5,5,5]`
   - 所有 `up` 和 `low` 保持为1
   - 正确结果：1（题目允许单元素）

2. **严格交替数组**：`arr = [9,4,6,3,7,2]`
   - 每次比较方向都变化
   - 最终结果应为6（全部元素组成湍流）

3. **中间出现相等**：`arr = [2,3,5,5,4]`
   - 在`i=3`时相等，中断前面的湍流
   - 后续`i=4`的比较只能形成长度2的湍流


## 代码实现
```cpp
class Solution {
public:
    int maxTurbulenceSize(vector<int>& arr) {
        int n = arr.size();
        // 定义两个状态数组：low[i]表示以i结尾最后一步下降的湍流长度
        // up[i]表示以i结尾最后一步上升的湍流长度
        vector<int> low(n, 1), up(n, 1); // 初始化为1（单元素情况）

        int result = 1; // 最小长度为1（空数组在题目中不存在）
        
        for(int i = 1; i < n; i++) {
            // 情况1：当前元素大于前一个元素（需要接在下降操作之后）
            if(arr[i] > arr[i-1]) {
                up[i] = low[i-1] + 1; // 继承前序下降状态的长度并+1
                low[i] = 1; // 重置下降状态（当前是上升，不能延续之前的下降）
            }
            // 情况2：当前元素小于前一个元素（需要接在上升操作之后）
            else if(arr[i] < arr[i-1]) {
                low[i] = up[i-1] + 1; // 继承前序上升状态的长度并+1
                up[i] = 1; // 重置上升状态
            }
            // 情况3：相等时，两个状态都重置为1（湍流中断）
            else {
                up[i] = low[i] = 1;
            }
            
            // 更新全局最大值（注意比较当前两个状态）
            result = max(result, max(up[i], low[i]));
        }
        
        return result;
    }
};
```

### 示例演算（复杂案例）
**输入**：`arr = [3,2,5,4,7,6]`

**执行过程**：

| i | arr[i-1] vs arr[i] | low[i] 更新逻辑         | up[i] 更新逻辑          | result 更新 |
|---|---------------------|------------------------|-------------------------|-------------|
|1 | 2 < 3              | low = up+1 = 2   | up = 1               | max(1,2)=2 |
|2 | 5 > 2              | low = 1             | up = low+1 = 3    | max(2,3)=3 |
|3 | 4 < 5              | low = up+1 = 4   | up = 1               | max(3,4)=4 |
|4 | 7 > 4              | low = 1             | up = low+1 = 5    | max(4,5)=5 |
|5 | 6 < 7              | low = up+1 = 6   | up = 1               | max(5,6)=6 |

**最终结果**：6（子数组 `[3,2,5,4,7,6]` 满足 `> < > < >` 交替）


### 复杂度分析
- **时间复杂度**：O(n)，单次遍历数组
- **空间复杂度**：O(n)，可优化为 O(1)（如前面所示的空间压缩方案）

