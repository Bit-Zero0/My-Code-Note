---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-08 17:27
Finish-date: 
Modified-date: 2025-03-08 17:35
Publish: false
---


# 188. 买卖股票的最佳时机 IV
[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

## 题目描述
给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1：**
**输入：** k = 2, prices = `[2,4,1]`
**输出：** 2
**解释：** 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

**示例 2：**
**输入：** k = 2, prices = `[3,2,6,5,0,3]`
**输出：** 7
**解释：** 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。

## 解题思路
本问题需要计算在最多完成 k 笔交易的情况下，股票交易的最大利润。动态规划是解决此类问题的经典方法，其核心在于定义合适的状态，并通过状态转移方程递推求解。


1. **状态定义**
    - `hold[i][j]`：第 `i` 天结束时，已完成 `j` 次交易并持有股票的最大利润。
    - `sold[i][j]`：第 `i` 天结束时，已完成 `j` 次交易且未持有股票的最大利润。
2. **转移方程**
    - **持有股票状态（hold）**：
        - 可从前一天持有股票不变转移而来，即 `hold[i-1][j]`。
        - 或前一天未持有股票，当日买入（计入新的交易），即 `sold[i-1][j] - prices[i]`。
    - **卖出股票状态（sold）**：
        - 可从前一天未持有股票不变转移而来，即 `sold[i-1][j]`。
        - 或前一天持有股票，当日卖出（完成一次新交易），即 `hold[i-1][j-1] + prices[i]`。
3. **初始化**
    - 第0天：`hold[0][0] = -prices[0]`（持有股票），`sold[0][0] = 0`（未持有股票）。
    - 其他初始状态设为负无穷（无效状态）。
4. **结果提取**  
    遍历最后一天遍历所有可能的交易次数 `0 ≤ j ≤ k`，取 `sold[n-1][j]` 中的最大值作为答案。
    

> [!tip]+ 关键点
> - **交易次数定义**：每次卖出（而非买入）视为完成一次交易，因此进行卖出操作时需要从 `j-1` 转移。
> - **无效状态处理**：初始状态设置为 `-INF`，避免不合法状态影响结果。
> - **结果处理**：最终必须处于未持有股票状态才能实现利润，因此遍历所有可能的交易次数来选择最大值。


## 代码实现

```cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        const int INF = 0x3f3f3f3f;
        int n = prices.size();
        if (n == 0) return 0;
        
        vector<vector<int>> hold(n, vector<int>(k + 1, -INF));
        vector<vector<int>> sold(n, vector<int>(k + 1, -INF));
        hold[0][0] = -prices[0];
        sold[0][0] = 0;

        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= k; j++) {
                // 保持持有状态或买入
                hold[i][j] = max(hold[i - 1][j], (j >= 0) ? (sold[i - 1][j] - prices[i]) : -INF);
                // 保持不持有状态或卖出
                sold[i][j] = sold[i - 1][j];
                if (j >= 1) {
                    sold[i][j] = max(sold[i][j], hold[i - 1][j - 1] + prices[i]);
                }
            }
        }

        int maxProfit = 0;
        for (int j = 0; j <= k; j++) {
            maxProfit = max(maxProfit, sold[n - 1][j]);
        }
        return maxProfit;
    }
};
```


### 复杂度分析

- **时间复杂度**：`O(n*k)`，遍历每个元素和交易次数。
- **空间复杂度**：`O(n*k)`，存储两个二维状态数组。可优化为 `O(k)`，仅维护前一行状态。



