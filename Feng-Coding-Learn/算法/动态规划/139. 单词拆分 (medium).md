---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-11 16:02
Finish-date: 
Modified-date: 2025-03-11 16:15
Publish: false
---


# 139. 单词拆分
[139. 单词拆分](https://leetcode.cn/problems/word-break/)

## 题目描述
给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：** 不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**
**输入:** s = "leetcode", wordDict = ["leet", "code"]
**输出:** true
**解释:** 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

**示例 2：**
**输入:** s = "applepenapple", wordDict = ["apple", "pen"]
**输出:** true
**解释:** 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。

**示例 3：**
**输入:** s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
**输出:** false

**提示：**
- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

## 解题思路



### 问题性质与核心矛盾
**问题核心**：判断字符串能否被完全拆分为字典中的单词，要求拆分后的单词必须连续且完整。

**关键难点**：
1. **组合爆炸**：可能存在多种拆分方式，需要高效验证至少存在一种有效拆分
2. **连续性要求**：子串必须严格连续，不能跳跃字符
3. **字典复用**：字典单词可重复使用，但必须完整匹配

**暴力解法缺陷**：
- 递归回溯法时间复杂度达到指数级 O(2ⁿ)
- 重复计算相同前缀的拆分可能性

### 动态规划状态设计的数学原理
**状态定义**：
- `dp[i]`：表示前i个字符（s`[0..i-1]`）是否可以被成功拆分
- 物理意义：将问题分解为前缀子问题的解

**状态转移方程推导**：
对于每个位置 `i`，逆序遍历所有可能的分割点 `j`（从 `i` 到 `1`）：
1. **检查前 `j-1` 个字符**：若 `dp[j-1]` 为 `true`，说明前 `j-1` 个字符可拆分。
2. **检查子串 `s[j..i]`**：若该子串在字典中，则 `dp[i] = true`，并终止当前检查。
3. **剪枝策略**：当发现某个j满足条件时立即终止搜索

**初始化**
初始状态 ​**`dp[0] = true`**，表示空字符串可以被视为有效分割的起点。

**数学归纳证明**：
- **初始条件**：`dp=true`（空字符串总可拆分）
- **递推关系**：若存在有效分割点j，则i点的状态由j点状态保证
- **终止条件**：`dp[n]`即为整个字符串的可拆分性

### 算法实现细节剖析
**预处理优化**：
1. **字典哈希化**：将`wordDict`存入`unordered_set`实现 O(1) 查询
2. **索引调整**：原字符串前补空格使`s[1..n]`对应原始字符串，方便子串截取



### 复杂度优化分析
**时间复杂度**：
- 最坏情况 O(n² * L)，其中L是字典中最长单词长度
- 实际运行效率取决于字符串的拆分模式

**空间优化策略**：
1. **滚动数组**：由于只需前序状态，可压缩dp数组为单变量（但会丢失中间状态）
2. **字典树优化**：使用Trie树加速子串匹配，将时间复杂度优化至 O(n²)

**剪枝策略对比**：

| 搜索方向 | 优势场景                   | 劣势场景               |
|----------|----------------------------|------------------------|
| 正序查找 | 适合多数分割点在字符串前部 | 无法提前终止           |
| 倒序查找 | 快速定位最大有效分割点     | 需要完整遍历所有可能性 |

### 边界条件与特殊测试用例
1. **空字符串**：
   - 输入：s = "", wordDict = ["a"]
   - 正确处理：返回true（dp初始化为true）

2. **完全匹配**：
   - 输入：s = "apple", wordDict = ["apple"]
   - 关键路径：j=1时截取"apple"直接匹配成功

3. **重叠匹配**：
   ```python
   s = "aaaaaaa", wordDict = ["aaaa","aaa"]
   # 有效拆分方式：多种组合可能
   ```

4. **字典包含前缀但无法完全拆分**：
   ```python
   s = "carsales", wordDict = ["car","cars","sale"]
   # "carsales" -> "car"+"sales"（失败）
   # "cars"+"ales"（失败）
   ```




## 代码实现
```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        vector<bool> dp(n + 1, false); // dp[i]表示前i个字符是否可拆分
        dp = true; // 空字符串默认可拆分
        
        unordered_set<string> hash(wordDict.begin(), wordDict.end());
        s = ' ' + s; // 头部添加虚拟空格使索引对齐
        
        for(int i = 1; i <= n; i++) { // i表示当前终点在原始字符串中的位置
            // 倒序查找分割点：从i往前找j，使得s[j..i]在字典中
            for(int j = i; j >= 1; j--) { 
                // 截取子串：s[j..i]（对应原始字符串的j-1到i-1位置）
                string word = s.substr(j, i - j + 1);
                
                // 关键判断：前j-1个字符可拆分，且当前子串在字典中
                if(dp[j - 1] && hash.count(word)) {
                    dp[i] = true;
                    break; // 找到即终止，优化效率
                }
            }
        }
        return dp[n]; // 返回整个字符串的可拆分性
    }
};
```

### 示例演算（复杂案例）
**输入**：s = "applepenapple", wordDict = ["apple","pen"]

**执行流程**：

| i | 检查的子串         | 有效分割点j | dp状态变化       |
|---|--------------------|-------------|------------------|
| 5 | "apple" (j=1)      | j=1         | dp=true       |
| 8 | "pen" (j=6)        | j=6         | dp=true       |
| 13| "apple" (j=9)      | j=9         | dp=true      |

**最终结果**：true（拆分方式："apple" + "pen" + "apple"）



### 复杂度分析
- **时间复杂度**：O(n² * L)，其中L为字典中最长单词长度（substr操作代价）
- **空间复杂度**：O(n + m)，n为dp数组空间，m为字典哈希表空间



