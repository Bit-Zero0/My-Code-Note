---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-16 13:32
Finish-date: 
Modified-date: 2025-03-16 14:32
Publish: false
---


# 647. 回文子串
[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)


## 题目描述
给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

**示例 1：**
**输入：** s = "abc"
**输出：** 3
**解释：** 三个回文子串: "a", "b", "c"

**示例 2：**
**输入：** s = "aaa"
**输出：** 6
**解释：** 6个回文子串: "a", "a", "a", "aa", "aa", "aaa"

**提示：**
- `1 <= s.length <= 1000`
- `s` 由小写英文字母组成

## 解题思路


给定一个字符串 `s`，要求统计其中所有回文子串的数量。回文子串定义为正序和倒序相同的子串，例如 `"aba"`、`"aa"`。单个字符和两个相同字符均为回文。

**核心挑战**  
1. **高效遍历所有子串**：避免重复判断，快速确定每个子串是否为回文。  
2. **动态规划状态转移**：通过已知信息推导未知，减少重复计算。


**算法设计**  
1. **状态定义**  
   - `dp[i][j]`：表示字符串 `s` 的子串 `s[i...j]` 是否为回文（`true`/`false`）。

2. **状态转移方程**  
   - **基本情况**：  
     - 单个字符：`i == j` → `dp[i][j] = true`。  
     - 两个相同字符：`i + 1 == j` 且 `s[i] == s[j]` → `dp[i][j] = true`。  
   - **扩展情况**：  
     - 对于长度大于2的子串，若首尾字符相同且中间子串是回文，则当前子串为回文：  $$dp[i][j] = (s[i] == s[j]) \ \&\& \ dp[i+1][j-1]$$

3. **遍历顺序**  
   - **反向遍历**：从字符串末尾向前遍历 `i`，确保在计算 `dp[i][j]` 时，`dp[i+1][j-1]` 已被计算。

4. **结果统计**  
   - 遍历过程中，每次发现 `dp[i][j]` 为 `true` 时，计数器 `result` 递增。

**时间复杂度**  
- **双重循环**：遍历所有子串组合，时间复杂度为 **O(n²)**。  
- **空间复杂度**：使用二维数组存储状态，空间复杂度为 **O(n²)**。

> [!tip]+ 关键点
> 1. **反向遍历的必要性**  
>    - 由于 `dp[i][j]` 依赖于 `dp[i+1][j-1]`（即更短的子串），反向遍历确保所需状态已提前计算。
> 
> 2. **状态转移条件的覆盖性**  
>    - **单字符**：自然回文。  
>    - **双字符**：只需首尾相同。  
>    - **长字符**：首尾相同且中间部分回文。
> 
> 3. **结果统计的实时性**  
>    - 在填充 `dp[i][j]` 的同时立即更新计数器，避免二次遍历。

## 代码实现

```cpp
class Solution {
public:
    int countSubstrings(string s) {
        int n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n, false)); // dp[i][j]表示s[i...j]是否为回文
        int result = 0;

        // 反向遍历i，确保计算dp[i][j]时dp[i+1][j-1]已确定
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) { // j从i开始，因为子串左端点≤右端点
                if (s[i] == s[j]) {
                    if (i == j) { // 单个字符必为回文
                        dp[i][j] = true;
                    } else if (i + 1 == j) { // 两个相同字符
                        dp[i][j] = true;
                    } else { // 长度≥3时，取决于中间子串是否回文
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }
                // 当前子串是回文则计数
                if (dp[i][j]) {
                    result++;
                }
            }
        }
        return result;
    }
};
```


### 示例分析

以 `s = "aba"` 为例：  
1. **初始化**：所有 `dp[i][j]` 初始化为 `false`。  
2. **处理 `i=2`**：  
   - `j=2` → `dp[2][2] = true`，`result=1`。  
3. **处理 `i=1`**：  
   - `j=1` → `dp[1][1] = true`，`result=2`。  
   - `j=2` → `s[1] != s[2]`，跳过。  
4. **处理 `i=0`**：  
   - `j=0` → `dp[0][0] = true`，`result=3`。  
   - `j=1` → `s[0] != s[1]`，跳过。  
   - `j=2` → `s[0] == s[2]`，检查 `dp[1][1] = true` → `dp[0][2] = true`，`result=4`。  
最终结果为4，对应子串 `"a"`, `"b"`, `"a"`, `"aba"`。


### 复杂度分析
- **时间复杂度**：O (n²)，其中 `n` 是字符串长度。每个子串需计算一次。
- **空间复杂度**：O (n²)，存储动态规划数组。