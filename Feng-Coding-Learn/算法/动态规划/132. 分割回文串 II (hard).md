---
Type: Note
tags:
  - 算法
  - hard
  - 动态规划
Status: writing
Start-date: 2025-03-17 15:25
Finish-date: 
Modified-date: 2025-03-17 15:41
Publish: false
---


# 132. 分割回文串 II
[132. 分割回文串 II](https://leetcode.cn/problems/palindrome-partitioning-ii/)

## 题目描述
给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是回文串。

返回符合要求的 **最少分割次数** 。

**示例 1：**
**输入：** s = "aab"
**输出：** 1
**解释：** 只需一次分割就可将 _s_ 分割成 `["aa","b"]` 这样两个回文子串。

**示例 2：**
**输入：** s = "a"
**输出：** 0

**示例 3：**
**输入：** s = "ab"
**输出：** 1

**提示：**
- `1 <= s.length <= 2000`
- `s` 仅由小写英文字母组成

## 解题思路


**问题分析**  
给定一个字符串 `s`，要求将其分割为若干回文子串，并返回最小的分割次数。例如，输入 `"aab"` 需要切1次得到 `["aa", "b"]`。

**核心挑战**  
1. **高效预处理回文信息**：快速判断任意子串是否为回文。  
2. **动态规划求最小分割**：利用预处理信息，找到最少切割次数。


**算法设计**  
1. **预处理回文信息**  
   - 构建二维数组 `isPal[i][j]`，表示子串 `s[i...j]` 是否为回文。  
   - **状态转移**：  
     - `i == j` → 单字符，是回文。  
     - `s[i] == s[j]` 且 `i+1 >= j-1` → 双字符或中间无字符，是回文。  
     - `s[i] == s[j]` 且 `isPal[i+1][j-1] == true` → 长字符回文。

2. **动态规划求最小分割**  
   - `dp[i]` 表示前 `i+1` 个字符的最小分割次数。  
   - **初始状态**：`dp[i]` 初始化为最大值（`INT_MAX`）。  
   - **状态转移**：  
     - 若 `s[0...i]` 是回文，`dp[i] = 0`。  
     - 否则，遍历所有可能的分割点 `j`（`0 < j ≤ i`），若 `s[j...i]` 是回文，则 `dp[i] = min(dp[i], dp[j-1] + 1)`。



> [!tip]+ 关键点
> 1. **预处理回文子串**  
>    - 通过反向遍历 `i`，确保在计算 `isPal[i][j]` 时，`isPal[i+1][j-1]` 已确定。  
>    - 覆盖单字符、双字符及长字符的三种情况。
> 
> 2. **动态规划分割逻辑**  
>    - **直接回文**：若 `s[0...i]` 是回文，无需切割，`dp[i] = 0`。  
>    - **分割点枚举**：遍历 `j` 从 `1` 到 `i`，若 `s[j...i]` 是回文，则分割次数为 `dp[j-1] + 1`。  
>    - **避免越界**：`j` 从 `1` 开始，确保 `j-1 ≥ 0`。


## 代码实现

```cpp
class Solution {
public:
    int minCut(string s) {
        int n = s.size();
        if (n <= 1) return 0;

        // 预处理回文子串
        vector<vector<bool>> isPal(n, vector<bool>(n, false));
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (s[i] == s[j]) {
                    if (i + 1 <= j - 1) {
                        isPal[i][j] = isPal[i + 1][j - 1];
                    } else {
                        isPal[i][j] = true; // 单字符或相邻相同字符
                    }
                }
            }
        }

        // dp[i]表示前i+1个字符的最小切割次数
        vector<int> dp(n, INT_MAX);
        for (int i = 0; i < n; i++) {
            if (isPal[0][i]) {
                dp[i] = 0; // 整个子串是回文，无需切割
            } else {
                // 遍历分割点j，将子串分为s[0..j-1]和s[j..i]
                for (int j = 1; j <= i; j++) { // j从1开始，避免j-1=-1
                    if (isPal[j][i]) {
                        dp[i] = min(dp[i], dp[j - 1] + 1);
                    }
                }
            }
        }

        return dp[n - 1];
    }
};
```


### 示例分析

以 `s = "aab"` 为例：  
1. **预处理回文**：  
   - `isPal[0][0] = true`，`isPal[1][1] = true`，`isPal[2][2] = true`。  
   - `isPal[0][1] = false`，`isPal[0][2] = false`，`isPal[1][2] = true`（`"ab"` 不是回文，`"aab"` 不是回文，但 `"b"` 是回文）。  
2. **动态规划分割**：  
   - `dp[0] = 0`（`"a"` 是回文）。  
   - `dp[1]`：`s[0...1]` 不是回文，遍历 `j=1` → `isPal[1][1] = true`，`dp[1] = dp[0] + 1 = 1`。  
   - `dp[2]`：`s[0...2]` 不是回文，遍历 `j=2` → `isPal[2][2] = true` → `dp[2] = dp[1] + 1 = 2`；遍历 `j=1` → `isPal[1][2] = false`，最终 `dp[2] = 1`（分割为 `"aa"` 和 `"b"`）。


### 复杂度分析
- **时间复杂度**：O (n²)，预处理和动态规划各遍历一次二维数组。
- **空间复杂度**：O (n²)，存储回文数组和动态规划数组。

