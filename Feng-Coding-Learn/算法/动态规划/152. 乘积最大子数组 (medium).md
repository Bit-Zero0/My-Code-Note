---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-09 21:11
Finish-date: 
Modified-date: 2025-03-09 22:09
Publish: false
---


# 152. 乘积最大子数组
[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

## 题目描述
给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**
**输入:** nums = [2,3,-2,4]
**输出:** `6`
**解释:** 子数组 [2,3] 有最大乘积 6。

**示例 2:**

**输入:** nums = [-2,0,-1]
**输出:** 0
**解释:** 结果不能为 2, 因为 [-2,-1] 不是子数组。

**提示:**
- `1 <= nums.length <= 2 * 10^4`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数

## 解题思路

本问题要求找到数组中乘积最大的连续子数组。由于数组中可能包含负数，简单的贪心策略无法解决问题（例如负数相乘可能“负负得正”），因此需要动态规划思想，同时维护最大值和最小值两种状态。

#### 核心思路分析
1. **问题特征**  
   - **负数反转**：当前元素为负数时，可能使前面的最小乘积（负数）变成最大值。
   - **零截断**：当前元素为0时，子数组乘积归零，需要重新开始计算。
   - **动态连续性**：最大乘积可能由当前元素单独构成，或与前面连续子数组组合构成。

2. **状态定义**  
   - 定义两个动态规划数组：
     - `maxDp[i]`：以第 `i` 个元素结尾的子数组的最大乘积。
     - `minDp[i]`：以第 `i` 个元素结尾的子数组的最小乘积。

3. **状态转移逻辑**  
   - **候选值来源**：
     - 当前元素本身（例如前面子数组乘积为负，直接取当前元素）。
     - 当前元素与前一个最大乘积的乘积。
     - 当前元素与前一个最小乘积的乘积（应对负数反转场景）。
   - **更新规则**：
     - `maxDp[i] = max( nums[i], max(x, y) )`，其中 `x = maxDp[i-1]*nums[i]`, `y = minDp[i-1]*nums[i]`。
     - `minDp[i] = min( nums[i], min(x, y) )`，处理负负得正后的极小值。

4. **初始化与遍历**  
   - 初始化 `maxDp = minDp = 1`，使得第一个元素的处理逻辑一致。
   - 遍历时通过比较三个候选值更新状态。

5. **结果记录**  
   - 遍历过程中不断用 `maxDp[i]` 更新全局最大值 `result`。



#### 边界与极端情况
- **全负数数组**：如 `[-2, -3, -4]`，最大乘积由最后两个元素构成（-3*-4=12）。
- **含零的数组**：如 `[2, 0, 3]`，最大乘积为3。
- **单个元素**：如 `[-5]`，直接返回该元素。


### 代码实现及注释

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        // 定义动态规划数组：maxDp[i]表示以第i个元素结尾的子数组的最大乘积
        // minDp[i]表示以第i个元素结尾的子数组的最小乘积（处理负数反转场景）
        vector<int> maxDp(n + 1), minDp(n + 1);
        // 初始化：dp设为1，使得第一个元素的处理逻辑一致
        maxDp = minDp = 1;
        int result = INT_MIN; // 记录全局最大值
        
        for (int i = 1; i <= n; i++) {
            // 计算前一个状态的最大和最小乘积与当前元素的乘积
            int prevMin = minDp[i - 1] * nums[i - 1];
            int prevMax = maxDp[i - 1] * nums[i - 1];
            // 当前最大值可能来自三种情况：
            // 1. 当前元素本身（例如前面子数组乘积为负）
            // 2. 前一个最大乘积与当前元素的乘积
            // 3. 前一个最小乘积与当前元素的乘积（负数反转）
            maxDp[i] = max(nums[i - 1], max(prevMin, prevMax));
            // 当前最小值同理，用于后续可能的负数反转
            minDp[i] = min(nums[i - 1], min(prevMin, prevMax));
            // 更新全局最大值
            result = max(result, maxDp[i]);
        }
        return result;
    }
};
```

#### 复杂度分析
- **时间复杂度**：O(n)，只需一次遍历数组。
- **空间复杂度**：O(n)，使用两个长度为 `n+1` 的数组存储状态。可优化至 O(1)（见后续说明）。

