---
Type: Note
tags:
  - 算法
Status: writing
Start-date: 2025-02-24 15:18
Finish-date: 
Modified-date: 2025-02-24 15:36
Publish: false
---


# 931. 下降路径最小和
[931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)

## 题目描述
给你一个 `n x n` 的 **方形** 整数数组 `matrix` ，请你找出并返回通过 `matrix` 的**下降路径** 的 **最小和** 。

**下降路径** 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 `(row, col)` 的下一个元素应当是 `(row + 1, col - 1)`、`(row + 1, col)` 或者 `(row + 1, col + 1)` 。

**示例 1：**
![](https://pic.leetcode.cn/1729566253-aneDag-image.png)
**输入：** matrix = `[[2,1,3],[6,5,4],[7,8,9]]`
**输出：** 13
**解释：** 如图所示，为和最小的两条下降路径

**示例 2：**
![](https://pic.leetcode.cn/1729566282-dtXwRd-image.png)
**输入：** matrix = `[[-19,57],[-40,-5]]`
**输出：**-59
**解释：** 如图所示，为和最小的下降路径

**提示：**
- `n == matrix.length == matrix[i].length`
- `1 <= n <= 100`
- `-100 <= matrix[i][j] <= 100`

## 解题思路

**最小下降路径和（动态规划）**  
本题要求在给定的 `n x n` 矩阵中，找出从顶部到底部的路径，使得路径上的数字之和最小。路径每一步可以从正下方、左下方或右下方移动。  
采用动态规划解法，核心思想是：**逐层计算每个位置的最小路径和，通过状态转移方程将问题分解为子问题**。具体步骤如下：

1. **状态定义**  
定义 `dp[i][j]` 表示到达第 `i` 行第 `j` 列位置的最小路径和。  
- **设计技巧**：  
  将 `dp` 数组设计为 `(n+1) x (n+2)`，其中 `n+1` 行用于简化从首行开始的递推，`n+2` 列用于处理列边界问题（左右两侧用 `INT_MAX` 填充，避免越界判断）。


2. **状态转移方程**  
每个位置的最小路径和取决于其上一行的三个可能来源：  
- 正上方 (`dp[i-1][j]`)  
- 左上方 (`dp[i-1][j-1]`)  
- 右上方 (`dp[i-1][j+1]`)  
转移方程为：  
$$dp[i][j] = \min(dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]) + matrix[i-1][j-1]$$

**边界处理**：  
- 通过扩大 `dp` 数组的列范围，将无效位置（如 `j=0` 或 `j=n+1`）初始化为 `INT_MAX`，计算时自动排除无效值。


3. **初始化**  
- **虚拟首行**：`dp[0][*] = 0`，表示从虚拟顶层出发的初始状态。  
- **实际首行**：`dp[1][j] = matrix[0][j-1]`（通过状态转移方程自动计算）。


4. **遍历顺序**  
按层从上到下遍历，每层从左到右计算每个位置的最小路径和。


5. **结果提取**  
最终结果为 `dp[n][1..n]` 中的最小值，即最后一行所有可能终点的最小路径和。



> [!tip]+ 关键点解析
> 1. **虚拟首行设计**：  
>    通过增加虚拟行简化初始条件，避免单独处理第一行的逻辑。
> 2. **扩大列范围**：  
>    左右两侧的 `INT_MAX` 使得计算时无需判断 `j-1` 或 `j+1` 是否越界，代码更简洁。
> 3. **状态转移方向**：  
>    每个位置的值仅依赖上一层的三个相邻位置，确保无后效性。

## 代码实现
```cpp
class Solution {
public:
    int minFallingPathSum(vector<vector<int>>& matrix) {
        int n = matrix.size();
        // 创建动态规划数组，多出1行和2列用于简化边界处理
        vector<vector<int>> dp(n + 1, vector<int>(n + 2, INT_MAX));
        
        // 初始化虚拟首行，所有位置初始和为0（作为起点）
        for (int i = 0; i < dp[0].size(); i++)
            dp[0][i] = 0;

        // 逐层计算最小路径和
        for (int i = 1; i <= n; i++) {           // 从第1行到第n行（对应matrix的0~n-1行）
            for (int j = 1; j <= n; j++) {      // 从第1列到第n列（对应matrix的0~n-1列）
                // 取上一层的左、中、右三个方向的最小值，加上当前矩阵值
                dp[i][j] = min({dp[i-1][j+1], dp[i-1][j], dp[i-1][j-1]}) + matrix[i-1][j-1];
            }
        }

        // 遍历最后一层，找到最小路径和
        int result = INT_MAX;
        for (int i = 1; i <= n; i++)
            result = min(dp[n][i], result);
        
        return result;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n²)  
  双重循环遍历 `n x n` 的矩阵，每个状态的计算为常数时间。
- **空间复杂度**：O(n²)  
  `dp` 数组占用 `(n+1) x (n+2)` 的空间，与输入规模成平方关系。







