---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-24 20:55
Finish-date: 
Modified-date: 2025-01-24 22:12
Publish: false
---


# LCR 166. 珠宝的最高价值
[LCR 166. 珠宝的最高价值](https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/)

## 题目描述
现有一个记作二维矩阵 `frame` 的珠宝架，其中 `frame[i][j]` 为该位置珠宝的价值。拿取珠宝的规则为：

- 只能从架子的左上角开始拿珠宝
- 每次可以移动到右侧或下侧的相邻位置
- 到达珠宝架子的右下角时，停止拿取

注意：珠宝的价值都是大于 0 的。除非这个架子上没有任何珠宝，比如 `frame = [[0]]`。

**示例 1：**
**输入：** frame = `[[1,3,1],[1,5,1],[4,2,1]]`
**输出：**`12`
**解释：** 路径 1→3→5→2→1 可以拿到最高价值的珠宝

**提示：**
- `0 < frame.length <= 200`
- `0 < frame[0].length <= 200`

## 解题思路
1. 状态定义
	- 定义 `dp[i][j]` 表示从起点 `(0, 0)` 到达格子 `(i-1, j-1)` 所能收集到的礼物的最大价值。
	- 为了方便处理边界条件，`dp` 数组的大小为 `(m+1) x (n+1)`，其中 `dp[0][*]` 和 `dp[*][0]` 是辅助边界。
  2. 状态转移方程
	- 对于每个格子 `(i-1, j-1)`，可以从上方 `(i-2, j-1)` 或左方 `(i-1, j-2)` 移动过来。
	- 因此，到达 `(i-1, j-1)` 的最大价值为：
```
dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + frame[i-1][j-1]
```
#### 3. 初始条件
- `dp[0][*]` 和 `dp[*][0]` 的值均为 0，因为这些位置是辅助边界，没有实际意义。

#### 4. 填表过程
- 从 `i = 1` 到 `m`，`j = 1` 到 `n`，逐步计算 `dp[i][j]`。
- 每次计算 `dp[i][j]` 时，依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`。

#### 5. 最终结果
- `dp[m][n]` 表示从起点 `(0, 0)` 到终点 `(m-1, n-1)` 所能收集到的礼物的最大价值。


### 算法流程
1. **初始化：**
    - 获取矩阵的行数 `m` 和列数 `n`。
    - 初始化二维动态规划数组 `dp`，大小为 `(m+1) x (n+1)`，所有值初始化为 `0`。
        
2. **遍历矩阵：**
    - 遍历每个位置 `(i, j)`：
        - 根据状态转移方程计算 `dp[i][j]`。
3. **返回结果：**
    - 返回 `dp[m][n]`，即从起点到终点的最大价值路径。

## C++代码
```cpp
class Solution {
public:
    int jewelleryValue(vector<vector<int>>& frame) {
        int m = frame.size(), n = frame[0].size(); // 棋盘的行数和列数
        vector<vector<int>> dp(m + 1, vector<int>(n + 1)); // 定义 dp 数组

        // 填表过程
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                // 状态转移方程：从上方或左方移动过来，取最大值并加上当前格子的价值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + frame[i - 1][j - 1];
            }
        }

        return dp[m][n]; // 返回从起点到终点的最大价值
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(m * n)`，其中 `m` 和 `n` 分别是棋盘的行数和列数。我们需要遍历整个棋盘。
- **空间复杂度**：`O(m * n)`，用于存储动态规划数组。
