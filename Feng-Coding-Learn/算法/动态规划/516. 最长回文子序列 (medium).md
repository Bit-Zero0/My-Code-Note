---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-17 15:41
Finish-date: 
Modified-date: 2025-03-17 16:00
Publish: false
---


# 516. 最长回文子序列
[516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

## 题目描述


## 解题思路

本题的目标是找到字符串中最长的回文子序列的长度。回文子序列不要求字符连续，但需要保持相对顺序。例如，字符串 `"bbbab"` 的最长回文子序列是 `"bbbb"`，长度为4。通过动态规划可以高效解决此问题。



1. **定义动态规划状态**
	定义**二维数组 `dp[i][j]`，表示子串 `s[i...j]` 的最长回文子序列长度**。我们需要填充 `dp` 数组，最终返回 `dp[0][n-1]`（整个字符串的最长回文子序列长度）。


2. **初始化边界条件**
	- **单字符回文**：每个字符本身是一个长度为1的回文，因此 `dp[i][i] = 1`。


3. **状态转移方程**
	- **情况1：首尾字符相等**（`s[i] == s[j]`）  
	  此时，首尾字符可以加入回文子序列，因此：  
	  `dp[i][j] = dp[i+1][j-1] + 2`  
	  即在中间子串 `s[i+1...j-1]` 的最长回文长度基础上，加上首尾两个字符。
	
	- **情况2：首尾字符不等**（`s[i] != s[j]`）  
	  此时，最长回文子序列要么在 `s[i...j-1]` 中，要么在 `s[i+1...j]` 中，取两者的最大值：  `dp[i][j] = max(dp[i][j-1], dp[i+1][j])`


4. **填表顺序**
	- **从后往前遍历**：外层循环 `i` 从字符串末尾向前遍历，内层循环 `j` 从 `i+1` 开始向后遍历。  这种顺序确保在计算 `dp[i][j]` 时，子问题 `dp[i+1][j-1]`、`dp[i][j-1]` 和 `dp[i+1][j]` 已经计算完成。

5. **最终结果**
	返回 `dp[0][n-1]`，即整个字符串的最长回文子序列长度。


## 代码实现
```cpp
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        // dp[i][j] 表示子串 s[i..j] 的最长回文子序列长度
        vector<vector<int>> dp(n, vector<int>(n));

        // 从后向前遍历，保证子问题已计算
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1; // 单字符回文长度为1
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    // 首尾字符相等：中间子串长度 + 2
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    // 首尾不等：取左半部分或右半部分的最大值
                    dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]);
                }
            }
        }
        return dp[0][n - 1]; // 返回整个字符串的最长回文子序列长度
    }
};
```



## 复杂度分析
- **时间复杂度**：双重循环遍历所有子串，时间复杂度为 O(n²)。
- **空间复杂度**：使用二维数组 `dp`，空间复杂度为 O(n²)。  
  （可通过状态压缩优化到 O(n)，但代码保持直观性未做优化。）



### 关键点解释
- **填表顺序**：从后向前遍历确保子问题的解已就绪。
- **状态转移**：根据首尾字符是否相等，分别处理两种情况。
- **边界条件**：单字符回文的初始化是递推的基础。


