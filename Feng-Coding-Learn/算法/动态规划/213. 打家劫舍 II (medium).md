---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-03 22:50
Finish-date: 
Modified-date: 2025-03-04 18:13
Publish: false
---


# 213. 打家劫舍 II
[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

## 题目描述
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**示例 1：**
**输入：** nums = `[2,3,2]`
**输出：** 3
**解释：** 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

**示例 2：**
**输入：** nums = `[1,2,3,1]`
**输出：** 4
**解释：** 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 3：**
**输入：** nums = `[1,2,3]`
**输出：** 3

**提示：**
- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 1000`


## 解题思路
本题是「[[面试题 17.16. 按摩师 (easy)|打家劫舍]]」问题的进阶版，房屋排列成环形结构，首尾相连。核心难点在于如何处理环形结构带来的约束：**第一个房屋和最后一个房屋不能同时被偷**。我们可以将环形问题拆解为两个线性问题来解决。

> [!tip]+ 环形问题的拆解
> 在环形排列的房屋中选择不相邻的房屋进行偷窃，需要将问题拆分为两种情况处理：
> 1. 1.**偷窃第一个房屋**：此时不能偷窃最后一个房屋，且第二个房屋也不能偷窃，因此有效范围为第3到倒数第2个房屋（索引2到n-2）
> 2. 2.**不偷窃第一个房屋**：此时可以偷窃最后一个房屋，有效范围为第2到最后一个房屋（索引1到n-1）


对于每个线性子问题，我们使用动态规划来解决。定义两个状态数组：

- `steal[i]`：表示偷第 `i` 个房屋时，前 `i` 个房屋能获得的最大金额。
- `notSteal[i]`：表示不偷第 `i` 个房屋时，前 `i` 个房屋能获得的最大金额。

**状态转移方程**：
- `steal[i] = notSteal[i-1] + nums[i]`：偷第 `i` 个房屋时，第 `i-1` 个房屋不能偷，取 `notSteal[i-1]` 加上当前房屋金额。
- `notSteal[i] = max(steal[i-1], notSteal[i-1])`：不偷第 `i` 个房屋时，前 `i-1` 个房屋可偷可不偷，取两者较大值。

**初始条件**：
- `steal[left] = nums[left]`：在起始位置，偷该房屋的金额为 `nums[left]`。
- `notSteal[left] = 0`：不偷起始位置时，金额为 0。

最终，线性问题的解为 `max(steal[right], notSteal[right])`，即最后一个位置偷或不偷的较大值。

> [!tip]+ 关键点解析
> 在环形房屋问题中，偷第一个房屋时，第二个和最后一个房屋不可偷。原代码将问题拆分为两种情况：
> 
> ​1. 偷第一个房屋：此时必须跳过第二个房屋（索引`1`），且最后一个房屋（索引`n-1`）不可偷。因此，剩余可偷范围为索引`2`到`n-2`。这通过`nums[0] + _rob(nums, 2, n-2)`实现，确保计算时不会包含被跳过的房屋。
> 
> ​2. 不偷第一个房屋：此时可偷范围为索引1到n-1，最后一个房屋是否可偷由动态规划自然处理。
> 
> 若错误调用_rob(nums, 0, n-2)，函数内部可能允许偷第二个房屋（索引1），导致与偷第一个房屋相邻，违反规则。因此，正确做法是跳过第二个房屋，直接计算后续范围。



```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();

        // 将环形问题拆分为两个线性问题，取较大值：
        // 1. 偷第一个房屋，则不能偷最后一个，计算nums[0] + 偷取范围[2, n-2]
        // 2. 不偷第一个房屋，可偷最后一个，计算偷取范围[1, n-1]
        return max(nums[0] + _rob(nums , 2 , n - 2) , _rob(nums , 1 , n - 1));
    }

    // 辅助函数：计算nums数组中从left到right范围内的最大偷窃金额
    int _rob(vector<int>& nums, int left, int right) {
        if (left > right) return 0; // 无效范围直接返回0
        int n = nums.size();
        vector<int> steal(n), notSteal(n); // 动态规划状态数组

        steal[left] = nums[left]; // 初始化：偷left位置的金额为nums[left]
        for (int i = left + 1; i <= right; i++) {
            // 当前偷i：必须不偷i-1，取notSteal[i-1] + nums[i]
            steal[i] = notSteal[i - 1] + nums[i];
            // 当前不偷i：取i-1偷或不偷的较大值
            notSteal[i] = max(steal[i - 1], notSteal[i - 1]);
        }
        return max(steal[right], notSteal[right]); // 返回最终状态的较大值
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)。拆解为两次线性动态规划，每次时间复杂度为 O(n)。
- **空间复杂度**：O(n)。动态规划数组的空间开销，可优化为 O(1)（使用滚动变量）。