---
Type: Note
tags:
  - 算法
  - medium
  - 动态规划
  - 递归
  - 记忆化搜索
Status: writing
Start-date: 2025-03-12 11:53
Finish-date: 
Modified-date: 2025-03-20 19:29
Publish: false
---


# 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

## 题目描述
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。


**示例 1：**
**输入：** nums = [10,9,2,5,3,7,101,18]
**输出：** 4
**解释：** 最长递增子序列是 [2,3,7,101]，因此长度为 4 。

**示例 2：**
**输入：** nums = [0,1,0,3,2,3]
**输出：** 4

**示例 3：**
**输入：** nums = [7,7,7,7,7,7,7]
**输出：** 1

**提示：**
- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

## 解题思路(动态规划)

最长递增子序列（LIS）问题要求找到给定整数数组中最长的严格递增子序列的长度。子序列的元素在原数组中可以不连续，但必须保持顺序。

**动态规划解法**  
1. **状态定义**  
   - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
   
2. **状态转移方程**  
   - 对于每个元素 `i`，遍历其之前的所有元素 `j`（`j < i`）：
     - 如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
   - 每次更新 `dp[i]` 后，记录全局最大值。

3. **初始化**  
   - `dp` 数组初始化为全 `1`，因为每个元素自身至少可以构成长度为 1 的子序列。

4. **遍历顺序**  
   - 外层循环遍历所有元素（`i` 从 `1` 到 `n-1`）。
   - 内层循环遍历 `i` 之前的所有元素（`j` 从 `0` 到 `i-1`），检查是否满足递增条件。

5. **结果**  
   - 遍历所有 `dp[i]`，取最大值作为最终结果。

**时间复杂度**  
- 时间复杂度：`O(n²)`，双重循环遍历数组。
- 空间复杂度：`O(n)`，存储 `dp` 数组。


### 代码实现

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        vector<int> dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长子序列长度
        int result = 1;       // 至少有一个元素，初始化为1
        
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) { // 正序遍历，检查所有 j < i
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            result = max(result, dp[i]); // 更新全局最大值
        }
        
        return result;
    }
};
```

### 复杂度分析
**时间复杂度**
- 双重循环遍历数组，时间复杂度为 **O($n²$)**，适用于中等规模的数据（如 `n ≤ 10^4`）。

**空间复杂度**
 -  空间复杂度为O($n^2$) , 开辟了一个为n 的 dp数组.


## 记忆化搜索

使用**记忆化递归**（自顶向下动态规划），通过递归探索所有可能的子序列，并利用记忆化存储中间结果，避免重复计算。

### 关键步骤
1. **状态定义**：  
   `memo[pos]` 表示从位置 `pos` 开始的最长递增子序列的长度。

2. **递归逻辑**：  
   对于当前位置 `pos`，遍历其后所有位置 `j`，若 `nums[j] > nums[pos]`，则递归计算 `memo[j]`，并取最大值加 1。

3. **记忆化优化**：  
   用数组 `memo` 存储已计算的结果，避免重复递归。

4. **遍历所有起点**：  
   最终答案是所有起点的最长子序列长度的最大值。


> [!tip]+ 关键点
> 1. **记忆化存储**：  
>    通过 `memo` 数组避免重复计算相同子问题，将指数级时间复杂度优化为多项式级。
> 
> 2. **递归方向**：  
>    从后往前递归，确保后续位置的子问题先被计算，避免重复探索。
> 

### 代码实现
```cpp
#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, 0); // 记忆化数组，初始化为0

        function<int(int)> dfs = [&](int pos) -> int {
            if (memo[pos] > 0) return memo[pos]; // 已计算过，直接返回

            int result = 1; // 至少包含自身
            for (int j = pos + 1; j < n; ++j) {
                if (nums[j] > nums[pos]) {
                    // 递归计算后续位置的最长长度，并更新当前结果
                    result = max(result, dfs(j) + 1);
                }
            }
            memo[pos] = result; // 存储结果
            return result;
        };

        int answer = 0;
        for (int i = 0; i < n; ++i) {
            answer = max(answer, dfs(i)); // 遍历所有起点，取最大值
        }
        return answer;
    }
};
```


#### 示例分析
以 `nums = [10,9,2,5,3,7,101,18]` 为例：
1. **起点选择**：遍历所有元素，每个元素都可能作为子序列的起点。
2. **递归展开**：  
   - 以 `pos=2`（元素 `2`）为例，后续元素 `5`、`3`、`7`、`101`、`18` 中比 `2` 大的有 `5`、`3`、`7`、`101`、`18`。
   - 递归计算每个后续位置的最长子序列长度，取最大值加 1。
3. **记忆化加速**：  
   例如，当计算 `pos=3`（元素 `5`）时，若已计算过 `pos=4`（元素 `3`）的结果，则直接复用。

#### 复杂度分析
- **时间复杂度**：$O(n^2)$  
  每个位置 `pos` 需要遍历其后所有 `j`（最多 `n` 次），总共有 `n` 个起点。

- **空间复杂度**：$O(n)$  
  记忆化数组 `memo` 的大小为 `n`，递归栈的深度最大为 `n`。






