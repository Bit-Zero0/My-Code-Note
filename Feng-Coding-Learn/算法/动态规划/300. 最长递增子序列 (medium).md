---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-12 11:53
Finish-date: 
Modified-date: 2025-03-12 12:18
Publish: false
---


# 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

## 题目描述
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。


**示例 1：**
**输入：** nums = [10,9,2,5,3,7,101,18]
**输出：** 4
**解释：** 最长递增子序列是 [2,3,7,101]，因此长度为 4 。

**示例 2：**
**输入：** nums = [0,1,0,3,2,3]
**输出：** 4

**示例 3：**
**输入：** nums = [7,7,7,7,7,7,7]
**输出：** 1

**提示：**
- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

## 解题思路

最长递增子序列（LIS）问题要求找到给定整数数组中最长的严格递增子序列的长度。子序列的元素在原数组中可以不连续，但必须保持顺序。

**动态规划解法**  
1. **状态定义**  
   - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
   
2. **状态转移方程**  
   - 对于每个元素 `i`，遍历其之前的所有元素 `j`（`j < i`）：
     - 如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
   - 每次更新 `dp[i]` 后，记录全局最大值。

3. **初始化**  
   - `dp` 数组初始化为全 `1`，因为每个元素自身至少可以构成长度为 1 的子序列。

4. **遍历顺序**  
   - 外层循环遍历所有元素（`i` 从 `1` 到 `n-1`）。
   - 内层循环遍历 `i` 之前的所有元素（`j` 从 `0` 到 `i-1`），检查是否满足递增条件。

5. **结果**  
   - 遍历所有 `dp[i]`，取最大值作为最终结果。

**时间复杂度**  
- 时间复杂度：`O(n²)`，双重循环遍历数组。
- 空间复杂度：`O(n)`，存储 `dp` 数组。



## 代码实现

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        vector<int> dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长子序列长度
        int result = 1;       // 至少有一个元素，初始化为1
        
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) { // 正序遍历，检查所有 j < i
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            result = max(result, dp[i]); // 更新全局最大值
        }
        
        return result;
    }
};
```

### 复杂度分析
**时间复杂度**
- 双重循环遍历数组，时间复杂度为 **O($n²$)**，适用于中等规模的数据（如 `n ≤ 10^4`）。

**空间复杂度**
 -  空间复杂度为O($n^2$) , 开辟了一个为n 的 dp数组.