---
Type: Note
tags:
  - 算法
  - medium
  - 动态规划
  - 递归
  - 记忆化搜索
  - 贪心算法
Status: writing
Start-date: 2025-03-12 11:53
Finish-date: 
Modified-date: 2025-03-21 18:39
Publish: false
---


# 300. 最长递增子序列
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

## 题目描述
给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。


**示例 1：**
**输入：** nums = [10,9,2,5,3,7,101,18]
**输出：** 4
**解释：** 最长递增子序列是 [2,3,7,101]，因此长度为 4 。

**示例 2：**
**输入：** nums = [0,1,0,3,2,3]
**输出：** 4

**示例 3：**
**输入：** nums = [7,7,7,7,7,7,7]
**输出：** 1

**提示：**
- `1 <= nums.length <= 2500`
- `-10^4 <= nums[i] <= 10^4`

## 解题思路(动态规划)

最长递增子序列（LIS）问题要求找到给定整数数组中最长的严格递增子序列的长度。子序列的元素在原数组中可以不连续，但必须保持顺序。

**动态规划解法**  
1. **状态定义**  
   - `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。
   
2. **状态转移方程**  
   - 对于每个元素 `i`，遍历其之前的所有元素 `j`（`j < i`）：
     - 如果 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j] + 1)`。
   - 每次更新 `dp[i]` 后，记录全局最大值。

3. **初始化**  
   - `dp` 数组初始化为全 `1`，因为每个元素自身至少可以构成长度为 1 的子序列。

4. **遍历顺序**  
   - 外层循环遍历所有元素（`i` 从 `1` 到 `n-1`）。
   - 内层循环遍历 `i` 之前的所有元素（`j` 从 `0` 到 `i-1`），检查是否满足递增条件。

5. **结果**  
   - 遍历所有 `dp[i]`，取最大值作为最终结果。

**时间复杂度**  
- 时间复杂度：`O(n²)`，双重循环遍历数组。
- 空间复杂度：`O(n)`，存储 `dp` 数组。


### 代码实现

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        vector<int> dp(n, 1); // dp[i] 表示以 nums[i] 结尾的最长子序列长度
        int result = 1;       // 至少有一个元素，初始化为1
        
        for (int i = 1; i < n; ++i) {
            for (int j = 0; j < i; ++j) { // 正序遍历，检查所有 j < i
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
            result = max(result, dp[i]); // 更新全局最大值
        }
        
        return result;
    }
};
```

### 复杂度分析
**时间复杂度**
- 双重循环遍历数组，时间复杂度为 **O($n²$)**，适用于中等规模的数据（如 `n ≤ 10^4`）。

**空间复杂度**
 -  空间复杂度为O($n^2$) , 开辟了一个为n 的 dp数组.


## 记忆化搜索

使用**记忆化递归**（自顶向下动态规划），通过递归探索所有可能的子序列，并利用记忆化存储中间结果，避免重复计算。

### 关键步骤
1. **状态定义**：  
   `memo[pos]` 表示从位置 `pos` 开始的最长递增子序列的长度。

2. **递归逻辑**：  
   对于当前位置 `pos`，遍历其后所有位置 `j`，若 `nums[j] > nums[pos]`，则递归计算 `memo[j]`，并取最大值加 1。

3. **记忆化优化**：  
   用数组 `memo` 存储已计算的结果，避免重复递归。

4. **遍历所有起点**：  
   最终答案是所有起点的最长子序列长度的最大值。


> [!tip]+ 关键点
> 1. **记忆化存储**：  
>    通过 `memo` 数组避免重复计算相同子问题，将指数级时间复杂度优化为多项式级。
> 
> 2. **递归方向**：  
>    从后往前递归，确保后续位置的子问题先被计算，避免重复探索。
> 

### 代码实现
```cpp
#include <vector>
#include <functional>
using namespace std;

class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, 0); // 记忆化数组，初始化为0

        function<int(int)> dfs = [&](int pos) -> int {
            if (memo[pos] > 0) return memo[pos]; // 已计算过，直接返回

            int result = 1; // 至少包含自身
            for (int j = pos + 1; j < n; ++j) {
                if (nums[j] > nums[pos]) {
                    // 递归计算后续位置的最长长度，并更新当前结果
                    result = max(result, dfs(j) + 1);
                }
            }
            memo[pos] = result; // 存储结果
            return result;
        };

        int answer = 0;
        for (int i = 0; i < n; ++i) {
            answer = max(answer, dfs(i)); // 遍历所有起点，取最大值
        }
        return answer;
    }
};
```


#### 示例分析
以 `nums = [10,9,2,5,3,7,101,18]` 为例：
1. **起点选择**：遍历所有元素，每个元素都可能作为子序列的起点。
2. **递归展开**：  
   - 以 `pos=2`（元素 `2`）为例，后续元素 `5`、`3`、`7`、`101`、`18` 中比 `2` 大的有 `5`、`3`、`7`、`101`、`18`。
   - 递归计算每个后续位置的最长子序列长度，取最大值加 1。
3. **记忆化加速**：  
   例如，当计算 `pos=3`（元素 `5`）时，若已计算过 `pos=4`（元素 `3`）的结果，则直接复用。

#### 复杂度分析
- **时间复杂度**：$O(n^2)$  
  每个位置 `pos` 需要遍历其后所有 `j`（最多 `n` 次），总共有 `n` 个起点。

- **空间复杂度**：$O(n)$  
  记忆化数组 `memo` 的大小为 `n`，递归栈的深度最大为 `n`。



## 贪心策略

本问题要求找到数组中最长严格递增子序列（LIS）的长度。核心思路是通过**贪心策略+二分查找**优化时间复杂度，维护一个记录递增序列关键值的数组，将时间复杂度从O(n²)优化至O(n log n)。

> [!tip]+ 关键点
> 1. **贪心策略设计**：维护数组`len[]`，其中`len[i]`表示长度为`i+1`的递增子序列的最小末尾元素。通过维护最小末尾元素，为后续扩展更长的子序列提供可能。
> 2. **二分查找优化**：当新元素无法扩展当前最长子序列时，通过二分查找找到第一个大于等于该元素的位置并替换，保持`len[]`数组的单调性。
> 3. **长度等价性证明**：虽然`len[]`中的元素不一定是真实LIS序列，但其长度与LIS长度严格相等。

#### 算法步骤
1. **初始化**：将第一个元素加入`len[]`数组。
2. **遍历数组**：
   - 若当前元素大于`len[]`末尾元素：追加到`len[]`
   - 否则：二分查找替换位置，更新`len[]`
3. **返回结果**：`len[]`的长度即为LIS长度


### 示例解析
以`nums = [10,9,2,5,3,7,101,18]`为例：
1. **初始化**：`len = [10]`
2. **处理9**：替换10 → `len = [9]`
3. **处理2**：替换9 → `len = [2]`
4. **处理5**：追加 → `len = [2,5]`
5. **处理3**：替换5 → `len = [2,3]`
6. **处理7**：追加 → `len = [2,3,7]`
7. **处理101**：追加 → `len = [2,3,7,101]`
8. **处理18**：替换101 → `len = [2,3,7,18]`

最终长度4，对应可能的LIS如`[2,3,7,18]`或`[2,5,7,101]`等。虽然`len[]`中的序列不一定是真实LIS，但长度严格正确。



### 代码实现
```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n == 0) return 0;

        vector<int> len;
        len.push_back(nums[0]); // 初始化第一个元素

        for(int i = 1; i < n; i++) {
            if(nums[i] > len.back()) { // 可扩展更长子序列
                len.push_back(nums[i]);
            } else { // 优化现有子序列结构
                // 二分查找第一个≥nums[i]的位置
                int left = 0, right = len.size() - 1;
                while(left < right) {
                    int mid = (left + right) >> 1;
                    if(nums[i] > len[mid]) {
                        left = mid + 1; // 缩小左边界
                    } else {
                        right = mid;    // 缩小右边界
                    }
                }
                len[left] = nums[i]; // 替换为更小的末尾元素
            }
        }
        return len.size(); // 数组长度即LIS长度
    }
};
```


### 正确性证明

#### 1. 策略定义
维护数组`len[]`满足以下性质：
- 严格递增：`len[0] < len[1] < ... < len[m-1]`
- 对于任意长度`k+1`的递增子序列，其末尾元素必定 ≥ `len[k]`

#### 2. 贪心选择性证明
**命题**：每次替换操作不会破坏已有长度的最优性

**归纳证明**：
- **基例**：初始时`len = [nums[0]]`，满足长度为1的LIS
- **归纳假设**：处理前`i`个元素后，`len[]`保存各长度的最小末尾
- **归纳步骤**：
  - **情况1**（追加元素）：当`nums[i] > len.back()`，直接扩展长度，显然保持性质
  - **情况2**（替换元素）：设找到位置`pos`使得`len[pos] ≥ nums[i]`
    - 替换后`len[pos] = nums[i]`，更小的末尾元素为后续扩展提供可能
    - 所有长度`≤ pos+1`的子序列仍满足末尾元素 ≥ 新`len[pos]`

#### 3. 最优子结构证明
**命题**：最终`len[]`长度等于LIS的真实长度

**反证法**：
- 假设存在真实LIS长度为`L`，但算法得到长度`L' < L`
- 根据`len[]`定义，必须存在某个`k`使得`len[k]`未被更新到足够小，导致无法扩展长度
- 但每次替换操作都保证`len[]`记录最小末尾元素，矛盾

#### 4. 单调性保持证明
**数学推导**：
- 二分查找条件`nums[i] > len[mid]`确保`len[]`始终严格递增
- 替换操作后新的`len[pos] = nums[i]`，由于`nums[i] ≤ len[pos]`且`nums[i] > len[pos-1]`（由查找条件保证），单调性不变


### 复杂度分析
- **时间复杂度**：O(n log n)  
  每个元素最多经历一次二分查找（O(log n)）
- **空间复杂度**：O(n)  
  `len[]`数组最坏情况存储完整递增序列






