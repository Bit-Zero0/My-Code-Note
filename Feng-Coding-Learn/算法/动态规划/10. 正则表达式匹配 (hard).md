---
Type: Note
tags:
  - 算法
  - hard
  - 动态规划
Status: writing
Start-date: 2025-03-20 22:50
Finish-date: 
Modified-date: 2025-03-21 14:11
Publish: false
---


# 10. 正则表达式匹配
[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)

## 题目描述
给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

 

**示例 1：**
**输入：** s = "aa", p = "a"
**输出：** false
**解释：**"a" 无法匹配 "aa" 整个字符串。

**示例 2:**
**输入：** s = "aa", p = "a*"
**输出：** true
**解释：** 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。

**示例 3：**
**输入：** s = "ab", p = ".*"
**输出：** true
**解释：**".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

**提示：**
- `1 <= s.length <= 20`
- `1 <= p.length <= 20`
- `s` 只包含从 `a-z` 的小写字母。
- `p` 只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。
- 保证每次出现字符 `*` 时，前面都匹配到有效的字符

## 解题思路 (动态规划)

本题要求判断字符串 `s` 是否匹配包含通配符 `.` 和 `*` 的正则表达式 `p`。其中，`.` 匹配任意单个字符，`*` 匹配零个或多个前面的元素。例如，`s = "aab"` 和 `p = "c*a*b"` 应返回 `true`，因为 `c*` 可以匹配空，`a*` 匹配两个 `a`，`b` 匹配 `b`。


1. **动态规划定义**：
   - 定义二维数组 `dp[i][j]`，表示 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符是否匹配。
2. **初始化**：
   - **空字符串匹配**：`dp[0][0] = true`，表示两个空字符串匹配。
   - **处理模式 `p` 前缀的 `*`**：若 `p` 的前 `j` 个字符形如 `x*`（如 `a*`），则 `dp[0][j] = true`，因为 `*` 可以匹配空字符串。
3. **状态转移**：
   - **当前字符为 `*`**：
     - **匹配零次**：忽略 `*` 及其前一个字符，状态继承自 `dp[i][j-2]`。
     - **匹配一次或多次**：当 `p[j-1]` 与 `s[i]` 匹配（字符相等或 `p[j-1]` 为 `.`），且前 `i-1` 个字符已匹配到当前模式 `j`，则 `dp[i][j]` 为 `true`。
     - 综上：`dp[i][j] = dp[i][j-2] || ( (p[j-1] == '.' || p[j-1] == s[i]) && dp[i-1][j] )`
   - **其他字符**：
     - 若 `s[i]` 和 `p[j]` 匹配（字符相等或 `p[j]` 为 `.`），且前 `i-1` 和 `j-1` 的位置已匹配，则 `dp[i][j] = true`。


> [!tip]+ 关键点
> 1. **哨兵空格**：在 `s` 和 `p` 前添加空格，避免处理空字符串时的边界问题。
> 2. **`*` 的状态转移**：
>    - **匹配零次**：直接继承忽略 `*` 及其前驱字符的结果。
>    - **匹配多次**：需当前字符匹配，并确保前一步已匹配。
> 3. **初始化逻辑**：正确处理模式 `p` 前缀中的 `x*` 结构，确保空字符串匹配正确。


### 代码实现
```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        // 添加哨兵空格，简化空字符串处理
        s = ' ' + s, p = ' ' + p;
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));

        // 初始化：空字符串匹配
        dp[0][0] = true;
        // 处理模式p前缀中的"x*"结构（*匹配零次）
        for (int j = 2; j <= n; j += 2) {
            if (p[j] == '*') dp[0][j] = true;
            else break; // 非*字符，后续无法匹配空字符串
        }

        // 动态规划填表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j] == '*') {
                    // 状态转移：匹配零次 || 匹配一次或多次
                    dp[i][j] = dp[i][j - 2] || 
                              ((p[j - 1] == '.' || p[j - 1] == s[i]) && dp[i - 1][j]);
                } else {
                    // 当前字符匹配，且前i-1和j-1位置已匹配
                    dp[i][j] = (p[j] == '.' || p[j] == s[i]) && dp[i - 1][j - 1];
                }
            }
        }
        return dp[m][n];
    }
};
```

#### 代码分析
- **当 `p[j] == '*'` 时**：
    - `dp[i][j - 2]`：表示 `*` 让前面的字符出现 0 次，此时只需要看 `s` 的前 `i` 个字符和 `p` 的前 `j - 2` 个字符是否匹配。
    - `(p[j - 1] == '.' || p[j - 1] == s[i]) && dp[i - 1][j]`：表示 `*` 让前面的字符出现至少 1 次。如果 `p[j - 1]` 是 `.` 或者和 `s[i]` 相等，并且 `s` 的前 `i - 1` 个字符和 `p` 的前 `j` 个字符匹配，那么 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符也匹配。
- **当 `p[j] != '*'` 时**：
    - 如果 `p[j]` 是 `.` 或者和 `s[i]` 相等，并且 `s` 的前 `i - 1` 个字符和 `p` 的前 `j - 1` 个字符匹配，那么 `s` 的前 `i` 个字符和 `p` 的前 `j` 个字符也匹配。


#### 复杂度分析
- **时间复杂度**：双重循环遍历字符串，时间复杂度为 O(m×n)。
- **空间复杂度**：使用二维数组 `dp`，空间复杂度为 O(m×n)。  

