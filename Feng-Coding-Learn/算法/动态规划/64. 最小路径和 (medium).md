---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-02-24 15:31
Finish-date: 
Modified-date: 2025-03-04 18:14
Publish: false
---


# 64. 最小路径和
[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

## 题目描述
给定一个包含非负整数的 `_m_ x _n_` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)
**输入：** grid = `[[1,3,1],[1,5,1],[4,2,1]]`
**输出：** 7
**解释：** 因为路径 1→3→1→1→1 的总和最小。

**示例 2：**
**输入：** grid = `[[1,2,3],[4,5,6]]`
**输出：** 12

**提示：**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## 解题思路

本题要求在给定的 `m x n` 网格中，找到从左上角到右下角的最小路径和，每次只能向下或向右移动。采用动态规划解法，核心思想是：**逐点计算当前位置的最小路径和，通过状态转移方程将问题分解为左侧和上侧的子问题**。具体步骤如下：



1. **状态定义**  
定义 `dp[i][j]` 表示到达网格第 `i` 行第 `j` 列（对应原网格 `grid[i-1][j-1]`）的最小路径和。  
- **设计技巧**：  
  将 `dp` 数组扩展为 `(n+1) x (m+1)`，并在 `dp[0][1]` 和 `dp[1][0]` 初始化为 `0`，避免单独处理第一行和第一列的边界条件。


2. **状态转移方程**  
每个位置的最小路径和取决于其左侧和上侧的最小路径和：  
$$dp[i][j] = \min(dp[i-1][j], \ dp[i][j-1]) + grid[i-1][j-1]$$
**边界处理**：  
- 通过初始化无效区域（如 `dp[0][2..m]` 和 `dp[2..n][0]`）为 `INT_MAX`，确保计算时自动排除越界位置。


3. **初始化**  
- **虚拟起点**：`dp[0][1] = dp[1][0] = 0`，表示从虚拟起点出发的初始状态。  
- **无效区域**：其他虚拟行和列的初始值为 `INT_MAX`，避免干扰有效计算。


4. **遍历顺序**  
按行优先遍历，从左到右、从上到下依次计算每个位置的最小路径和，确保子问题已解。


5. **结果提取**  
最终结果为 `dp[n][m]`，即右下角位置的最小路径和。


> [!tip]+ 关键点解析
> 1. **虚拟起点设计**：  
>    通过设置 `dp[0][1]` 和 `dp[1][0]` 为 `0`，使得 `grid[0][0]` 的计算无需单独处理。
> 2. **无效区域填充**：  
>    虚拟行和列的 `INT_MAX` 确保越界位置不会影响有效计算。
> 3. **状态转移方向**：  
>    每个位置的值仅依赖左侧和上侧，保证无后效性。

## 代码实现
```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int n = grid.size();       // 网格行数
        int m = grid[0].size();    // 网格列数
        // 初始化 dp 数组，多出1行1列用于简化边界处理
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        // 设置虚拟起点，使原 grid[0][0] 的路径和正确计算
        dp[0][1] = dp[1][0] = 0;

        // 逐行逐列计算最小路径和
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // 取左侧和上侧的最小值，加上当前网格值
                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1];
            }
        }

        // 返回右下角的最小路径和
        return dp[n][m];
    }
};
```



### 复杂度分析
- **时间复杂度**：O(mn)  
  双重循环遍历 `m x n` 的网格，每个状态计算为常数时间。
- **空间复杂度**：O(mn)  
  `dp` 数组占用 `(n+1) x (m+1)` 的空间，与输入规模成线性关系。




