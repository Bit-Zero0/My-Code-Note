---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-10 12:20
Finish-date: 
Modified-date: 2025-03-10 12:40
Publish: false
---


# 413. 等差数列划分
[413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/)

## 题目描述
如果一个数列 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该数列为等差数列。

- 例如，`[1,3,5,7,9]`、`[7,7,7,7]` 和 `[3,-1,-5,-9]` 都是等差数列。

给你一个整数数组 `nums` ，返回数组 `nums` 中所有为等差数组的 **子数组** 个数。

**子数组** 是数组中的一个连续序列。

**示例 1：**

**输入：** nums = [1,2,3,4]
**输出：** 3
**解释：** nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。

**示例 2：**
**输入：** nums = [1]
**输出：** 0

**提示：**
- `1 <= nums.length <= 5000`
- `-1000 <= nums[i] <= 1000`

## 解题思路

### 关键步骤分析

#### 问题性质与暴力解法的局限
**问题核心**：寻找所有长度 ≥3 的连续等差子数组。暴力解法需要三重循环检查每个子数组的等差性，时间复杂度为 O(n³)，在 n=10³ 时不可行。

**动态规划优化切入点**：
- **连续性特征**：子数组必须连续，前序状态可复用
- **重叠子问题**：当检测 `nums[0..5]` 等差时，可直接复用 `nums[0..4]` 的检测结果
- **递推关系**：若 `nums[i]` 与前两个数构成等差，则其子数组数量可由前序结果推导

#### 动态规划状态定义的深层逻辑
**状态定义 `dp[i]` 的数学意义**：
- 表示以 `i` 结尾的等差数列子数组个数
- **关键性质**：这些子数组必须全部以 `i` 为终点，且长度 ≥3

**例证分析**：假设数组 `[1,3,5,7,9]`
- `dp = 1`：对应子数组 `[1,3,5]`
- `dp = 2`：新增 `[3,5,7]` 和 `[1,3,5,7]`（继承前序状态 +1）
- `dp = 3`：新增 `[5,7,9]`、`[3,5,7,9]`、`[1,3,5,7,9]`

**状态转移方程的严格推导**：
1. **初始条件**：当且仅当 `i≥2` 时可能构成等差数列
2. **等差成立时**：
   - 已有 `dp[i-1]` 个以 `i-1` 结尾的子数组，每个子数组末尾添加 `nums[i]` 后仍然等差 → 贡献 `dp[i-1]` 个
   - 新增长度为3的子数组 `[nums[i-2], nums[i-1], nums[i]]` → 贡献 +1 个
   - 因此：`dp[i] = dp[i-1] + 1`
3. **等差不成立时**：
   - 任何以 `i` 结尾的子数组都不满足条件 → `dp[i] = 0`

#### 结果累加机制的精妙之处
**累加原理**：每个 `dp[i]` 包含所有以 `i` 结尾的有效子数组，全局累加即得总数

**数学证明**：
- 设最终结果 `result = Σdp[i] (2≤i<n)`
- 每个长度 k≥3 的等差数列子数组 `nums[a..a+k-1]` 会被精确计算 (k-2) 次：
  - 当 i=a+2 时计入 `[a, a+1, a+2]`
  - 当 i=a+3 时计入 `[a, a+1, a+2, a+3]` 的末尾3元素部分
  - ... 直到 i=a+k-1
- 但根据状态转移设计，实际每个子数组仅在其最大下标处被计算1次，确保无重复计数


#### 边界情况与特殊测试用例
1. **全等数组**：`nums = [2,2,2,2,2]`
   - `dp=1`, `dp=2`, `dp=3`
   - 结果 1+2+3=6
   - 实际子数组数：3长度5个，4长度4个，5长度3个 → 共12个？ ❌ 
   - **注意**：我们的算法计算结果为6，说明定义的是"以i结尾的最长子数组"产生的子数组数。此处需要澄清：
     - 每个 `dp[i]` 实际上表示新增的连续等差段带来的子数组增量
     - 在连续k个等差元素中，总子数组数为 (k-1)(k-2)/2

2. **中断后恢复等差**：`nums = [1,3,5,8,11,14]`
   - 等差中断在i=3（5→8差3≠2）
   - 后续i=4,5重新构成等差（差3）
   - 此时dp=1，说明算法正确处理中断情况


#### 严谨性补充证明
**命题**：算法计算结果等于所有长度≥3的连续等差子数组的数量

**归纳证明**：
1. **基本情况**：当n=3时，若等差则dp=1，结果正确
2. **归纳假设**：假设对长度k的数组，算法正确计算结果
3. **归纳步骤**：
   - 当加入`nums[k]`时，若等差成立：
     - 新增子数组数为 `dp[k-1]+1`
     - 这些子数组均为以k结尾的有效数组
   - 结果累加保持正确性
4. **结论**：算法对所有n≥3情况成立


## 代码实现
```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size();
        if(n <= 2) return 0; // 处理无法构成等差的基本情况
        
        vector<int> dp(n, 0); // dp[i]物理意义：以i结尾的最长连续等差子数组带来的新增子数组数
        int result = 0;
        
        for(int i = 2; i < n; i++) {
            // 检测三元素等差性：这是构成任何长度≥3子数组的必要条件
            bool isArithmetic = (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]);
            
            if(isArithmetic) {
                // 状态转移核心：新增子数组数 = 前序子数组数 + 1
                // 例如前序有m个以i-1结尾的子数组，每个扩展后得到m个新子数组
                // 再加1个新的三元素子数组 [i-2, i-1, i]
                dp[i] = dp[i-1] + 1;
                result += dp[i]; // 全局累加
            } else {
                // 等差性断裂，无法形成任何以i结尾的有效子数组
                dp[i] = 0; // 显式重置，防止脏数据
            }
        }
        return result;
    }
};
```

### 示例演算（复杂案例）
**输入**：`nums = [1,2,3,4,7,10,13]`
**执行过程**：

| i | nums[i-2], nums[i-1], nums[i] | 是否等差 | dp[i] | result累加 | 新增子数组 |
|---|-----------------------------|--------|-------|------------|---------------------------|
|2 | 1,2,3 | 是 | 1 | 1 | [1,2,3] |
|3 | 2,3,4 | 是 | 1+1=2 | 1+2=3 | [2,3,4], [1,2,3,4] |
|4 | 3,4,7 | 否 | 0 | 3+0=3 | 无 |
|5 | 4,7,10 | 是 | 0+1=1 | 3+1=4 | [4,7,10] |
|6 | 7,10,13 | 是 | 1+1=2 | 4+2=6 | [7,10,13], [4,7,10,13] |

**最终结果**：6，验证正确性：
- 实际有效子数组：
  - 长度3：`[1,2,3], [2,3,4], [4,7,10], [7,10,13]`
  - 长度4：`[1,2,3,4], [4,7,10,13]`
  - 长度3：`[4,7,10,13`] 不存在，因为中间断裂
  - 总计 4+2 = 6，与算法结果一致

