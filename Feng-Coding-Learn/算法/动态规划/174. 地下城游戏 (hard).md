---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-03 22:34
Finish-date: 
Modified-date: 2025-03-04 18:13
Publish: false
---


# 174. 地下城游戏
[174. 地下城游戏](https://leetcode.cn/problems/dungeon-game/)

## 题目描述
恶魔们抓住了公主并将她关在了地下城 `dungeon` 的 **右下角** 。地下城是由 `m x n` 个房间组成的二维网格。我们英勇的骑士最初被安置在 **左上角** 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为_负整数_，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 _0_），要么包含增加骑士健康点数的魔法球（若房间里的值为_正整数_，则表示骑士将增加健康点数）。

为了尽快解救公主，骑士决定每次只 **向右** 或 **向下** 移动一步。

返回确保骑士能够拯救到公主所需的最低初始健康点数。

**注意：**任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

**示例 1：**
![](https://assets.leetcode.com/uploads/2021/03/13/dungeon-grid-1.jpg)
**输入：** dungeon = `[[-2,-3,3],[-5,-10,1],[10,30,-5]]`
**输出：** 7
**解释：** 如果骑士遵循最佳路径：右 -> 右 -> 下 -> 下 ，则骑士的初始健康点数至少为 7 。

**示例 2：**
**输入：** dungeon = [[0]]
**输出：** 1

**提示：**
- `m == dungeon.length`
- `n == dungeon[i].length`
- `1 <= m, n <= 200`
- `-1000 <= dungeon[i][j] <= 1000`

## 解题思路

本问题要求计算骑士从左上角出发到右下角救公主所需的最小初始血量。骑士每一步只能向右或向下移动，每个房间的数值会影响骑士的血量，需确保任何时刻血量不低于1。采用动态规划的逆向解法，从终点出发逆推每个位置的最小初始血量。


1. 动态规划状态定义
- **`dp[i][j]`**：表示从位置 `(i,j)` 到终点所需的最小初始血量。该值需保证在进入当前房间后，剩余路径中血量始终 ≥1。


2. 状态转移方程
对于每个房间 `(i,j)`，其右边和下边的最小初始血量分别为 `dp[i][j+1]` 和 `dp[i+1][j]`，选择较小的一个作为后续路径的基准。当前房间的值会影响所需的初始血量：
- **转移公式**：  
  `dp[i][j] = max(min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j], 1)`  
  这里 `max` 确保初始血量至少为1，防止中途血量耗尽。

3. 初始化与边界处理
- **边界初始化**：  
  将虚拟的右侧和下侧边界（`dp[n][m-1]` 和 `dp[n-1][m]`）初始化为1，表示到达终点后的最低血量需求。
- **其余位置**：  
  初始化为极大值（`INT_MAX`），便于后续取最小值。


4. 遍历顺序
- **逆向遍历**：  
  从右下角开始，逆序填充 `dp` 数组。确保计算当前房间时，右边和下边的房间已处理完毕。


### 关键点解析
- **逆向思维**：从终点逆推起点，确保每个位置的血量需求覆盖后续路径。
- **边界处理**：虚拟边界的初始化使得右下角的计算简洁且正确。
- **状态转移**：通过取较小后续路径值和当前房间值的调整，确保每一步的血量合理。


## 代码实现
```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int n = dungeon.size(), m = dungeon[0].size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, INT_MAX));
        dp[n-1][m] = dp[n][m-1] = 1; // 边界初始化为1

        for (int i = n-1; i >= 0; --i) {
            for (int j = m-1; j >= 0; --j) {
                int minPath = min(dp[i+1][j], dp[i][j+1]); // 选择后续路径较小的方向
                dp[i][j] = max(minPath - dungeon[i][j], 1); // 确保初始血量足够
            }
        }
        return dp[0][0];
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n×m)，遍历整个二维数组一次。
- **空间复杂度**：O(n×m)，维护一个二维动态规划数组。
