---
Type: Note
tags:
  - 算法
  - medium
  - 动态规划
  - 两个数组的DP
Status: writing
Start-date: 2025-03-18 21:43
Finish-date: 
Modified-date: 2025-03-18 21:49
Publish: false
---


# 1143. 最长公共子序列


## 题目描述
给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**
**输入：** text1 = "abcde", text2 = "ace" 
**输出：** 3  
**解释：** 最长公共子序列是 "ace" ，它的长度为 3 。

**示例 2：**
**输入：** text1 = "abc", text2 = "abc"
**输出：** 3
**解释：** 最长公共子序列是 "abc" ，它的长度为 3 。

**示例 3：**
**输入：** text1 = "abc", text2 = "def"
**输出：** 0
**解释：** 两个字符串没有公共子序列，返回 0 。

**提示：**
- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

## 解题思路

本题要求找出两个字符串的最长公共子序列（LCS）的长度。子序列的定义是从原字符串中删除若干字符（或不删除）后保持相对顺序的序列。例如，`text1 = "abcde"` 和 `text2 = "ace"` 的 LCS 是 `"ace"`，长度为3。通过动态规划可以高效解决此问题。



1. **动态规划定义**
	 定义二维数组 `dp[i][j]`，表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列长度。目标是求解 `dp[m][n]`，其中 `m` 和 `n` 分别为两个字符串的长度。

2. **状态转移方程**
	- **情况1：当前字符相等**（`text1[i-1] == text2[j-1]`）  ,此时，当前字符可以加入 LCS 中，因此：  `dp[i][j] = dp[i-1][j-1] + 1`  , 即在两个字符串去掉当前字符后的 LCS 长度基础上加1。
	- **情况2：当前字符不等**（`text1[i-1] != text2[j-1]`）  此时，LCS 的长度取决于两种情况中的较大值：
		- 忽略 `text1` 的当前字符，取 `dp[i-1][j]`。
		- 忽略 `text2` 的当前字符，取 `dp[i][j-1]`。  
  
  因此，状态转移方程为：  `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`


3. **初始化**：当任一字符串为空时，LCS 长度为0。因此，`dp[0][j] = 0` 和 `dp[i][0] = 0`。

4.  **填表顺序**：外层循环遍历 `text1` 的每个字符（`i` 从1到m），内层循环遍历 `text2` 的每个字符（`j` 从1到n）。这种顺序确保在计算 `dp[i][j]` 时，子问题 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 已被计算。


> [!tip]+ 关键点
> 1. **动态规划定义**：`dp[i][j]` 表示子问题的解，覆盖所有前缀组合。
> 2. **状态转移逻辑**：
>    - 字符相等时，直接继承前一步结果并扩展长度。
>    - 字符不等时，通过比较两种可能的子问题取最优解。
> 3. **边界处理**：空字符串的 LCS 长度初始化为0，作为递推的起点。


## 代码实现
```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        // dp[i][j] 表示text1前i个字符和text2前j个字符的LCS长度
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

        // 从前往后遍历，填充dp表
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    // 字符相等：LCS长度等于前一步结果+1
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 字符不等：取两种情况的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n]; // 返回最终结果
    }
};
```



### 复杂度分析
- **时间复杂度**：双重循环遍历所有字符，时间复杂度为 O(m×n)。
- **空间复杂度**：使用二维数组 `dp`，空间复杂度为 O(m×n)。  
  （可通过滚动数组优化到 O(n)，但代码保持直观性未做优化。）






