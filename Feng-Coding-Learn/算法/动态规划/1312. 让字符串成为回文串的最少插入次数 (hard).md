---
Type: Note
tags:
  - 算法
  - hard
  - 动态规划
Status: writing
Start-date: 2025-03-18 21:18
Finish-date: 
Modified-date: 2025-03-18 21:43
Publish: false
---


# 1312. 让字符串成为回文串的最少插入次数
[1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

## 题目描述
给你一个字符串 `s` ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 `s` 成为回文串的 **最少操作次数** 。

「回文串」是正读和反读都相同的字符串。

**示例 1：**
**输入：** s = "zzazz"
**输出：** 0
**解释：** 字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。

**示例 2：**
**输入：** s = "mbadm"
**输出：** 2
**解释：** 字符串可变为 "mbdadbm" 或者 "mdbabdm" 。

**示例 3：**
**输入：** s = "leetcode"
**输出：** 5
**解释：** 插入 5 个字符后字符串变为 "leetcodocteel" 。

**提示：**
- `1 <= s.length <= 500`
- `s` 中所有字符都是小写字母。

## 解题思路


**核心思路**  
将问题转化为寻找字符串中最长回文子序列（LPS），最少插入次数等于字符串长度减去LPS的长度。动态规划方法直接计算每个子串变为回文的最小插入次数。

**动态规划设计**  
1. **状态定义**  
   - `dp[i][j]`：表示将子串 `s[i...j]` 变为回文所需的最小插入次数。

2. **状态转移**  
	  - **情况1：字符对称**（`s[i] == s[j]`） 此时，首尾字符已经对称，无需额外插入。因此，`dp[i][j]` 的值等于去掉首尾后的中间子串的最小插入次数，即： `dp[i][j] = dp[i+1][j-1]`
    
	 - **情况2：字符不对称**（`s[i] != s[j]`） 此时有两种选择：
	    - **在右侧插入一个字符**与 `s[i]` 对称，对应子问题 `dp[i][j-1]`，需要插入次数加1。
	    - **在左侧插入一个字符**与 `s[j]` 对称，对应子问题 `dp[i+1][j]`，需要插入次数加1。 取两者中的较小值： `dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1`

3. **遍历顺序**  
   - 反向遍历 `i`（从末尾到开头），正向遍历 `j`（从 `i+1` 到末尾），确保子问题已计算。


> [!tip]+ 关键点
> 1. **初始化**  
>    - 默认所有 `dp[i][j]` 初始化为0，当 `i >= j` 时，子串本身是回文，无需插入。
> 
> 2. **状态转移条件**  
>    - **字符相等**：当前子串两端已对称，直接继承中间子串的结果。  
>    - **字符不等**：需在左或右插入字符，取较小代价并加1次插入。
> 
> 3. **遍历顺序优化**  
>    - 反向遍历 `i` 确保在处理 `dp[i][j]` 时，`dp[i+1][j-1]`、`dp[i+1][j]` 和 `dp[i][j-1]` 已计算。
> 


## 代码实现

```cpp
class Solution {
public:
    int minInsertions(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n, 0)); // dp[i][j]表示子串s[i..j]的最小插入次数

        // 反向遍历i，确保处理dp[i][j]时子问题已解决
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) { // j从i+1开始，处理长度≥2的子串
                if (s[i] == s[j]) {
                    // 两端字符相同，无需额外插入，直接继承中间部分的结果
                    dp[i][j] = dp[i + 1][j - 1];
                } else {
                    // 两端字符不同，取左或右子串的最小值并加1（插入一个字符）
                    dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1;
                }
            }
        }
        return dp[0][n - 1]; // 返回整个字符串的最小插入次数
    }
};
```


### 示例分析

以 `s = "mbadm"` 为例：  
1. **计算 `dp[1][3]`（子串 "bad"）**：  
   - `s[1] = 'b'` 与 `s[3] = 'd'` 不同，取 `min(dp[2][3], dp[1][2]) + 1`。  
   - `dp[2][3] = 1`（处理 "ad" 需插入1次），`dp[1][2] = 1`（处理 "ba" 需插入1次），故 `dp[1][3] = 2`。  
2. **计算 `dp[0][4]`（整个字符串）**：  
   - `s[0] = 'm'` 与 `s[4] = 'm'` 相同，继承 `dp[1][3] = 2`。  
最终结果为2，需插入2次变为回文。



### 复杂度分析
- **时间复杂度**：O (n²)，其中 `n` 是字符串长度。每个子串需计算一次。
- **空间复杂度**：O (n²)，存储动态规划数组。