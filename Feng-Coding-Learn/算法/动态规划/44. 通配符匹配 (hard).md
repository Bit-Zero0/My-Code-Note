---
Type: Note
tags:
  - 算法
  - hard
  - 动态规划
Status: writing
Start-date: 2025-03-20 22:03
Finish-date: 
Modified-date: 2025-03-20 22:50
Publish: false
---


# 44. 通配符匹配
[44. 通配符匹配](https://leetcode.cn/problems/wildcard-matching/)

## 题目描述
给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

 

**示例 1：**
**输入：** s = "aa", p = "a"
**输出：** false
**解释：**"a" 无法匹配 "aa" 整个字符串。

**示例 2：**
**输入：** s = "aa", p = "*"
**输出：** true
**解释：**'*' 可以匹配任意字符串。

**示例 3：**
**输入：** s = "cb", p = "?a"
**输出：** false
**解释：**'?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。

**提示：**
- `0 <= s.length, p.length <= 2000`
- `s` 仅由小写英文字母组成
- `p` 仅由小写英文字母、`'?'` 或 `'*'` 组成

## 解题思路


### 44. 通配符匹配

#### 题目描述
给定一个字符串 `s` 和一个模式 `p`，判断 `s` 是否能被 `p` 完全匹配。模式 `p` 支持以下匹配规则：
- `?` 可以匹配任意单个字符。
- `*` 可以匹配任意字符序列（包括空字符序列）。


#### 解题思路
**动态规划**  
**核心思路**：  
1. **状态定义**：`dp[i][j]` 表示字符串 `s` 的前 `i` 个字符和模式 `p` 的前 `j` 个字符是否匹配。
2. **初始化**：
   - `dp[0][0] = true`（空字符串匹配空模式）。
   - 处理前导 `*`：若 `p` 的前 `j` 个字符全为 `*`，则 `dp[0][j] = true`。
3. **状态转移**：
   - **当 `p[j] == '*'`**：
     - `dp[i][j] = dp[i][j-1] || dp[i-1][j]`（`*` 匹配空或至少一个字符）。
   - **当 `p[j] == '?'` 或 `s[i] == p[j]`**：
     - `dp[i][j] = dp[i-1][j-1]`（当前字符匹配，继承前一个状态）。
   - **其他情况**：`dp[i][j] = false`。

**复杂度分析**：  
- **时间复杂度**：O(m×n)，其中 `m` 和 `n` 分别为 `s` 和 `p` 的长度。
- **空间复杂度**：O(m×n)，存储动态规划数组。可优化至 O(n)，但代码复杂度增加。


#### 代码实现
```cpp
#include <vector>
#include <string>
using namespace std;

class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        // 在字符串前添加虚拟字符，方便处理索引从1开始的情况
        s = ' ' + s;
        p = ' ' + p;

        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));
        dp[0][0] = true; // 空字符串匹配空模式

        // 处理模式p的前导'*'
        for (int j = 1; j <= n; ++j) {
            if (p[j] == '*') {
                dp[0][j] = true;
            } else {
                break; // 遇到非'*'字符，后续无法匹配空字符串
            }
        }

        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p[j] == '*') {
                    // '*'可以匹配空（取dp[i][j-1]）或至少一个字符（取dp[i-1][j]）
                    dp[i][j] = dp[i][j-1] || dp[i-1][j];
                } else {
                    // 当前字符匹配，继承前一个状态
                    if (p[j] == '?' || s[i] == p[j]) {
                        dp[i][j] = dp[i-1][j-1];
                    }
                    // 否则，无法匹配
                }
            }
        }

        return dp[m][n];
    }
};
```


#### 代码注释说明
1. **预处理字符串**：  
   `s = ' ' + s; p = ' ' + p;`  
   在字符串前添加虚拟字符，使索引从 1 开始，简化边界条件处理。

2. **初始化动态规划数组**：  
   - **空字符串匹配**：`dp[0][0] = true`，表示两个空字符串匹配。
  - **模式 `p` 前缀为 `*` 的情况**：若 `p` 的前 `j` 个字符全为 `*`，则 `dp[0][j] = true`，因为 `*` 可以匹配空字符串。

3. **处理前导 `*`**：  
   `for (int j = 1; j <= n; ++j) { ... }`  
   若 `p` 的前 `j` 个字符全为 `*`，则 `dp[0][j] = true`，表示空字符串可被匹配。

4. **状态转移**：  
   - **`p[j] == '*'`**：  
	    匹配零个字符（忽略 `*`）
		- **操作**：不使用 `*`，即 `*` 不匹配任何字符。
		- **状态依赖**：此时能否匹配取决于 `p` 的前 `j-1` 个字符是否已匹配 `s` 的前 `i` 个字符。
		- **状态转移**：`dp[i][j] = dp[i][j-1]`。
		
		匹配一个或多个字符（使用 `*`）
		- **操作**：使用 `*` 匹配 `s` 的第 `i` 个字符。
		- **状态依赖**：此时 `*` 必须已经匹配了 `s` 的前 `i-1` 个字符，并且当前字符 `s[i]` 可以被 `*` 覆盖。
		- **状态转移**：`dp[i][j] = dp[i-1][j]`。
   - **`p[j] == '?'` 或 `s[i] == p[j]`**：  
	 `dp[i][j] = dp[i-1][j-1];`  
	 当前字符匹配，继承前一个状态。



5. **结果返回**：  
   `return dp[m][n];`  
   `dp[m][n]` 表示整个字符串 `s` 和模式 `p` 是否匹配。


#### 关键点总结
1. **动态规划状态定义**：  
   `dp[i][j]` 表示两个子串的匹配状态，通过状态转移方程逐步推导。

2. **`*` 的处理**：  
   `*` 可匹配空或多个字符，需同时考虑两种情况。

3. **前导 `*` 的优化**：  
   初始化时直接处理前导 `*`，避免重复计算。

4. **字符匹配的处理**：  
   `?` 匹配任意字符，`*` 匹配任意序列，普通字符需严格匹配。


#### 示例解析
以示例 2 为例：  
输入：`s = "aa"`, `p = "*"`  
- `dp[0][1] = true`（`*` 匹配空）。
- `i=1`, `j=1`：`*` 匹配 `a`，`dp[1][1] = dp[1][0] || dp[0][1] = false || true = true`。
- `i=2`, `j=1`：`*` 匹配第二个 `a`，`dp[2][1] = true`。
- 最终返回 `true`。


#### 常见疑问解答
- **为什么使用虚拟字符？**  
  简化索引处理，避免边界条件判断。

- **如何处理连续的 `*`？**  
  连续的 `*` 视为一个 `*`，因为多个 `*` 可匹配任意序列，包括空。







在通配符匹配问题中，当模式 `p` 的第 `j` 个字符是 `*` 时，状态转移方程 `dp[i][j] = dp[i][j-1] || dp[i-1][j]` 的推导基于 `*` 的两种匹配方式。以下是详细解释：

---

### **1. `*` 的两种匹配方式**
通配符 `*` 可以匹配 **零个或多个字符**。这两种情况需要分别处理：



---

### **2. 合并两种情况的逻辑**
由于 `*` 的两种匹配方式是独立的，只要其中一种成立即可，因此需要取逻辑或：

$$dp[i][j] = \underbrace{dp[i][j-1]}_{\text{匹配零个}} \ \text{||} \ \underbrace{dp[i-1][j]}_{\text{匹配多个}}$$

---

### **3. 示例验证**
以 `s = "abc"`，`p = "a*"` 为例：

- **初始状态**：`dp[0][0] = true`（空字符串匹配空模式）。
- **填充 `dp[0][j]`**：`p` 的第一个字符是 `a`（非 `*`），因此 `dp[0][1] = false`。
- **处理 `p[2] = '*'`**：
  - **`i=1`（`s[1] = 'a'`）**：  
    - `dp[1][2] = dp[1][1]（false）|| dp[0][2]（true） → true`（`*` 匹配 `a`）。
  - **`i=2`（`s[2] = 'b'`）**：  
    - `dp[2][2] = dp[2][1]（false）|| dp[1][2]（true） → true`（`*` 继续匹配 `b`）。
  - **`i=3`（`s[3] = 'c'`）**：  
    - `dp[3][2] = dp[3][1]（false）|| dp[2][2]（true） → true`（`*` 继续匹配 `c`）。

最终 `dp[3][2] = true`，表示 `"a*"` 可以匹配 `"abc"`。

---

### **4. 正确性分析**
- **覆盖所有可能性**：  
  - `dp[i][j-1]` 确保 `*` 可以跳过（匹配零个字符）。  
  - `dp[i-1][j]` 确保 `*` 可以扩展（匹配多个字符）。
- **动态规划的无后效性**：  
  每个状态 `dp[i][j]` 仅依赖于已计算的前序状态，确保递推正确。

---

### **总结**
动态转移方程 `dp[i][j] = dp[i][j-1] || dp[i-1][j]` 的推导基于 `*` 的两种匹配方式：
1. **不匹配当前字符**：直接继承左侧状态 `dp[i][j-1]`（跳过 `*`）。  
2. **匹配当前字符**：继承上方状态 `dp[i-1][j]`（`*` 继续扩展）。  

通过逻辑或合并这两种可能性，确保所有匹配情况被覆盖，从而正确求解通配符匹配问题。