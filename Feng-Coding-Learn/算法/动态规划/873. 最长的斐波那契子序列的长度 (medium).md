---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-14 19:14
Finish-date: 
Modified-date: 2025-03-15 13:41
Publish: false
---


# 873. 最长的斐波那契子序列的长度
[873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)

## 题目描述
如果序列 `X_1, X_2, ..., X_n` 满足下列条件，就说它是 _斐波那契式_ 的：

- `n >= 3`
- 对于所有 `i + 2 <= n`，都有 `X_i + X_{i+1} = X_{i+2}`

给定一个**严格递增**的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。

_（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， `[3, 5, 8]` 是 `[3, 4, 5, 6, 7, 8]` 的一个子序列）_

**示例 1：**
**输入:** arr = `[1,2,3,4,5,6,7,8]`
**输出:** 5
**解释:** 最长的斐波那契式子序列为 `[1,2,3,5,8]` 。

**示例 2：**
**输入:** arr = `[1,3,7,11,12,14,18]`
**输出:** 3
**解释**: 最长的斐波那契式子序列有 `[1,11,12]`、`[3,11,14]` 以及 `[7,11,18]` 。

**提示：**
- `3 <= arr.length <= 1000`
- `1 <= arr[i] < arr[i + 1] <= 10^9`

## 解题思路


**问题分析**  
给定严格递增的整数数组 `arr`，寻找最长斐波那契子序列的长度。斐波那契子序列需满足：对于所有 `k ≥ 2`，`X_k = X_{k-1} + X_{k-2}`。例如，输入 `[1,3,4,7,11,18]` 的最长斐波那契子序列为 `[1,3,4,7,11]`，长度为5。

**核心挑战**  
1. **子序列不要求连续**：元素顺序需保持原数组顺序，但可跳过中间元素。  
2. **高效状态转移**：如何快速验证前驱元素是否存在并计算最长长度。



### 方法：动态规划（二维状态 + 哈希表）

**算法设计**  
1. **状态定义**  
   - `dp[j][i]`：以 `arr[j]` 和 `arr[i]` 作为最后两个元素的最长斐波那契子序列长度。  
   - **初始值**：任意两个元素可形成长度为2的子序列，故 `dp[j][i] = 2`。

2. **状态转移**  
   - 对于每对元素 `(j, i)`（`j < i`），计算前驱元素 `x = arr[i] - arr[j]`。  
   - 若 `x` 存在且其位置 `k < j`，则状态转移方程为：  $$dp[j][i] = dp[k][j] + 1$$
   - **条件限制**：`x < arr[j]`，确保 `x` 在 `arr[j]` 左侧（因数组严格递增）。

3. **初始化**
  - **初始状态**：所有 `dp[i][j]` 初始化为 `2`，因为任意两个元素可视为长度为 2 的序列。

4. **哈希表优化**  
   - 使用哈希表 `hash` 存储元素到索引的映射，实现 `O(1)` 时间查找前驱元素位置。

5. **结果提取**  
   - 遍历所有 `dp[j][i]`，取全局最大值。若结果小于3，返回0（斐波那契序列至少需3个元素）。




## 代码实现

```cpp
class Solution {
public:
    int lenLongestFibSubseq(vector<int>& arr) {
        int n = arr.size();
        if (n < 3) return 0;

        // dp[j][i]表示以arr[j]和arr[i]为最后两个元素的最长斐波那契子序列长度
        vector<vector<int>> dp(n, vector<int>(n, 2)); 
        unordered_map<int, int> hash;  // 元素值到索引的映射

        for (int i = 0; i < n; i++) {
            hash[arr[i]] = i;  // 记录元素位置，重复元素会被覆盖（但输入数组严格递增，无重复）
        }

        int result = 2;  // 初始值为2（至少两个元素）

        for (int i = 2; i < n; i++) {          // 遍历每个元素作为第三元素的位置i
            for (int j = 1; j < i; j++) {      // j是i的前一个元素
                int x = arr[i] - arr[j];       // 计算前驱元素的值
                // 必须满足x存在且其位置k < j（因数组严格递增，x < arr[j]时k才可能在j左侧）
                if (x < arr[j] && hash.count(x)) {
                    int k = hash[x];           // 获取前驱元素的索引
                    dp[j][i] = dp[k][j] + 1;   // 状态转移：当前长度 = 前驱长度 +1
                }
                result = max(result, dp[j][i]); // 更新全局最大值
            }
        }

        return result < 3 ? 0 : result;  // 结果小于3时返回0
    }
};
```


### 关键点解释
1. **哈希表的作用**  
   - 快速定位前驱元素 `x` 的索引 `k`，避免遍历数组查找，时间复杂度由 **O(n³)** 优化至 **O(n²)**。

2. **条件 `x < arr[j]` 的必要性**  
   - 因数组严格递增，若 `x ≥ arr[j]`，则 `x` 必然位于 `arr[j]` 右侧，无法构成合法的斐波那契子序列。

3. **状态转移的逻辑**  
   - 当找到合法前驱 `k` 时，`dp[j][i]` 继承 `dp[k][j]` 的长度并加1，形成链式增长。


### 示例分析

以输入 `arr = [1,3,4,7,11,18]` 为例：  
1. **初始化哈希表**：`hash = {1:0, 3:1, 4:2, 7:3, 11:4, 18:5}`。  
2. **处理 `i=2`（元素4）**：  
   - `j=1`（元素3），计算 `x =4-3=1`，存在且 `k=0 <1` → `dp[1][2] = dp[0][1] +1 =3`。  
3. **处理 `i=3`（元素7）**：  
   - `j=2`（元素4），计算 `x=7-4=3`，存在且 `k=1 <2` → `dp[2][3] = dp[1][2] +1=4`。  
4. **处理 `i=4`（元素11）**：  
   - `j=3`（元素7），计算 `x=11-7=4`，存在且 `k=2 <3` → `dp[3][4] = dp[2][3] +1=5`。  
5. **最终结果**：最长子序列为 `[1,3,4,7,11]`，长度5。

\
### **复杂度分析**

- **时间复杂度**：O(n²)，双重循环遍历所有可能的 `i` 和 `j`。
- **空间复杂度**：O(n²)，存储二维 `dp` 数组。