---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-15 15:35
Finish-date: 
Modified-date: 2025-03-15 16:38
Publish: false
---


# 1027. 最长等差数列
[1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)

## 题目描述
给你一个整数数组 `nums`，返回 `nums` 中最长等差子序列的**长度**。

回想一下，`nums` 的子序列是一个列表 `nums[i1], nums[i2], ..., nums[ik]` ，且 `0 <= i1 < i2 < ... < ik <= nums.length - 1`。并且如果 `seq[i+1] - seq[i]`( `0 <= i < seq.length - 1`) 的值都相同，那么序列 `seq` 是等差的。

**示例 1：**
**输入：** nums = [3,6,9,12]
**输出：** 4
**解释：** 
整个数组是公差为 3 的等差数列。

**示例 2：**
**输入：** nums = [9,4,7,2,10]
**输出：** 3
**解释：**
最长的等差子序列是 [4,7,10]。

**示例 3：**
**输入：** nums = [20,1,15,3,10,5,8]
**输出：** 4
**解释：**
最长的等差子序列是 [20,15,10,5]。

**提示：**
- `2 <= nums.length <= 1000`
- `0 <= nums[i] <= 500`

## 解题思路


**核心思路**：  
1. **动态规划状态定义**：`dp[i][j]` 表示以 `nums[i]` 和 `nums[j]` 为最后两个元素的等差数列的长度。
2. **状态转移**：对于每个 `i` 和 `j`（`i < j`），计算前一个元素 `x = 2 * nums[i] - nums[j]`。若 `x` 存在且其索引 `k < i`，则 `dp[i][j] = dp[k][i] + 1`。
3. **哈希表优化**：使用哈希表快速查询 `x` 是否存在并获取其索引，避免线性搜索。


> [!question]+ 为什么不能使用`dp[i]` ?
> 假设定义 `dp[i]` 为以 `nums[i]` 结尾的最长等差数列长度，存在以下问题：
> 
> - **无法追踪公差**：不同前驱元素可能形成不同公差，`dp[i]` 无法区分这些公差。
> - **状态转移不明确**：无法确定当前元素应与哪个前驱元素的公差匹配，导致无法正确更新长度。
> 
> **示例**：`nums = [3, 6, 9, 4, 7]`
> - 以 `nums[3]=4` 结尾的序列可能有多种公差（如 `1（3→4）`、`-2（6→4）`），但 `dp[3]` 无法记录这些信息。


> [!question]+ 为什么需要二维状态 `dp[i][j]`？
> **二维状态的定义**
> - **`dp[i][j]`**：表示以 `nums[i]` 和 `nums[j]` 作为最后两个元素的等差数列的最大长度。
> - **物理意义**：明确记录了公差 `d = nums[j] - nums[i]`，从而可以唯一确定当前序列的等差特性。
> 
> **2. 状态转移方程的推导**
> 要形成以 `nums[i][j]` 结尾的等差数列，必须存在一个前驱元素 `nums[k]`，使得：
> 
> ```
>  nums[j] - nums[i] = nums[i] - nums[k]
> => nums[k] = 2 * nums[i] - nums[j]
> ```
> 
> - **状态转移**：若存在 `k`，则 `dp[i][j] = dp[k][i] + 1`。
> - **初始化**：所有 `dp[i][j] = 2`，表示仅包含 `nums[i]` 和 `nums[j]` 的初始长度。



**步骤分析**：
1. **初始化**：若数组长度小于 2，直接返回 0。
2. **构建哈希表**：将元素值映射到其索引，便于快速查找。
3. **动态规划遍历**：
   - 外层循环遍历 `i`（从 1 开始），内层循环遍历 `j`（从 `i+1` 开始）。
   - 计算 `x = 2 * nums[i] - nums[j]`，若 `x` 存在且 `k < i`，更新 `dp[i][j]`。
4. **结果统计**：遍历所有 `dp[i][j]`，记录最大值。


> [!tip]+ 关键点
> 1. **动态规划状态定义**：  
>    `dp[i][j]` 表示以 `nums[i]` 和 `nums[j]` 结尾的等差数列长度，通过前一个状态 `dp[k][i]` 推导。
> 
> 2. **哈希表的作用**：  
>    快速查找元素 `x` 的索引，确保时间复杂度为 O(n²)，而非 O(n³)。
> 3. **前驱元素的条件**
   > `x = 2 * nums[i] - nums[j]` 保证了 `nums[k]`, `nums[i]`, `nums[j]` 形成等差数列，且顺序为 `k < i < j`。
> 4. **哈希表更新**：  
>   在遍历 `i` 时，每次处理完所有 `j > i` 的情况后，才将 `nums[i]` 加入哈希表，确保后续查询仅使用 `i` 之前的元素。


> [!question]+ 疑问解答
> - **为什么 `x` 必须小于 `nums[i]`？**  
>   因为数组未排序，`x` 的索引 `k` 必须小于 `i`，以确保子序列的顺序正确。
> 
> - **动态规划数组的空间复杂度能否优化？**  
>   可以，但会增加时间复杂度。当前方法在时间和空间之间取得平衡，适用于题目约束（`n <= 1000`）。
> 
> - **如何处理重复元素？**  
>   题目允许重复元素，但子序列必须保持原顺序，代码中通过索引判断顺序，无需额外处理。


## 代码实现
```cpp
#include <vector>
#include <unordered_map>
using namespace std;

class Solution {
public:
    int longestArithSeqLength(vector<int>& nums) {
        int n = nums.size();
        if (n <= 1) return 0; // 处理特殊情况

        vector<vector<int>> dp(n, vector<int>(n, 2)); // dp[i][j] 初始化为2
        unordered_map<int, int> hash; // 哈希表：元素值 -> 索引
        hash[nums[0]] = 0; // 初始化第一个元素

        int result = 2; // 初始最长长度为2

        for (int i = 1; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int x = 2 * nums[i] - nums[j]; // 计算前一个元素的值
                if (hash.count(x) && hash[x] < i) { // 检查x是否存在且索引k < i
                    dp[i][j] = dp[hash[x]][i] + 1; // 更新dp[i][j]
                    result = max(result, dp[i][j]); // 更新全局最大值
                }
            }
            hash[nums[i]] = i; // 将当前元素存入哈希表
        }

        return result;
    }
};
```



### 复杂度分析
- **时间复杂度**：O(n²)，其中 `n` 是数组长度。每个元素对 `(i, j)` 最多处理一次。
- **空间复杂度**：O(n²)，用于存储动态规划数组 `dp`。


