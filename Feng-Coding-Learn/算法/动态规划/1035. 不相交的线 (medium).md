---
Type: Note
tags:
  - 算法
  - medium
  - 动态规划
Status: writing
Start-date: 2025-03-20 19:29
Finish-date: 
Modified-date: 2025-03-20 20:31
Publish: false
---


# 1035. 不相交的线
[1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

## 题目描述
在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足：

-  `nums1[i] == nums2[j]`
- 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

**示例 1：**
![](https://assets.leetcode.com/uploads/2019/04/26/142.png)
**输入：** nums1 = [1,4,2], nums2 = [1,2,4]
**输出：** 2
**解释：** 可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。

**示例 2：**
**输入：** nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
**输出：** 3

**示例 3：**
**输入：** nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
**输出：** 2

**提示：**
- `1 <= nums1.length, nums2.length <= 500`
- `1 <= nums1[i], nums2[j] <= 2000`

## 解题思路 (动态规划)


**问题分析**  
给定两个整数数组 `nums1` 和 `nums2`，要求在两个数组之间绘制不相交的直线，连接相等的元素。直线不能相交意味着连接的元素在两个数组中的顺序必须一致。例如，`nums1 = [1,4,2]` 和 `nums2 = [1,2,4]` 的最大连线数为2（连接 `1-1` 和 `4-4` 或 `1-1` 和 `2-2`）。

**核心挑战**  
1. **保持顺序一致性**：连线必须按顺序连接，避免交叉。  
2. **最大化连线数量**：等价于寻找两个数组的最长公共子序列（LCS）。


**算法设计**  
1. **状态定义**  
   - `dp[i][j]`：表示 `nums1` 前 `i` 个元素和 `nums2` 前 `j` 个元素的最长公共子序列长度（即最大不相交连线数）。

2. **状态转移方程**  
   - **字符匹配**：若 `nums1[i-1] == nums2[j-1]`，则当前元素可加入公共子序列：$$dp[i][j] = dp[i-1][j-1] + 1$$
   - **字符不匹配**：取不包含当前元素的最大值：  $$dp[i][j] = \max(dp[i-1][j], \, dp[i][j-1])$$

3. **初始状态**  
   - `dp[0][j] = 0` 和 `dp[i][0] = 0`（空数组的公共子序列长度为0）。

> [!tip]+ 关键点
> 1. **状态定义的本质**  
>    - `dp[i][j]` 表示的是两个数组前 `i` 和 `j` 个元素的最长公共子序列长度。由于连线不可交叉，公共子序列的顺序性保证了连线的合法性。
> 
> 2. **状态转移逻辑**  
>    - **匹配**：当前元素相等时，公共子序列长度继承前序状态并加1。  
>    - **不匹配**：当前元素不等时，需选择保留 `nums1` 的前 `i-1` 元素或 `nums2` 的前 `j-1` 元素的最优解。
> 
> 3. **遍历顺序**  
>    - 正向填充二维数组，确保处理 `dp[i][j]` 时，其依赖的子问题 `dp[i-1][j-1]`、`dp[i-1][j]` 和 `dp[i][j-1]` 已计算。


### 代码实现

```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size(), n = nums2.size();
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0)); // dp[i][j]表示前i和j元素的最大连线数

        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    // 当前元素相等，连线数+1，继承前i-1和j-1的状态
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 当前元素不等，取左侧或上方的最大值
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
```


#### 示例分析

以 `nums1 = [1,4,2]` 和 `nums2 = [1,2,4]` 为例：  
1. **初始化**：`dp[0][j]` 和 `dp[i][0]` 均为0。  
2. **处理 `i=1`（元素1）**：  
   - `j=1`（元素1）匹配，`dp[1][1] = 1`。  
   - `j=2`（元素2）不匹配，`dp[1][2] = max(0, 1) = 1`。  
   - `j=3`（元素4）不匹配，`dp[1][3] = max(0, 1) = 1`。  
3. **处理 `i=2`（元素4）**：  
   - `j=3`（元素4）匹配，`dp[2][3] = dp[1][2] + 1 = 2`。  
4. **处理 `i=3`（元素2）**：  
   - `j=2`（元素2）匹配，`dp[3][2] = dp[2][1] + 1 = 2`。  
最终 `dp[3][3] = 2`，对应最长公共子序列 `[1,4]` 或 `[1,2]`。


#### 复杂度分析
- **时间复杂度**：O (m×n)，其中 `m` 和 `n` 分别为 `nums1` 和 `nums2` 的长度。每个状态需 O (1) 时间计算。
- **空间复杂度**：O (m×n)，存储动态规划数组。可优化至 O (n)，但代码复杂度会增加。
