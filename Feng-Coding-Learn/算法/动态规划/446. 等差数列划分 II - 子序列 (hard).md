---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-15 16:23
Finish-date: 
Modified-date: 2025-03-16 13:15
Publish: false
---


# 446. 等差数列划分 II - 子序列
[446. 等差数列划分 II - 子序列](https://leetcode.cn/problems/arithmetic-slices-ii-subsequence/)

## 题目描述
给你一个整数数组 `nums` ，返回 `nums` 中所有 **等差子序列** 的数目。

如果一个序列中 **至少有三个元素** ，并且任意两个相邻元素之差相同，则称该序列为等差序列。

- 例如，`[1, 3, 5, 7, 9]`、`[7, 7, 7, 7]` 和 `[3, -1, -5, -9]` 都是等差序列。
- 再例如，`[1, 1, 2, 5, 7]` 不是等差序列。

数组中的子序列是从数组中删除一些元素（也可能不删除）得到的一个序列。

- 例如，`[2,5,10]` 是 `[1,2,1,_**2**_,4,1,**_5_**,_**10**_]` 的一个子序列。

题目数据保证答案是一个 **32-bit** 整数。

**示例 1：**
**输入：** nums = [2,4,6,8,10]
**输出：** 7
**解释：** 所有的等差子序列为：
```
[2,4,6]
[4,6,8]
[6,8,10]
[2,4,6,8]
[4,6,8,10]
[2,4,6,8,10]
[2,6,10]
```

**示例 2：**
**输入：** nums = [7,7,7,7,7]
**输出：** 16
**解释：** 数组中的任意子序列都是等差子序列。

**提示：**
- `1  <= nums.length <= 1000`
- `-2^31 <= nums[i] <= 2^31 - 1`

## 解题思路


**核心挑战**  
1. **高效统计所有可能序列**：需要避免重复计算并覆盖所有公差情况。  
2. **处理重复元素**：数值相同的元素在不同位置需视为不同子序列。



**算法设计**  
> [!tip]+ 状态定义的推导
> 1. **==一维状态 `dp[i]` 的局限性==**
> 
> 	若定义 `dp[i]` 为以 `nums[i]` 结尾的等差子序列数量，存在以下问题：
> 	
> 	- **无法追踪公差**：不同前驱元素可能形成不同公差的子序列，但 `dp[i]` 无法区分这些公差。
> 	- **状态转移不完整**：无法确定当前元素应与哪个前驱元素的公差匹配。
> 	
> 	**示例**： 数组 `[2,4,6,8]`，以 `8` 结尾的子序列可能有：
> 	
> 	- 公差为2的子序列：`[2,4,6,8]`。
> 	- 公差为4的子序列：`[2,6,8]`。 `dp[3]` 无法同时记录这两种不同公差的情况。
> 
> 2. **==二维状态 `dp[i][j]` 的必要性==**
> 	 **状态定义**
> 	- **`dp[i][j]`**：表示以 `nums[j]` 和 `nums[i]` 作为最后两个元素的等差子序列的数量。
> 	- **物理意义**：明确记录了公差 `d = nums[i] - nums[j]`，从而唯一确定当前序列的等差特性。
> 	
> 	**状态转移方程的推导**
> 	要形成以 `nums[j]` 和 `nums[i]` 结尾的等差子序列，必须存在一个前驱元素 `nums[k]`，使得：$$nums[j] - nums[k] = nums[i] - nums[j] => nums[k] = 2 * nums[j] - nums[i]$$
> 	- **数学意义**：`nums[k]` 是等差数列的前驱元素，与 `nums[j]` 和 `nums[i]` 构成连续三项。



1. **状态定义**  
   - `dp[i][j]`：表示以 `nums[i]` 和 `nums[j]` 作为最后两个元素的等差子序列的数量。  
   - **初始值**：所有 `dp[i][j]` 初始化为0，后续逐步累加。

2. **状态转移**  
   - 对于每对 `(i, j)`（`i < j`），计算前驱元素值 `x = 2 * nums[i] - nums[j]`，即满足 `nums[i] - x = nums[j] - nums[i]`。  
   - 若 `x` 存在且其位置 `k < i`，则所有以 `k` 和 `i` 结尾的子序列均可扩展为以 `i` 和 `j` 结尾的子序列：  $$dp[i][j] += dp[k][i] + 1$$  
   - **解释**：  
     - `dp[k][i]` 表示以 `k` 和 `i` 结尾的序列数量。  
     - `+1` 表示新增一个长度为3的子序列 `[k, i, j]`。

3. **哈希表优化**  
   - 使用哈希表 `hash` 存储元素值到所有出现位置的映射，以快速查找满足条件的前驱元素位置。

4. **结果统计**  
   - 遍历所有 `dp[i][j]`，累加其值到结果 `result` 中。


> [!tip]+ 关键点解析
> 1. **哈希表的作用**
>     - 快速定位满足条件的前驱元素位置，避免遍历数组，将时间复杂度从 **O(n³)** 优化至 **O(n²)**。
> 2. **状态转移的逻辑**
>     - 当找到合法前驱 `k` 时，`dp[i][j]` 继承 `dp[k][i]` 的所有序列并扩展一个元素，同时新增一个长度为3的序列。
> 3. **重复元素的处理**
>     - 哈希表记录所有相同数值的位置，通过条件 `k < i` 保证顺序正确性，避免重复计数。


## 代码实现

```cpp
class Solution {
public:
    int numberOfArithmeticSlices(vector<int>& nums) {
        int n = nums.size();
        if (n < 3) return 0;

        // dp[i][j]表示以i和j结尾的等差子序列的数量
        vector<vector<int>> dp(n, vector<int>(n, 0));
        // 哈希表记录每个数值的所有出现位置
        unordered_map<int, vector<int>> hash;

        // 初始化哈希表：记录每个数值的所有索引
        for (int i = 0; i < n; i++) {
            hash[nums[i]].push_back(i);
        }

        int result = 0;
        // 遍历所有可能的第三元素位置j
        for (int j = 2; j < n; j++) {
            // 遍历所有可能的第二元素位置i（i < j）
            for (int i = 1; i < j; i++) {
                // 计算前驱元素值
                int x = 2 * nums[i] - nums[j];
                // 若存在满足条件的前驱元素
                if (hash.count(x)) {
                    // 遍历所有前驱位置k
                    for (int k : hash[x]) {
                        // 前驱位置必须严格在i之前
                        if (k < i) {
                            // 状态转移：累加数量
                            dp[i][j] += dp[k][i] + 1;
                        }
                    }
                }
                // 将当前i和j的数量累加到结果中
                result += dp[i][j];
            }
        }

        return result;
    }
};
```


### 复杂度分析
- **时间复杂度**：O (n²)，每个元素对 `(i, j)` 处理一次，哈希表操作均为 O (1)。
- **空间复杂度**：O (n²)，每个元素最多存储 O (n) 个公差的子序列数目。