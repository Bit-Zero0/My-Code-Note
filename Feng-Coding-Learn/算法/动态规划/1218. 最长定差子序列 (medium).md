---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-14 18:38
Finish-date: 
Modified-date: 2025-03-14 19:14
Publish: false
---


# 1218. 最长定差子序列
[1218. 最长定差子序列](https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference/)

## 题目描述
给你一个整数数组 `arr` 和一个整数 `difference`，请你找出并返回 `arr` 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 `difference` 。

**子序列** 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 `arr` 派生出来的序列。

**示例 1：**
**输入：** arr = [1,2,3,4], difference = 1
**输出：** 4
**解释：** 最长的等差子序列是 [1,2,3,4]。

**示例 2：**
**输入：** arr = [1,3,5,7], difference = 1
**输出：** 1
**解释：** 最长的等差子序列是任意单个元素。

**示例 3：**
**输入：** arr = [1,5,7,8,5,3,4,2,1], difference = -2
**输出：** 4
**解释：** 最长的等差子序列是 [7,5,3,1]。

**提示：**
- `1 <= arr.length <= 10^5`
- `-10^4 <= arr[i], difference <= 10^4`

## 解题思路



**算法设计**  
1. **状态定义**  
   - 使用哈希表 `dp`，键为元素值，值为以该元素结尾的最长等差子序列长度。例如，`dp[x]` 表示以元素 `x` 结尾的子序列的最大长度。  

2. **状态转移方程**  
   - 对于当前元素 `arr[i]`，其前驱元素应为 `prev = arr[i] - difference`。  
   - 转移规则：  $$dp[arr[i]] = dp[prev] + 1 \quad (\text{若} \, prev \, \text{存在，否则初始化为1})$$
   - **解释**：如果存在前驱元素 `prev`，则当前子序列长度在前驱基础上加1；否则，当前元素单独构成长度为1的子序列。

3. **初始状态**  
   - 初始化 `dp[arr[0]] = 1`，表示第一个元素自身构成一个子序列。

4. **全局结果更新**  
   - 在遍历过程中，实时更新全局最大值 `result`。


> [!tip]+ 关键点
> 1. **哈希表的作用**  
>    - 哈希表直接以元素值作为键，避免了遍历查找前驱元素的复杂度，将状态转移优化到 **O(1)** 时间。
> 
> 2. **处理前驱不存在的情况**  
>    - 若前驱元素 `prev` 不存在于哈希表中，说明当前元素无法连接到任何已有子序列，因此以其自身作为起点，长度为1。
> 
> 3. **动态更新的正确性**  
>    - 即使存在多个相同值的元素，哈希表会记录最后一次出现的位置，但由于子序列允许不连续，这并不影响最长长度的计算。例如，`[1,2,1,2]` 中，公差为1的最长子序列长度为2（`[1,2]` 或 `[1,2]`），哈希表会正确维护最大值。


## 代码实现

```cpp
class Solution {
public:
    int longestSubsequence(vector<int>& arr, int difference) {
        unordered_map<int, int> dp;  // key: 元素值，value: 以该元素结尾的最长子序列长度
        dp[arr[0]] = 1;             // 初始化第一个元素
        int result = 1;             // 记录全局最大值

        for (int i = 1; i < arr.size(); i++) {
            int prev = arr[i] - difference;  // 计算前驱元素的值
            // 如果前驱存在，则当前长度为前驱长度+1；否则，当前元素单独成序列，长度为1
            dp[arr[i]] = dp.count(prev) ? dp[prev] + 1 : 1;
            result = max(result, dp[arr[i]]);  // 更新最大值
        }

        return result;
    }
};
```

### 示例分析

以输入 `arr = [1,5,7,8,5,3,4,2,1]`，`difference = -2` 为例：  
1. **初始化**：`dp[1] = 1`，`result = 1`。  
2. **处理元素5**：`prev = 5 - (-2) = 7`，`dp[7]` 不存在，故 `dp[5] = 1`，`result` 保持1。  
3. **处理元素7**：`prev = 7 - (-2) = 9`，不存在，`dp[7] = 1`。  
4. **处理元素8**：`prev = 10`，不存在，`dp[8] = 1`。  
5. **处理元素5**：`prev = 5 - (-2) = 7`，`dp[7] = 1` → `dp[5] = 2`，`result` 更新为2。  
6. **处理元素3**：`prev = 3 - (-2) = 5`，`dp[5] = 2` → `dp[3] = 3`，`result` 更新为3。  
7. **后续元素同理**，最终结果为3。


### **复杂度分析**：
- **时间复杂度**：O (n)，其中 `n` 是数组长度。每个元素仅需常数时间处理。
- **空间复杂度**：O (n)，哈希表最多存储 `n` 个元素。
