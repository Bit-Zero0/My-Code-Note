---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-04 17:42
Finish-date: 
Modified-date: 2025-03-04 18:14
Publish: false
---


# 740. 删除并获得点数
[740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)

## 题目描述
给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 `nums[i]`，删除它并获得 `nums[i]` 的点数。之后，你必须删除 所有 等于 `nums[i] - 1` 和 `nums[i] + 1 `的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

**示例 1：**
输入：nums = `[3,4,2]`
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

**示例 2：**
输入：nums = `[2,2,3,3,3,4]`
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
 

提示：
`1 <= nums.length <= 2 * 10^4`
`1 <= nums[i] <= 10^4`


## 解题思路

本题的核心在于如何在删除元素时避免相邻数值的冲突，同时最大化获得的点数。我们可以将问题转化为类似[[面试题 17.16. 按摩师 (easy)|打家劫舍]]的动态规划问题，通过以下步骤解决：

### 问题转化
1. **数值分组与点数统计**  
   对于数值 `x`，所有等于 `x` 的元素被删除时，总点数为 `x * count(x)`（`count(x)` 是 `x` 的出现次数）。我们用一个数组 `arr` 记录每个数值的总点数，其中 `arr[x] = x * count(x)`。

2. **避免相邻数值的冲突**  
   如果选择删除数值 `x`，则不能删除 `x-1` 和 `x+1`。这与[[面试题 17.16. 按摩师 (easy)|打家劫舍]]问题中不能偷相邻房屋的约束类似，因此可以用动态规划处理。

### 动态规划设计
定义两个状态数组：
- `select[i]`：表示选择数值 `i` 时的最大点数。
- `notSelect[i]`：表示不选择数值 `i` 时的最大点数。

**状态转移方程**：
- **选择 `i`**：必须不选择 `i-1`，因此当前点数为 `notSelect[i-1] + arr[i]`。
- **不选择 `i`**：取选择或不选择 `i-1` 的较大值，即 `max(select[i-1], notSelect[i-1])`。

**初始条件**：
- 初始化 `select = 0` 和 `notSelect = 0`，表示没有数值时的点数为 0。

## 代码实现

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        const int N = 10001; // 数值范围上限
        int arr[N] = {0};
        // 统计每个数值的总点数
        for (auto x : nums) {
            arr[x] += x;
        }

        vector<int> select(N), notSelect(N); // 动态规划状态数组

        // 遍历所有可能的数值（1到10000）
        for (int i = 1; i < N; i++) {
            // 选择当前数值i：必须不选i-1，点数累加arr[i]
            select[i] = notSelect[i - 1] + arr[i];
            // 不选当前数值i：取i-1选或不选的较大值
            notSelect[i] = max(select[i - 1], notSelect[i - 1]);
        }

        // 最终结果是选或不选最大数值的较大值
        return max(select[N - 1], notSelect[N - 1]);
    }
};
```

### 复杂度分析
- **时间复杂度**：O(N)，其中 N 是数值范围上限（本题为 10000）。遍历所有数值一次。
- **空间复杂度**：O(N)，用于存储动态规划状态数组。可优化为 O(1)（使用两个变量代替数组）。
