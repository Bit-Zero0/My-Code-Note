---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-24 17:03
Finish-date: 
Modified-date: 2025-01-24 21:04
Publish: false
---


# 63. 不同路径 II
[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

## 题目描述
给定一个 `m x n` 的整数数组 `grid`。一个机器人初始位于 **左上角**（即 `grid[0][0]`）。机器人尝试移动到 **右下角**（即 `grid[m - 1][n - 1]`）。机器人每次只能向下或者向右移动一步。

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。机器人的移动路径中不能包含 **任何** 有障碍物的方格。

返回机器人能够到达右下角的不同路径数量。

测试用例保证答案小于等于 `2 * 109`。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)
**输入：** obstacleGrid = `[[0,0,0],[0,1,0],[0,0,0]]
**输出：** 2
**解释：** 3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 `2` 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

**示例 2：**
![](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)
**输入：** obstacleGrid = `[[0,1],[0,0]]`
**输出：** 1

**提示：**
- `m == obstacleGrid.length`
- `n == obstacleGrid[i].length`
- `1 <= m, n <= 100`
- `obstacleGrid[i][j]` 为 `0` 或 `1`


## 解题思路
#### **问题背景**

题目要求计算从左上角到右下角的路径数量，但路径中可能存在障碍物（用 `1` 表示）。如果遇到障碍物，则不能通过该位置。这是一个经典的动态规划问题，需要考虑障碍物对路径的影响。

#### **关键点分析**
1. 状态定义
	- 定义 `dp[i][j]` 表示从起点 `(0, 0)` 到达格子 `(i-1, j-1)` 的路径总数。
	- 为了方便处理边界条件，`dp` 数组的大小为 `(m+1) x (n+1)`，其中 `dp[0][*]` 和 `dp[*][0]` 是辅助边界。
2. 状态转移方程
	- 如果当前格子有障碍物，则 `dp[i][j] = 0`。
	- 如果当前格子 `(i-1, j-1)` 没有障碍物（`ob[i-1][j-1] == 0`），则：
```
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```
	
3. 初始条件
	- `dp[1][0] = 1`：这是一个辅助初始条件，用于启动状态转移。
	- 其他 `dp[0][*]` 和 `dp[*][0]` 的值均为 0，因为这些位置是辅助边界，没有实际意义。
4. 填表过程
	- 从 `i = 1` 到 `m`，`j = 1` 到 `n`，逐步计算 `dp[i][j]`。
	- 每次计算 `dp[i][j]` 时，依赖于 `dp[i-1][j]` 和 `dp[i][j-1]`。
5. 最终结果
	- `dp[m][n]` 表示从起点 `(0, 0)` 到终点 `(m-1, n-1)` 的路径总数。


#### **难点应对**
1. **如何处理起点有障碍物的情况？**  
    如果起点有障碍物，则直接返回 `0`，因为无法开始。
2. **如何处理边界上的障碍物？**  
    如果某一行或某一列的第一个位置有障碍物，则该行或列之后的所有位置都无法到达，路径数量为 `0`。
    

### 算法流程
1. **初始化：**
    - 获取数组的行数 `m` 和列数 `n`。
    - 初始化二维动态规划数组 `dp`，大小为 `(m+1) x (n+1)`，所有值初始化为 `0`。
    - 初始化 `dp[1][0] = 1`，表示从起点到起点有1条路径。
2. **遍历数组：**
    - 遍历每个位置 `(i, j)`：
        - 如果当前位置有障碍物（`ob[i-1][j-1] == 1`），则跳过该位置的计算。
        - 否则，根据状态转移方程计算 `dp[i][j]`。
3. **返回结果：**
    - 返回 `dp[m][n]`，即从起点到终点的路径数量。

## C++代码

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& ob) {
        int m = ob.size(), n = ob[0].size(); // 网格的行数和列数
        vector<vector<int>> dp(m + 1, vector<int>(n + 1)); // 定义 dp 数组

        dp[1][0] = 1; // 辅助初始条件，用于启动状态转移

        // 填表过程
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (ob[i - 1][j - 1] == 0) { // 如果当前格子没有障碍物
                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 状态转移方程
                }
            }
        }

        return dp[m][n]; // 返回从起点到终点的路径总数
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(m * n)`，其中 `m` 和 `n` 分别是网格的行数和列数。我们需要遍历整个网格。
- **空间复杂度**：`O(m * n)`，用于存储动态规划数组。

