---
Type: Note
tags:
  - 算法
  - easy
Status: done
Start-date: 2025-01-20 22:42
Finish-date: 2025-01-20
Modified-date: 2025-03-04 18:15
Publish: false
---


# 746. 使用最小花费爬楼梯
[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

## 题目描述
给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**
**输入：** cost = [10,15,20]
**输出：** 15
**解释：** 你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。

**示例 2：**
**输入：** cost = [1,100,1,1,1,100,1,1,100,1]
**输出：** 6
**解释：** 你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。

**提示：**
- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

## 解题思路
#### 关键点：
1. 状态定义
	- 定义 `dp[i]` 表示到达第 `i` 阶楼梯的最小花费。
	- 注意：`dp[i]` 并不包括第 `i` 阶的花费，而是到达第 `i` 阶之前的总花费。
2. **状态转移方程**：
	- 到达第 `i` 阶楼梯的最小花费可以从第 `i-1` 阶或第 `i-2` 阶转移而来。
	- 状态转移方程为：
     ```
     dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
     ```
3. **初始条件**：
	- `dp[0] = 0`，表示到达第 0 阶楼梯不需要花费。
	- `dp[1] = 0`，表示到达第 1 阶楼梯不需要花费。
1. **最终结果**：`dp[n]`，其中 `n` 是楼梯的总阶数。



### 算法流程
1. 初始化动态规划数组 `dp`，大小为 `cost.size() + 1`。
2. 设置初始条件：
   - `dp[0] = 0`。
   - `dp[1] = 0`。
3. 从 `i = 2` 开始遍历到 `n`，计算 `dp[i]`：
   - `dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`。
4. 返回 `dp[n]`，即为到达楼梯顶部的最小花费。


#### 示例解释
以 `cost = [10, 15, 20]` 为例：
1. 初始化：
   - `dp[0] = 0`。
   - `dp[1] = 0`。
2. 计算 `dp[2]`：
   - `dp[2] = min(dp[1] + cost[1], dp[0] + cost[0]) = min(0 + 15, 0 + 10) = 10`。
3. 计算 `dp[3]`：
   - `dp[3] = min(dp[2] + cost[2], dp[1] + cost[1]) = min(10 + 20, 0 + 15) = 15`。
4. 返回 `dp[3] = 15`。

## C++代码
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n + 1); // 动态规划数组，dp[i] 表示到达第 i 阶楼梯的最小花费

        dp[0] = 0; // 到达第 0 阶楼梯不需要花费
        dp[1] = 0; // 到达第 1 阶楼梯不需要花费

        for (int i = 2; i <= n; i++) {
            // 状态转移方程：从第 i-1 阶或第 i-2 阶转移而来
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }

        return dp[n]; // 返回到达楼梯顶部的最小花费
    }
};
```

#### 复杂度分析
- **时间复杂度**：`O(n)`，需要遍历 `cost` 数组一次。
- **空间复杂度**：`O(n)`，需要一个大小为 `n+1` 的数组来存储动态规划状态。


### 优化空间复杂度
如果不需要存储整个动态规划数组，可以使用 **滚动变量** 来优化空间复杂度：
```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        int prev1 = 0, prev2 = 0; // 初始化 dp[0] 和 dp[1]
        for (int i = 2; i <= n; i++) {
            int curr = min(prev1 + cost[i - 1], prev2 + cost[i - 2]);
            prev2 = prev1;
            prev1 = curr;
        }
        return prev1;
    }
};
```
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。


