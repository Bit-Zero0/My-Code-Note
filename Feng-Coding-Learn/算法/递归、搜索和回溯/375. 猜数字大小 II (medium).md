---
Type: Note
tags:
  - 算法
  - medium
  - 递归
  - 记忆化搜索
Status: writing
Start-date: 2025-03-19 17:16
Finish-date: 
Modified-date: 2025-03-19 17:48
Publish: false
---


# 375. 猜数字大小 II
[375. 猜数字大小 II](https://leetcode.cn/problems/guess-number-higher-or-lower-ii/)

## 题目描述
我们正在玩一个猜数游戏，游戏规则如下：

1. 我从 `1` 到 `n` 之间选择一个数字。
2. 你来猜我选了哪个数字。
3. 如果你猜到正确的数字，就会 **赢得游戏** 。
4. 如果你猜错了，那么我会告诉你，我选的数字比你的 **更大或者更小** ，并且你需要继续猜数。
5. 每当你猜了数字 `x` 并且猜错了的时候，你需要支付金额为 `x` 的现金。如果你花光了钱，就会 **输掉游戏** 。

给你一个特定的数字 `n` ，返回能够 **确保你获胜** 的最小现金数，**不管我选择那个数字** 。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/09/10/graph.png)

**输入：** n = 10
**输出：**16
** 解释：** 制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。

**示例 2：**
**输入：** n = 1
**输出：** 0
**解释：** 只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。

**示例 3：**
**输入：** n = 2
**输出：** 1
**解释：** 有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。

**提示：**
- `1 <= n <= 200`

## 解题思路

使用**记忆化递归**（自顶向下动态规划），通过递归探索所有可能的猜测点，并利用记忆化存储中间结果，避免重复计算。

### 关键步骤
1. **状态定义**：  
   `memo[l][r]` 表示在区间 `[l, r]` 内确保获胜的最小费用。

2. **递归逻辑**：  
   对于当前区间 `[l, r]`，遍历所有可能的猜测点 `k`：
   - 若猜测 `k` 错误，需支付 `k` 元，并处理左边子区间 `[l, k-1]` 或右边子区间 `[k+1, r]`。
   - 最坏情况下的费用为 `k + max(左边费用, 右边费用)`。

3. **记忆化优化**：  
   用二维数组 `memo` 存储已计算的区间费用，避免重复递归。

4. **边界条件**：  
   - 当区间长度为 0（`l > r`）或 1（`l == r`）时，费用为 0。


> [!tip]+ 关键点
> 1. **记忆化存储**：  
>    通过 `memo` 数组避免重复计算相同子问题，将指数级时间复杂度优化为多项式级。
> 
> 2. **递归方向**：  
>    从后往前递归，确保子区间的结果先被计算，避免重复探索。

## 代码实现
```cpp
class Solution {
    int memo[201][201]; // 记忆化数组，存储区间 [l, r] 的最小费用

public:
    int getMoneyAmount(int n) {
        return dfs(1, n); // 初始区间为 [1, n]
    }

    int dfs(int l, int r) {
        if (l >= r) return 0; // 区间长度为 0 或 1，费用为 0
        if (memo[l][r] != 0) return memo[l][r]; // 已计算过，直接返回

        int result = INT_MAX; // 初始化为最大值
        for (int k = l; k <= r; ++k) {
            // 递归计算左右子区间的费用
            int left = dfs(l, k - 1);
            int right = dfs(k + 1, r);
            // 取左右子区间的最大值，加上当前猜测的费用
            int cost = max(left, right) + k;
            if (cost < result) result = cost; // 更新最小值
        }

        memo[l][r] = result; // 存储结果
        return result;
    }
};
```


### 示例分析
以 `n = 2` 为例：
1. **初始调用**：`dfs(1, 2)`。
2. **遍历猜测点**：
   - **k = 1**：左边无元素（费用 0），右边为 `[2, 2]`（费用 0）。总费用 `1 + max(0, 0) = 1`。
   - **k = 2**：左边为 `[1, 1]`（费用 0），右边无元素。总费用 `2 + max(0, 0) = 2`。
3. **取最小值**：选择 `k = 1`，总费用为 `1`，与示例结果一致。

### 复杂度分析
- **时间复杂度**：$O(n^3)$  
  每个区间 `[l, r]` 需遍历 $O(n)$ 个可能的猜测点，总共有 $O(n^2)$ 个区间。

- **空间复杂度**：$O(n^2)$  
  记忆化数组 `memo` 的大小为 $O(n^2)$。




