---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-14 16:17
Finish-date: 
Modified-date: 2025-03-14 16:48
Publish: false
---


# 79. 单词搜索
[79. 单词搜索](https://leetcode.cn/problems/word-search/)

## 题目描述
给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)
**输入：** board = `[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, word = "ABCCED"
**输出：** true

**示例 2：**
![](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)
**输入：** board = `[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, word = "SEE"
**输出：** true

**示例 3：**
![](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)
**输入：** board = `[["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, word = "ABCB"
**输出：** false

**提示：**
- `m == board.length`
- `n = board[i].length`
- `1 <= m, n <= 6`
- `1 <= word.length <= 15`
- `board` 和 `word` 仅由大小写英文字母组成

## 解题思路

本题可以使用回溯算法来解决。回溯算法本质上是一种深度优先搜索算法，它会尝试所有可能的路径，当发现当前路径无法得到有效结果时，会回退到上一步，尝试其他路径。

### 具体思路
1. **遍历网格**：
    - 首先，我们需要遍历整个二维字符网格 `board`，找到所有与单词 `word` 的第一个字符相同的单元格。因为单词的起始位置可能在网格的任意一个与首字母匹配的单元格处。
2. **深度优先搜索（DFS）**：
    - 对于每一个与单词首字母匹配的单元格，我们从该单元格开始进行深度优先搜索。
    - 在 DFS 过程中，我们会检查当前单元格的上、下、左、右四个相邻单元格，看是否能继续匹配单词的下一个字符。
    - 为了避免重复使用同一个单元格，我们使用一个 `used` 数组来标记每个单元格是否已经被使用过。
    - 当我们成功匹配到单词的最后一个字符时，说明找到了完整的单词，返回 `true`。
    - 如果在某个分支上无法继续匹配，我们会回溯到上一步，撤销当前单元格的使用标记，继续尝试其他可能的路径。

### 详细步骤
1. **初始化数据结构**：
    - `used` 数组：`bool used[7][7]`，用于标记每个单元格是否已经被使用过。这里假设网格的最大尺寸为 `7x7`，实际应用中可以根据具体情况调整大小。
    - `dx` 和 `dy` 数组：分别表示水平和垂直方向的偏移量，用于遍历当前单元格的四个相邻单元格（上、下、左、右）。
    - `m` 和 `n`：分别表示网格的行数和列数。
2. **遍历网格找到起始点**：
    - 在 `exist` 函数中，我们使用两层嵌套的 `for` 循环遍历整个网格。当找到一个单元格的字符与单词的第一个字符相同时，将该单元格标记为已使用，并调用 `dfs` 函数开始深度优先搜索。
    - 如果 `dfs` 函数返回 `true`，说明找到了完整的单词，直接返回 `true`。
    - 如果 `dfs` 函数返回 `false`，说明从当前起始点无法找到完整的单词，将该单元格标记为未使用，继续尝试其他起始点。
3. **深度优先搜索（DFS）**：
    - 在 `dfs` 函数中，首先检查 `pos` 是否等于单词的长度。如果相等，说明已经成功匹配到单词的最后一个字符，返回 `true`。
    - 然后，使用一个 `for` 循环遍历当前单元格的四个相邻单元格。对于每个相邻单元格，检查其是否在网格范围内、是否未被使用过以及其字符是否与单词的当前字符相同。
    - 如果满足条件，将该相邻单元格标记为已使用，并递归调用 `dfs` 函数继续匹配下一个字符。
    - 如果递归调用返回 `true`，说明找到了完整的单词，直接返回 `true`。
    - 如果递归调用返回 `false`，说明从当前相邻单元格无法找到完整的单词，将该相邻单元格标记为未使用，继续尝试其他相邻单元格。
    - 如果遍历完所有相邻单元格都无法找到完整的单词，返回 `false`。

## 代码实现
```cpp
#include <vector>
#include <string>
using namespace std;

class Solution {
    // 用于标记每个单元格是否已经被使用过
    bool used[7][7]; 
    // 水平方向的偏移量，用于遍历相邻单元格（上、下、左、右）
    int dx[4] = {0 , 0 , 1 , -1};
    // 垂直方向的偏移量，用于遍历相邻单元格（上、下、左、右）
    int dy[4] = {1 , -1 , 0 , 0};
    // 网格的行数
    int m;
    // 网格的列数
    int n;

public:
    bool exist(vector<vector<char>>& board, string word) {
        // 获取网格的行数和列数
        m = board.size();
        n = board[0].size();
        // 遍历整个网格
        for(int i = 0 ; i < m ; i++) {
            for(int j = 0 ; j < n ; j++) {
                // 找到与单词首字母匹配的单元格
                if(board[i][j] == word[0]) {
                    // 标记该单元格为已使用
                    used[i][j] = true;
                    // 从该单元格开始进行深度优先搜索
                    if(dfs(board , i , j , word , 1)) return true;
                    // 回溯，将该单元格标记为未使用
                    used[i][j] = false;
                }
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board , int i , int j , string& word ,  int pos) {
        // 当 pos 等于单词的长度时，说明已经成功匹配到单词的最后一个字符
        if(pos == word.size()) return true;

        // 遍历当前单元格的四个相邻单元格
        for(int k = 0 ; k < 4 ; k++) {
            // 计算相邻单元格的坐标
            int x = i + dx[k];
            int y = j + dy[k];
            // 检查相邻单元格是否在网格范围内、未被使用过且字符与单词的当前字符相同
            if(x >= 0 && x < m && y >= 0 && y < n && !used[x][y] && board[x][y] == word[pos]) {
                // 标记该相邻单元格为已使用
                used[x][y] = true;
                // 递归调用 dfs 函数继续匹配下一个字符
                if(dfs(board , x , y , word , pos + 1)) return true;
                // 回溯，将该相邻单元格标记为未使用
                used[x][y] = false;
            }
        }
        return false;
    }
};
```

### 复杂度分析
- **时间复杂度**：$O(m \times n \times 3^L)$，其中 $m$ 和 $n$ 分别是网格的行数和列数，$L$ 是单词的长度。对于每个单元格，我们最多有 3 个方向可以继续搜索（因为不能回到上一个单元格），所以总的时间复杂度为 $O(m \times n \times 3^L)$。
- **空间复杂度**：$O(m \times n)$，主要用于递归调用栈和 `used` 数组的空间。递归调用栈的深度最大为 $L$，而 `used` 数组的大小为 $m \times n$，因此空间复杂度为 $O(m \times n)$。


