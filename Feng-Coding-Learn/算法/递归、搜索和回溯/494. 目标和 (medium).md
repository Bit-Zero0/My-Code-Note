---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-11 16:47
Finish-date: 
Modified-date: 2025-03-11 16:58
Publish: false
---


# 494. 目标和
[494. 目标和](https://leetcode.cn/problems/target-sum/)

## 题目描述
给你一个非负整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**
**输入：** nums = [1,1,1,1,1], target = 3
**输出：** 5
**解释：** 一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

**示例 2：**
**输入：** nums = [1], target = 1
**输出：** 1

**提示：**
- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`

## 解题思路

### 目标和

#### 题目描述
给定一个整数数组 `nums` 和一个整数 `target`，通过向数组中的每个元素前添加 `+` 或 `-`，构造一个表达式，使得运算结果等于目标值。返回所有可能的符号组合数量。

示例：  
输入：nums = [1,1,1,1,1], target = 3  
输出：5  
解释：共有5种符号组合方式使和为3。


### 解题思路

我们需要为数组中每个元素选择 `+` 或 `-`，使得表达式结果等于目标值。所有元素必须被使用，且顺序不可变。问题本质是穷举所有可能的符号组合，统计符合条件的方案数。

#### 选择回溯法
回溯法通过深度优先搜索（DFS）遍历所有可能的符号组合：
1. **路径状态**：维护当前路径的和 `path`。
2. **选择列表**：每个元素有两种选择（`+` 或 `-`）。
3. **递归终止条件**：处理完所有元素时，检查路径和是否等于目标值。
4. **回溯操作**：每次递归后撤销选择，恢复路径状态。

#### 关键步骤
1. **递归终止**：当处理到最后一个元素后（`pos == nums.size()`），验证路径和是否匹配目标。
2. **符号选择**：
   - **添加正号**：将当前元素值加到路径和中。
   - **添加负号**：将当前元素值从路径和中减去。
3. **状态回退**：每次递归返回后，恢复路径和的状态，以尝试其他可能性。


### 代码实现

```cpp
class Solution {
    int path = 0;           // 当前路径和
    int result = 0;         // 符合条件的组合数
    int _target;            // 目标值

public:
    int findTargetSumWays(vector<int>& nums, int target) {
        _target = target;
        dfs(nums, 0);       // 从第0个元素开始回溯
        return result;
    }

    void dfs(vector<int>& nums, int pos) {
        // 终止条件：处理完所有元素
        if (nums.size() == pos) {
            if (path == _target) result++;
            return;
        }

        // 选择1：添加正号（将当前元素加到路径和）
        path += nums[pos];
        dfs(nums, pos + 1); // 递归处理下一个元素
        path -= nums[pos];  // 回溯，撤销选择

        // 选择2：添加负号（从路径和中减去当前元素）
        path -= nums[pos];
        dfs(nums, pos + 1); // 递归处理下一个元素
        path += nums[pos];  // 回溯，撤销选择
    }
};
```


### 复杂度分析

- **时间复杂度**：**O(2ⁿ)**  
  每个元素有2种选择，递归树共有 2ⁿ 个叶子节点（n为数组长度）。例如，n=20时需处理约100万次递归。

- **空间复杂度**：**O(n)**  
  递归栈深度最大为n（线性遍历数组），未使用额外空间存储路径。



