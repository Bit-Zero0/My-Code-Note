---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-14 17:17
Finish-date: 
Modified-date: 2025-03-14 17:24
Publish: false
---


# 980. 不同路径 III
[980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/)

## 题目描述
在二维网格 `grid` 上，有 4 种类型的方格：
- `1` 表示起始方格。且只有一个起始方格。
- `2` 表示结束方格，且只有一个结束方格。
- `0` 表示我们可以走过的空方格。
- `-1` 表示我们无法跨越的障碍。

返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

**每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格**。


**示例 1：**
**输入：** `[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]`
**输出：** 2
**解释：** 我们有以下两条路径：
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)

**示例 2：**
**输入：**`[[1,0,0,0],[0,0,0,0],[0,0,0,2]]`
**输出：** 4
**解释：** 我们有以下四条路径： 
1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)

**示例 3：**
**输入：**`[[0,1],[2,0]]`
**输出：** 0
**解释：**
没有一条路能完全穿过每一个空的方格一次。
请注意，起始和结束方格可以位于网格中的任意位置。


**提示：**
- `1 <= grid.length * grid[0].length <= 20`

## 解题思路

### 核心思想
本题要求找出从起点到终点，且经过所有非障碍物单元格恰好一次的路径数量。我们可以使用回溯算法（深度优先搜索）来遍历所有可能的路径，并统计满足条件的路径数量。
1. **统计必要步数**：计算所有空单元格（`0`）的数量，加上起点和终点，得到路径必须的总步数。
2. **回溯搜索**：从起点出发，尝试四个方向移动，标记已访问的单元格，递归搜索路径。
3. **剪枝与终止条件**：
    - 到达终点时，检查是否已覆盖所有必要单元格。
    - 无法移动或路径无效时，回溯撤销选择

#### 具体步骤
1. **初始化与统计**：
    - 遍历整个网格，统计值为 `0` 的单元格数量，这些单元格是需要经过的中间单元格。
    - 同时找到起点（值为 `1` 的单元格）和终点（值为 `2` 的单元格）的位置。
    - 因为要经过起点和终点，所以总的需要经过的单元格数量 `step` 等于 `0` 的数量加上 `2`。
2. **深度优先搜索（DFS）**：
    - 从起点开始进行深度优先搜索，使用 `used` 数组来标记每个单元格是否已经被访问过，避免重复访问。
    - 在 `dfs` 函数中，当到达终点（即 `grid[i][j] == 2`）时，检查当前经过的单元格数量 `count` 是否等于总的需要经过的单元格数量 `step`。如果相等，说明找到了一条满足条件的路径，将结果 `result` 加 `1`。
    - 对于当前位置 `(i, j)`，尝试向四个方向（上、下、左、右）进行扩展。对于每个扩展的新位置 `(x, y)`，检查其是否在网格范围内、未被访问过且不是障碍物（值不为 `-1`）。
    - 如果满足条件，将新位置标记为已访问，递归调用 `dfs` 函数继续搜索，并将经过的单元格数量 `count` 加 `1`。
    - 在递归返回后，将新位置标记为未访问，以便尝试其他可能的路径，这就是回溯的过程。

## 代码实现
```cpp
class Solution {
    int step = 0;
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};
    bool used[21][21];
    int result = 0;
    int m, n;

public:
    int uniquePathsIII(vector<vector<int>>& grid) {
        int startX, startY;
        m = grid.size();
        n = grid[0].size();
        // 遍历网格，统计需要经过的 0 的数量和找到起点位置
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 0) step++;
                if (grid[i][j] == 1) {
                    startX = i;
                    startY = j;
                }
            }
        }
        // 加上起点和终点，总共需要经过的步数
        step += 2;
        used[startX][startY] = true;
        dfs(grid, startX, startY, 1);
        return result;
    }

    void dfs(vector<vector<int>>& grid, int i, int j, int count) {
        // 当到达终点时
        if (grid[i][j] == 2) {
            // 如果经过的步数等于需要经过的总步数
            if (step == count)
                result++;
            return;
        }
        // 遍历四个方向
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            // 检查新位置是否合法且未被访问过，同时不是障碍物
            if (x >= 0 && x < m && y >= 0 && y < n && !used[x][y] && grid[x][y] != -1) {
                used[x][y] = true;
                dfs(grid, x, y, count + 1);
                used[x][y] = false;
            }
        }
    }
};
```

### 复杂度分析
- **时间复杂度**：$O(3^{m\times n})$。在最坏情况下，对于每个单元格，除了来的方向，有 3 个方向可以继续探索，网格的大小为 $m\times n$，所以时间复杂度为 $O(3^{m\times n})$。
- **空间复杂度**：$O(m\times n)$。主要是递归调用栈的空间和 `used` 数组的空间开销，递归的最大深度为 $m\times n$。

