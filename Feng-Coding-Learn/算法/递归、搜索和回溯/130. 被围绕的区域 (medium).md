---
Type: Note
tags:
  - 算法
  - medium
  - FLoodFill算法
  - 递归
Status: writing
Start-date: 2025-03-16 14:50
Finish-date: 
Modified-date: 2025-03-16 15:33
Publish: false
---


# 130. 被围绕的区域
[130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)

## 题目描述
给你一个 `m x n` 的矩阵 `board` ，由若干字符 `'X'` 和 `'O'` 组成，**捕获** 所有 **被围绕的区域**：
- **连接：** 一个单元格与水平或垂直方向上相邻的单元格连接。
- **区域：连接所有** `'O'` 的单元格来形成一个区域。
- **围绕：** 如果您可以用 `'X'` 单元格 **连接这个区域**，并且区域中没有任何单元格位于 `board` 边缘，则该区域被 `'X'` 单元格围绕。

通过 **原地** 将输入矩阵中的所有 `'O'` 替换为 `'X'` 来 **捕获被围绕的区域**。你不需要返回任何值。

**示例 1：**
**输入：** board = `[["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]`
**输出：** `[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]`

**解释：**
![](https://pic.leetcode.cn/1718167191-XNjUTG-image.png)
在上图中，底部的区域没有被捕获，因为它在 board 的边缘并且不能被围绕。

**示例 2：**
**输入：** board = `[["X"]]`
**输出：**`[["X"]]`

**提示：**
- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 200`
- `board[i][j]` 为 `'X'` 或 `'O'`

> [!abstract]+ 解释
> 被围绕的区间不会存在于边界上，换句话说，任何边界上的 `'O'` 都不会被填充为 `'X'`。 任何不在边界上，或不与边界上的 `'O'` 相连的 `'O'` 最终都会被填充为 `'X'`。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。


## 解题思路


本题的关键在于找出所有不被 `'X'` 围绕的 `'O'` 区域，也就是与边界上的 `'O'` 相连通的 `'O'` 区域，将这些区域标记出来，最后把其余的 `'O'` 区域填充为 `'X'`。我们可以使用深度优先搜索（DFS）算法来实现。

### 具体步骤
1. **边界遍历**：
    - 首先遍历矩阵的四条边界（上下左右）。对于边界上的每个 `'O'` 元素，以它为起点进行深度优先搜索。
    - 因为与边界上的 `'O'` 相连通的 `'O'` 区域不会被 `'X'` 围绕，所以我们要标记这些区域。在 DFS 过程中，将这些 `'O'` 暂时标记为其他字符，这里选择 `'.'`。
2. **深度优先搜索（DFS）**：
    - 在 `dfs` 函数中，将当前位置的 `'O'` 标记为 `'.'`。
    - 然后遍历当前位置的四个相邻位置（上、下、左、右），通过 `dx` 和 `dy` 数组来实现。
    - 对于每个相邻位置，如果它在矩阵范围内且为 `'O'`，则递归调用 `dfs` 函数继续标记。
3. **最终填充**：
    - 遍历整个矩阵，将所有标记为 `'.'` 的位置恢复为 `'O'`，因为这些位置是与边界相连通的 `'O'` 区域。
    - 将所有仍然为 `'O'` 的位置填充为 `'X'`，因为这些位置是被 `'X'` 围绕的区域。

## 代码实现
```cpp
class Solution {
    int m, n;
    // 用于遍历四个方向的偏移量数组
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

public:
    void solve(vector<vector<char>>& board) {
        // 获取矩阵的行数和列数
        m = board.size();
        n = board[0].size();

        // 遍历矩阵的上下边界
        for (int i = 0; i < n; i++) {
            if (board[0][i] == 'O') dfs(board, 0, i);
            if (board[m - 1][i] == 'O') dfs(board, m - 1, i);
        }

        // 遍历矩阵的左右边界
        for (int j = 0; j < m; j++) {
            if (board[j][0] == 'O') dfs(board, j, 0);
            if (board[j][n - 1] == 'O') dfs(board, j, n - 1);
        }

        // 最终填充操作
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (board[i][j] == '.') board[i][j] = 'O';
                else if (board[i][j] == 'O') board[i][j] = 'X';
            }
        }
    }

    void dfs(vector<vector<char>>& board, int i, int j) {
        // 将当前位置的 'O' 标记为 '.'
        board[i][j] = '.';

        // 遍历四个相邻位置
        for (int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            // 检查相邻位置是否在矩阵范围内且为 'O'
            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'O')
                dfs(board, x, y);
        }
    }
};
```

### 复杂度分析
- **时间复杂度**：$O(m\times n)$，其中 $m$ 是矩阵的行数，$n$ 是矩阵的列数。因为我们需要遍历矩阵的边界和整个矩阵，并且每个位置最多被访问一次。
- **空间复杂度**：$O(m\times n)$，主要是递归调用栈的空间开销。在最坏情况下，递归的深度可能达到矩阵的所有位置。

