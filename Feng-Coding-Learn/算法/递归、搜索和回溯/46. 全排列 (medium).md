---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-08 16:33
Finish-date: 
Modified-date: 2025-03-08 16:45
Publish: false
---


# 46. 全排列
[46. 全排列](https://leetcode.cn/problems/permutations/)

## 题目描述
给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。

**示例 1：**
**输入：** nums = `[1,2,3]`
**输出:** `[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`

**示例 2：**
**输入：** nums = `[0,1]`
**输出：**`[[0,1],[1,0]]`

**示例 3：**
**输入：**nums = `[1]`
**输出：** `[[1]]`

**提示：**
- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

## 解题思路

全排列问题要求生成所有不重复的元素排列，每个排列必须包含所有元素且每个元素仅出现一次。例如，对于输入 `[1,2,3]`，所有可能的排列方式为：

```
[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]
```

我们需要通过算法遍历所有可能的排列情况，并高效地保存结果。


#### 方法选择：回溯法

回溯法通过递归逐层构建排列，利用状态标记避免重复使用元素，并通过回溯撤销选择，从而探索所有可能性。核心步骤如下：

1. **路径记录**：动态数组 `path` 保存当前路径。
2. **状态标记**：数组 `used` 记录元素是否已被使用，保证不重复。
3. **深度优先搜索**：递归枚举每个位置的元素，回溯时恢复状态，继续其他分支。



#### 算法流程
1. **初始化状态**
    - `path`：空，表示初始路径。
    - `used`：全 `false`，表示所有元素未使用。
2. **递归遍历选择**
    - **遍历数组元素**：对于每个未使用的元素，将其加入路径。
    - **标记使用状态**：记录元素已被选择。
    - **递归到下一层**：继续处理后续位置的元素。
    - **回溯撤销选择**：恢复元素未被使用的状态，移除路径中的元素。
3. **终止条件**  
    当路径长度等于原数组长度时，保存当前路径到结果集。
    



### 最终代码

```cpp
class Solution {
    vector<int> path;             // 当前路径
    vector<vector<int>> result;   // 结果集合
    bool used[7] = {false};       // 状态标记数组（根据题意n≤6）

public:
    vector<vector<int>> permute(vector<int>& nums) {
        dfs(nums);
        return result;
    }

    void dfs(vector<int>& nums) {
        // 终止条件：路径长度等于数组长度
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }

        // 遍历所有元素
        for (int i = 0; i < nums.size(); i++) {
            if (!used[i]) {                       // 若元素未被使用
                path.push_back(nums[i]);          // 加入当前路径
                used[i] = true;                   // 标记为已使用
                dfs(nums);                        // 递归处理下一层
                used[i] = false;                  // 回溯前恢复状态
                path.pop_back();                  // 移除路径中的元素
            }
        }
    }
};
```


### 代码注释解析
1. **成员变量**
    - `path`：记录当前路径的元素，逐步构建排列。
    - `result`：保存所有合法的排列结果。
    - `used`：根据题意数组长度不超过6，静态数组大小设为7以避免越界。
2. **递归函数 `dfs`**
    
    - **终止条件**：当路径长度等于数组长度时，当前路径为一个合法的排列，将其存入结果。
    - **递归逻辑**：遍历所有元素，跳过已使用元素。选择未使用元素后递归，完成后回溯撤销选择。
3. **状态标记与回溯**
    - **`used[i] = true`**：标记当前元素已使用，防止同一层级重复选择。
    - **代码恢复状态**：递归结束后重置 `used[i]` 并移除路径中的元素，确保回溯到上层时可以正确尝试其他分支。


#### 复杂度分析
- **时间复杂度**：O(n × n!)  
    共有 n! 种排列，每种排列通过 O(n) 次操作生成（递归深度为n）。
- **空间复杂度**：O(n)  
    递归栈深度为 n，存储路径和状态数组的空间为 O(n)。

