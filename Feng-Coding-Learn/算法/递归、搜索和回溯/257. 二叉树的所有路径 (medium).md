---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-08 16:28
Finish-date: 
Modified-date: 2025-03-08 16:45
Publish: false
---


# 257. 二叉树的所有路径
[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

## 题目描述
给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。


**示例 1：**
![](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)
**输入：** root = `[1,2,3,null,5]`
**输出：**`["1->2->5","1->3"]`

**示例 2：**
**输入：** root = `[1]`
**输出： **`["1"]`

**提示：**
- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`

## 解题思路


### 解题思路

**方法：深度优先搜索（DFS）前序遍历**

要获取二叉树所有从根到叶子的路径，可以通过深度优先搜索遍历每个节点，并在遍历过程中记录路径。具体步骤如下：

1. **递归前序遍历**：按照根节点 → 左子树 → 右子树的顺序遍历（前序），确保路径从根开始。
2. **路径构建**：
   - 每访问一个节点，将其值追加到当前路径字符串。
   - 若当前节点是叶子节点（无左右子树），将完整路径加入结果集。
   - 若非叶子节点，在路径后追加 `"->"`，继续递归遍历子节点。
3. **递归终止条件**：遇到叶子节点时终止当前路径的构建。
4. **隐式回溯**：通过字符串的**值传递**特性，自动回退到上一层的路径状态，无需显式删除节点值。


> [!tip]+ **关键点解释**
> - **前序遍历顺序**：根节点最先被访问，符合路径从根到叶子的逻辑。
> - **路径拼接方式**：通过字符串拼接逐步构建路径，非叶子节点后追加 `"->"`。
> - **值传递优化回溯**：每次递归调用传递路径的副本，避免显式回溯操作（如删除已添加的节点值）。

**边界条件处理**：
- **空树**：直接返回空结果集。
- **单节点树**：路径只有根节点自身。


## 代码实现

```cpp
class Solution {
    vector<string> result; // 存储所有路径的结果集

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        string path = "";
        if (root == nullptr) return result; // 空树直接返回空结果
        dfs(root, path);
        return result;
    }

    void dfs(TreeNode* root, string path) {
        // 将当前节点值加入路径
        path += to_string(root->val);

        // 如果是叶子节点，将完整路径加入结果集
        if (!root->left && !root->right) {
            result.push_back(path);
            return;
        }

        // 非叶子节点，追加箭头符号，继续遍历子节点
        path += "->";

        // 递归左子树（如果存在）
        if (root->left) {
            dfs(root->left, path); // 值传递 path，自动回溯
        }
        // 递归右子树（如果存在）
        if (root->right) {
            dfs(root->right, path);
        }
    }
};
```

### 复杂度分析：
- **时间复杂度**：O(n²)，每个节点访问一次，路径字符串操作最坏需要 O(n) 时间（如链表状树）。
- **空间复杂度**：O(n²)，递归栈深度为树的高度 O(h)，结果集存储所有路径需要 O(n²) 空间（例如满二叉树有 n/2 个叶子，每个路径长度为 logn）。
