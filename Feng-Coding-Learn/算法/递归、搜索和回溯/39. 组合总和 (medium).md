---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-12 15:21
Finish-date: 
Modified-date: 2025-03-12 15:29
Publish: false
---


# 39. 组合总和
[39. 组合总和](https://leetcode.cn/problems/combination-sum/)

## 题目描述
给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**
**输入：** candidates = `[2,3,6,7]`, target = `7`
**输出：**`[[2,2,3],[7]]`
**解释：**
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。

**示例 2：**
**输入:** candidates = `[2,3,5]` ,  target = 8
**输出:** `[[2,2,2,2],[2,3,3],[3,5]]`

**示例 3：**

**输入:** candidates = `[2],` target = 1
**输出:** `[]`

**提示：**
- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`

## 解题思路

需要从数组中选取元素（可重复使用）组成和为目标值的组合，且组合不能重复。例如，`[2,2,3]` 和 `[2,3,2]` 被视为同一组合，需去重。

#### 选择回溯法
回溯法通过递归遍历所有可能的组合，通过以下策略保证结果正确性：
1. **元素可重复使用**：递归时允许重复选择当前元素。
2. **去重机制**：按固定顺序遍历数组，避免产生顺序不同但元素相同的组合。
3. **剪枝优化**：当路径和超过目标值时提前终止递归。

#### 关键步骤
1. **递归终止条件**：
   - **成功**：路径和等于目标值，保存结果。
   - **失败**：路径和超过目标值，终止递归。
2. **遍历与选择**：
   - 从当前位置开始遍历数组（允许重复选当前元素）。
   - 将当前元素加入路径，递归处理下一层。
   - 回溯时移除元素，恢复状态。
3. **去重保障**：
   - 始终保持遍历顺序从左到右，避免回头选择已处理过的元素。



> [!info]+ 关键点解释
> 1. **为什么递归传入 `i` 而不是 `i+1`？**
>     - 题目允许重复使用元素，因此递归时仍从 `i` 开始。例如，选择 `2` 后，下一层递归仍然可以选 `2`。
> 2. **如何保证不出现重复组合？**
>     - 通过固定遍历顺序（从 `pos` 开始），保证组合中的元素是非递减的。例如，`[2,2,3]` 是合法的，但 `[3,2,2]` 不会出现，因为遍历到 `3` 时不会回头选 `2`。


## 代码实现

```cpp
class Solution {
    vector<vector<int>> result;  // 存储所有有效组合
    vector<int> path;            // 当前路径
    int sum = 0;                 // 当前路径和

public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        dfs(candidates, 0, target);
        return result;
    }

    void dfs(vector<int>& nums, int pos, int target) {
        // 终止条件1：路径和等于目标值，保存结果
        if (sum == target) {
            result.push_back(path);
            return;
        }
        // 终止条件2：路径和超过目标值，直接返回
        if (sum > target) {
            return;
        }

        // 从pos开始遍历，避免生成重复组合
        for (int i = pos; i < nums.size(); ++i) {
            path.push_back(nums[i]);   // 选择当前元素
            sum += nums[i];            // 更新路径和
            dfs(nums, i, target);      // 递归：允许重复选当前元素
            path.pop_back();           // 回溯：移除当前元素
            sum -= nums[i];            // 回溯：恢复路径和
        }
    }
};
```



### 复杂度分析

- **时间复杂度**：  
  - **最坏情况**：O(N × 2^T)，其中 N 为数组长度，T 为目标值。当所有元素均为1时，递归树深度为T。
  - **剪枝优化后**：实际运行时间远小于理论值。
- **空间复杂度**：O(T)，递归栈深度最大为T（例如组合全为1时）。

