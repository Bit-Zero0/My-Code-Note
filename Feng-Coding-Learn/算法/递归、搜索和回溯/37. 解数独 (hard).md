---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-13 22:33
Finish-date: 
Modified-date: 2025-03-14 16:17
Publish: false
---


# 37. 解数独
[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

## 题目描述
编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1：**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)
**输入：** board = `[["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]`
**输出：**`[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]`
**解释：**输入的数独如上图所示，唯一有效的解决方案如下所示：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714_solutionsvg.png)

**提示：**
- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字或者 `'.'`
- 题目数据 **保证** 输入数独仅有一个解

## 解题思路

建议学本题之间先学习[[36. 有效的数独 (medium)]]。

**解题思路**
**核心思想**：通过回溯法逐格尝试填入数字，利用辅助数组快速检查数字的合法性。

#### 关键步骤
1. **初始化辅助数组**：
   - 遍历数独网格，记录已填入数字的行、列、子网格信息。
2. **回溯搜索**：
   - 遍历每个空格，尝试填入数字 1-9。
   - 若数字合法，递归处理下一个空格。
   - 若所有数字均不合法，回溯撤销选择。
3. **终止条件**：
   - 所有空格填充完毕，返回 `true`。

### 算法流程

对于数独问题，我们需要在空白格中填入数字 `1 - 9`，同时要满足数独的三条规则：每行、每列、每个 `3x3` 宫内数字不重复。  

1. **初始化标记数组**：
    - `checkRow[9][10]`：用于标记每一行中数字 `1 - 9` 是否已经出现。`checkRow[i][num]` 表示第 `i` 行中数字 `num` 是否已经存在。
    - `checkCol[9][10]`：用于标记每一列中数字 `1 - 9` 是否已经出现。`checkCol[j][num]` 表示第 `j` 列中数字 `num` 是否已经存在。
    - `checkGrip[3][3][10]`：用于标记每个 `3x3` 宫内数字 `1 - 9` 是否已经出现。`checkGrip[i / 3][j / 3][num]` 表示第 `(i / 3, j / 3)` 个 `3x3` 宫内数字 `num` 是否已经存在。
2. **遍历棋盘**：
    - 首先遍历整个数独棋盘，将已经存在的数字在相应的标记数组中标记为 `true`。
    - 然后从左上角开始，逐行逐列地寻找空白格（即字符为 `'.'` 的位置）。
3. **尝试填入数字**：
    - 对于每个空白格，尝试填入数字 `1 - 9`。
    - 在填入数字之前，检查该数字是否满足数独的规则，即检查该数字在当前行、当前列和当前 `3x3` 宫内是否已经出现。如果都未出现，则可以填入该数字，并更新相应的标记数组。
    - 递归调用 `dfs` 函数，继续填充下一个空白格。
    - 如果递归调用返回 `true`，表示找到了一个有效的解，直接返回 `true`。
    - 如果递归调用返回 `false`，说明当前填入的数字无法得到有效的解，需要回溯，将该位置恢复为 `'.'`，并更新相应的标记数组。
4. **终止条件**：
    - 当遍历完整个棋盘，没有找到空白格时，说明已经找到了一个有效的解，返回 `true`。
    - 如果在尝试了所有可能的数字后，仍然无法填入有效的数字，返回 `false`。

## 代码实现
```cpp
class Solution {
    bool checkRow[9][10] = {false};    // 检查行重复
    bool checkCol[9][10] = {false};    // 检查列重复
    bool checkGrip[3][3][10] = {false}; // 检查子网格重复

public:
    void solveSudoku(vector<vector<char>>& board) {
        // 初始化辅助数组
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '0';
                    checkRow[i][num] = checkCol[j][num] = checkGrip[i / 3][j / 3][num] = true;
                }
            }
        }
        dfs(board); // 开始回溯搜索
    }

    bool dfs(vector<vector<char>>& board) {
        for (int row = 0; row < 9; ++row) {
            for (int col = 0; col < 9; ++col) {
                if (board[row][col] == '.') {
                    // 尝试填入数字 1～9
                    for (int num = 1; num <= 9; ++num) {
                        // 检查数字是否合法
                        if (!checkRow[row][num] && !checkCol[col][num] && !checkGrip[row / 3][col / 3][num]) {
                            // 填入数字并更新状态
                            board[row][col] = num + '0';
                            checkRow[row][num] = checkCol[col][num] = checkGrip[row / 3][col / 3][num] = true;

                            // 递归处理下一个空格
                            if (dfs(board)) return true;// 关键点

                            // 如果递归返回false，说明当前选择无效，需要回溯
                            board[row][col] = '.';
                            checkRow[row][num] = checkCol[col][num] = checkGrip[row / 3][col / 3][num] = false;
                        }
                    }
                    // 当前空格无法填入任何数字，返回 false
                    return false;
                }
            }
        }
        // 所有空格填充完毕，返回 true
        return true;
    }
};
```

### 代码解释
1. **辅助数组初始化**：
   - `checkRow`、`checkCol`、`checkGrip` 分别记录行、列、子网格中数字是否已出现。
   - 遍历数独网格，初始化辅助数组。

2. **回溯搜索**：
   - **遍历空格**：双重循环找到第一个空格 `(row, col)`。
   - **尝试填入数字**：遍历数字 1～9，检查是否合法。
     - 若合法，填入数字并递归处理下一个空格。
     - 若递归返回 `true`，说明找到解，直接返回。
     - 若递归返回 `false`，说明当前选择不合法，撤销选择并尝试下一个数字。
   - **无法填入**：若当前空格无法填入任何数字，返回 `false`。

3. **终止条件**：
   - 若所有空格均填充完毕，返回 `true`。

### 复杂度分析
- **时间复杂度**：O(9^M)，其中 M 是空格数量。最坏情况下需遍历所有可能的组合。
- **空间复杂度**：O(1)。辅助数组占用固定空间（3x9x10 + 3x3x10 = 360 字节）。


