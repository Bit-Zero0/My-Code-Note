---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-12 15:45
Finish-date: 
Modified-date: 2025-03-12 17:02
Publish: false
---


# 526. 优美的排列
[526. 优美的排列](https://leetcode.cn/problems/beautiful-arrangement/)

## 题目描述
假设有从 1 到 n 的 n 个整数。用这些整数构造一个数组 `perm`（**下标从 1 开始**），只要满足下述条件 **之一** ，该数组就是一个 **优美的排列** ：

- `perm[i]` 能够被 `i` 整除
- `i` 能够被 `perm[i]` 整除

给你一个整数 `n` ，返回可以构造的 **优美排列** 的 **数量** 。

**示例 1：**
**输入：** n = 2
**输出：** 2
**解释：**
```
第 1 个优美的排列是 [1,2]：
    - perm[1] = 1 能被 i = 1 整除
    - perm[2] = 2 能被 i = 2 整除
第 2 个优美的排列是 [2,1]:
    - perm[1] = 2 能被 i = 1 整除
    - i = 2 能被 perm[2] = 1 整除
```

**示例 2：**
**输入：** n = 1
**输出：** 1

**提示：**
- `1 <= n <= 15`

## 解题思路


**核心思想**  
通过深度优先搜索（DFS）遍历所有可能的排列，并在递归过程中通过条件剪枝，提前终止无效分支。

**算法步骤**  
1. **状态定义**  
   - `used[i]`：标记数字 `i` 是否已被使用。  
   - `pos`：当前正在处理的位置（从1开始）。  

2. **递归终止条件**  
   当 `pos == n+1` 时，说明已经生成一个完整排列，计数加1。  

3. **递归逻辑**  
   对于每个位置 `pos`，尝试所有未被使用的数字 `i`：  
   - **剪枝条件**：若 `i` 满足 `pos % i == 0` 或 `i % pos == 0`，则选择该数字。  
   - **递归选择**：标记 `i` 为已使用，递归处理下一个位置 `pos+1`。  
   - **回溯**：恢复 `i` 的未使用状态，尝试其他可能性。  




## 代码实现

```cpp
class Solution {
    bool used[16];  // 记录数字是否被使用（n最大为15）
    int result;     // 统计合法排列数量

public:
    int countArrangement(int n) {
        dfs(1, n);  // 从第1个位置开始递归
        return result;
    }

    void dfs(int pos, int n) {
        // 终止条件：所有位置都已填完，计数加1
        if (pos == n + 1) {
            result++;
            return;
        }

        // 尝试将每个数字i填入当前位置pos
        for (int i = 1; i <= n; i++) {
            // 剪枝：若i未被使用且满足整除条件
            if (!used[i] && (pos % i == 0 || i % pos == 0)) {
                used[i] = true;     // 标记i为已使用
                dfs(pos + 1, n);    // 递归处理下一个位置
                used[i] = false;    // 回溯，恢复i的未使用状态
            }
        }
    }
};
```


### 复杂度分析
- **时间复杂度**：**O(n!)** 最坏情况下需要遍历所有排列，但剪枝条件会显著减少实际递归次数。例如，当 `n=15` 时，理论复杂度为 `15!`，但实际运行时间远小于此值。
- **空间复杂度**：**O(n)** 递归栈深度为 `n`，`used` 数组占用固定空间。





### 动态规划解法
#### 状态表示
**核心洞察**：  
使用二进制位掩码（bitmask）表示已使用的数字集合。每个二进制位对应一个数字是否被使用。

**具体定义**：  
• `dp[mask]`：当数字使用状态为`mask`时，满足条件的排列数目  
• `mask`的二进制表示：第k位为1表示数字k+1已被使用（例如`mask=0b101`表示数字1和3已被使用）

**状态维度**：  
共有2ⁿ种可能状态（每个数字有选/不选两种状态）

#### 状态转移方程
**转移逻辑**：  
对于每个状态`mask`，计算下一个可用位置`pos`，然后尝试放置符合条件的数字：
```
pos = 已选数字数量 + 1
for 所有未使用的数字i:
    if i+1满足pos的整除条件:
        dp[新mask] += dp[旧mask]
```

**数学表达**：  
`dp[mask | (1 << i)] += dp[mask]`  
当且仅当：  
• 数字i+1未被使用（`mask & (1<<i) == 0`）  
• 满足`pos % (i+1) == 0`或`(i+1) % pos == 0`


```cpp
class Solution {
public:
    // 计算美丽排列的数量
    int countArrangement(int n) {
        // dp数组：dp[mask] 表示已选数字对应的位掩码为mask时的合法排列数目
        vector<int> dp(1 << n);
        dp[0] = 1; // 初始状态：未选任何数字时有1种方法

        for (int mask = 0; mask < (1 << n); mask++) {
            // 当前已选数字的个数 + 1 = 下一个要放置的位置
            int pos = __builtin_popcount(mask) + 1;

            // 尝试将每个未选的数字j+1（对应数组索引j）放置到当前位置pos
            for (int i = 0; i < n; i++) {
                // 检查第j位是否未被选中，并且满足位置条件
                if (!(mask & (1 << i)) && (pos % (i + 1) == 0 || (j + 1) % pos == 0)) {
                    // 将当前状态mask的合法数目累加到mask | (1 << j)
                    dp[mask | (1 << i)] += dp[mask];
                }
            }
        }

        // 返回所有数字都被选中时的合法排列数目
        return dp.back();
    }
};
```

#### 代码深度解析
##### 1. 初始化
```cpp
vector<int> dp(1 << n, 0);
dp[0] = 1;
```
• 创建大小为2ⁿ的数组，初始化为0  
• `dp[0] = 1`表示空集合（没有数字被选中）有1种排列方式（作为递归基）

##### 2. 主循环结构
```cpp
for (int mask = 0; mask < (1 << n); ++mask) {
    int pos = __builtin_popcount(mask) + 1;
    // ...后续处理...
}
```
• 按顺序遍历所有可能的数字使用状态  
• `__builtin_popcount(mask)`：GCC内置函数，快速计算二进制中1的个数，即已选数字数量  
• `pos`表示当前需要填充的位置（已选k个数字后，下一个位置是k+1）

##### 3. 候选数字枚举
```cpp
for (int i = 0; i < n; ++i) {
    if (!(mask & (1 << i)) &&  // 检查是否未使用
        (pos % (i+1) == 0 || (i+1) % pos == 0)) {
        // 更新状态
    }
}
```
• 遍历所有n个数字（i对应数字i+1）  
• `mask & (1<<i)`：位运算快速判断数字i+1是否已被使用  
• 双重条件判断是否符合位置要求

#### 4. 状态转移实现
```cpp
dp[mask | (1 << i)] += dp[mask];
```
• `mask | (1 << i)`：将第i位设为1，表示选中数字i+1  
• 将当前状态的方案数累加到新状态



#### 完整状态转移示例（n=3）
让我们通过n=3的案例，观察dp数组的变化：

#### 初始状态
```
dp[0b000] = 1  // 初始空状态
```

#### 处理mask=0（0b000）
• pos = 0+1 = 1  
• 候选数字：1,2,3  
• 检查条件：  
  • 1%1=0 → 有效  
  • 2%1=0 → 有效  
  • 3%1=0 → 有效  

更新：  
```
dp[0b001] += 1  // 选1  
dp[0b010] += 1  // 选2  
dp[0b100] += 1  // 选3  
此时：
dp = [1,1,1,0,1,0,0,0]
```

#### 处理mask=1（0b001）
• pos = 1+1 = 2  
• 已选数字：1  
• 候选数字：2,3  
• 检查条件：  
  • 位置2与数字2：2%2=0 → 有效  
  • 位置2与数字3：3%2≠0且2%3≠0 → 无效  

更新：  
```
dp[0b011] += dp[1] → dp[3] += 1  
此时：
dp = [1,1,1,1,1,0,0,0]
```

#### 处理mask=2（0b010）
• pos = 1+1 = 2  
• 已选数字：2  
• 候选数字：1,3  
• 检查条件：  
  • 位置2与数字1：2%1=0 → 有效  
  • 位置2与数字3：3%2≠0且2%3≠0 → 无效  

更新：  
```
dp[0b011] += dp[2] → dp[3] += 1 → dp[3]=2
```

#### 处理mask=4（0b100）
• pos = 1+1 = 2  
• 已选数字：3  
• 候选数字：1,2  
• 检查条件：  
  • 位置2与数字1：2%1=0 → 有效  
  • 位置2与数字2：2%2=0 → 有效  

更新：  
```
dp[0b101] += 1  // 选1  
dp[0b110] += 1  // 选2  
此时：
dp = [1,1,1,2,1,1,1,0]
```

#### 最终处理mask=3（0b011）
• pos = 2+1 = 3  
• 已选数字：1,2  
• 候选数字：3  
• 检查条件：3%3=0 → 有效  

更新：  
```
dp[0b111] += dp[3] → dp[7] += 2
```

#### 最终结果
```
dp[7] = 3  // 有效排列为[1,2,3], [2,1,3], [3,2,1]
```



#### 复杂度分析
**时间复杂度**
	• **主循环**：遍历2ⁿ个状态 → O(2ⁿ)  
	• **内层循环**：每个状态处理n个候选 → O(n)  
	• **总时间复杂度**：O(n·2ⁿ)  
	当n=15时，计算量为15×32768=491,520次操作，完全可行。

**空间复杂度**
	• **dp数组**：存储2ⁿ个整数 → O(2ⁿ)  
	当n=15时，需要32768×4B≈128KB，非常小。

