---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2024-07-17 22:16
Finish-date: 
Modified-date: 2024-07-18 11:32
Publish: false
---


# 面试题 08.06. 汉诺塔问题
[面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

## 题目描述
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**
```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

**示例2:**
```
 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]

```

**提示:**
A中盘子的数目不大于14个。


## 解题思路
这是一道递归方法的经典题目，我们可以先从最简单的情况考虑：
- 假设 n = 1，只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；
-  如果 n = 2 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 3 步（为了方便叙述，记 A 中的盘子从上到下为 1 号，2 号）：
	1) 1 号盘子放到 B 上；
	2) 2 号盘子放到 C 上；
	3) 1 号盘子放到 C 上。
至此，C 中的盘子从上到下为 1 号， 2 号。

• 如果 n > 2 呢？这是我们需要用到 n = 2 时的策略，将 A 上面的两个盘子挪到 B 上，再将最大的盘子挪到 C 上，最后将 B 上的小盘子挪到 C 上就完成了所有步骤。例如 `n = 3` 时如下图：
![[面试题 08.06. 汉诺塔问题.excalidraw]]
因为 A 中最后处理的是最大的盘子，所以在移动过程中不存在大盘子在小盘子上面的情况。
则本题可以被解释为：
1. 对于规模为 n 的问题，我们需要将 A 柱上的 n 个盘子移动到C柱上。
2. 规模为 n 的问题可以被拆分为规模为 `n-1` 的子问题：
	1) 将 A 柱上的上面 `n-1` 个盘子移动到B柱上。
	2) 将 A 柱上的最大盘子移动到 C 柱上，然后将 B 柱上的 n-1 个盘子移动到C柱上。
3. 当问题的规模变为 `n=1` 时，即只有一个盘子时，我们可以直接将其从 A 柱移动到 C 柱。
- 需要注意的是，步骤2.  b 考虑的是总体问题中的 子问题b 情况。在处理子问题的 子问题b 时，我们应该将 A 柱中的最上面的盘子移动到 C 柱，然后再将 B 柱上的盘子移动到 C 柱。在处理总体问题的 子问题b 时，A 柱中的最大盘子仍然是最上面的盘子，因此这种做法是通用的。


### 算法流程
递归函数设计：`void hanotaa(vector<int>& A, vector<int>& B, vector<int>& C, int n)`
1. 返回值：无；
2. 参数：三个柱子上的盘子，当前需要处理的盘子个数（当前问题规模）。
3. 函数作用：将 A 中的上面 n 个盘子挪到 C 中。

递归函数流程：
1. 当前问题规模为 `n=1` 时，直接将 A 中的最上面盘子挪到 C 中并返回；
2. 递归将 A 中最上面的 `n-1` 个盘子挪到 B 中；
3. 将 A 中最上面的一个盘子挪到 C 中；
4. 将 B 中上面 n-1 个盘子挪到 C 中。

## C++代码
```c
class Solution {
public:
    void dfs(vector<int>& a, vector<int>& b, vector<int>& c , int n)
    {
        if(n == 1)
        {
            c.push_back(a.back());
            a.pop_back();
            return ;
        }

        dfs( a , c , b , n - 1);
        c.push_back(a.back());
        a.pop_back();
        dfs( b , a , c , n - 1);
    }

    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        dfs(A, B ,C , A.size());
    }

};
```
