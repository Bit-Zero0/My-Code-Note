---
Type: Note
tags:
  - 算法
  - medium
  - 递归
  - FLoodFill算法
Status: writing
Start-date: 2025-03-16 18:48
Finish-date: 
Modified-date: 2025-03-16 18:53
Publish: false
---


# 529. 扫雷游戏
[529. 扫雷游戏](https://leetcode.cn/problems/minesweeper/)

## 题目描述
让我们一起来玩扫雷游戏！

给你一个大小为 `m x n` 二维字符矩阵 `board` ，表示扫雷游戏的盘面，其中：

- `'M'` 代表一个 **未挖出的** 地雷，
- `'E'` 代表一个 **未挖出的** 空方块，
- `'B'` 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的 **已挖出的** 空白方块，
- **数字**（`'1'` 到 `'8'`）表示有多少地雷与这块 **已挖出的** 方块相邻，
- `'X'` 则表示一个 **已挖出的** 地雷。

给你一个整数数组 `click` ，其中 `click = [clickr, clickc]` 表示在所有 **未挖出的** 方块（`'M'` 或者 `'E'`）中的下一个点击位置（`clickr` 是行下标，`clickc` 是列下标）。

根据以下规则，返回相应位置被点击后对应的盘面：
1. 如果一个地雷（`'M'`）被挖出，游戏就结束了- 把它改为 `'X'` 。
2. 如果一个 **没有相邻地雷** 的空方块（`'E'`）被挖出，修改它为（`'B'`），并且所有和其相邻的 **未挖出** 方块都应该被递归地揭露。
3. 如果一个 **至少与一个地雷相邻** 的空方块（`'E'`）被挖出，修改它为数字（`'1'` 到 `'8'` ），表示相邻地雷的数量。
4. 如果在此次点击中，若无更多方块可被揭露，则返回盘面。

**示例 1：**
![](https://assets.leetcode.com/uploads/2023/08/09/untitled.jpeg)
**输入：** board = `[["E","E","E","E","E"],["E","E","M","E","E"],["E","E","E","E","E"],["E","E","E","E","E"]]`, click = [3,0]
**输出：**`[["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]`

**示例 2：**
![](https://assets.leetcode.com/uploads/2023/08/09/untitled-2.jpeg)
**输入：** board = `[["B","1","E","1","B"],["B","1","M","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]`, click = [1,2]
**输出：**`[["B","1","E","1","B"],["B","1","X","1","B"],["B","1","1","1","B"],["B","B","B","B","B"]]`

**提示：**
- `m == board.length`
- `n == board[i].length`
- `1 <= m, n <= 50`
- `board[i][j]` 为 `'M'`、`'E'`、`'B'` 或数字 `'1'` 到 `'8'` 中的一个
- `click.length == 2`
- `0 <= click_r < m`
- `0 <= click_c < n`
- `board[click_r][click_c]` 为 `'M'` 或 `'E'`


> [!abstract]+ 题目简述
> 给定一个扫雷的初始状态，玩家点击了一个位置，根据规则更新整个棋盘。规则如下：
> - 如果点击的位置是地雷（`'M'`），则该位置变为`'X'`，游戏结束。
> - 如果点击的位置是未被挖掘的空方块（`'E'`），则：
>     - 若该方块周围有地雷，显示地雷数量。
>     - 若周围没有地雷，递归展开周围所有未被挖掘的空方块。

## 解题思路

本题可以通过深度优先搜索（DFS）算法实现。核心思想是从点击的位置开始，递归展开周围未被挖掘的空方块，并根据周围地雷数量更新棋盘状态。

### 具体步骤
1. **处理点击位置**：
    - 如果点击的位置是地雷（`'M'`），直接将其标记为`'X'`并返回。
2. **深度优先搜索（DFS）**：
    - 计算当前位置周围 8 个方向的地雷数量。
    - 如果地雷数量大于 0，将当前位置设置为对应的数字，停止递归。
    - 如果地雷数量为 0，将当前位置设置为`'B'`，并递归处理周围所有未被挖掘的空方块（`'E'`）。

> [!tip]+ 关键点
> - **方向遍历**：使用 8 个方向的偏移量数组`dx`和`dy`遍历周围方块。
> - **终止条件**：当当前位置周围有地雷时，停止递归，避免不必要的计算。


## 代码实现
```cpp
class Solution {
    int m, n;
    // 8个方向的偏移量数组
    int dx[8] = {1, -1, 0, 0, 1, -1, 1, -1};
    int dy[8] = {0, 0, 1, -1, -1, 1, 1, -1};

public:
    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click) {
        m = board.size();
        n = board[0].size();
        int x = click[0], y = click[1];

        // 点击地雷，直接标记为 'X' 并返回
        if (board[x][y] == 'M') {
            board[x][y] = 'X';
            return board;
        }

        // 从点击位置开始深度优先搜索
        dfs(board, x, y);
        return board;
    }

    void dfs(vector<vector<char>>& board, int i, int j) {
        // 计算当前块周围的地雷数量
        int count = 0;
        for (int k = 0; k < 8; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'M') {
                count++;
            }
        }

        if (count > 0) {
            // 周围有地雷，显示数量
            board[i][j] = count + '0';
        } else {
            // 周围无地雷，标记为 'B' 并递归展开相邻的空方块
            board[i][j] = 'B';
            for (int k = 0; k < 8; k++) {
                int x = i + dx[k];
                int y = j + dy[k];
                // 仅处理未翻开的空方块 'E'
                if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'E') {
                    dfs(board, x, y);
                }
            }
        }
    }
};
```


### 复杂度分析
- **时间复杂度**：O(m×n)，其中 m 和 n 分别是棋盘的行数和列数。每个位置最多被访问一次。
- **空间复杂度**：O(m×n)，主要用于递归调用栈的空间。