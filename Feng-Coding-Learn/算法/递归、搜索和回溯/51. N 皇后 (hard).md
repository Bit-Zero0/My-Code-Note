---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-03-13 21:46
Finish-date: 
Modified-date: 2025-03-13 22:24
Publish: false
---


# 51. N 皇后
[51. N 皇后](https://leetcode.cn/problems/n-queens/)

## 题目描述
按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**
![](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)
**输入：** n = 4
**输出：** `[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]`
**解释：** 如上图所示，4 皇后问题存在两个不同的解法。

**示例 2：**
**输入：** n = 1
**输出：** `[["Q"]]`

**提示：**
- `1 <= n <= 9`

## 解题思路

本题是经典的回溯算法问题，回溯算法本质上是一种深度优先搜索算法，通过尝试所有可能的解决方案来找到满足特定条件的解。在解决 N 皇后问题时，我们需要将 N 个皇后放置在 N×N 的棋盘上，使得任意两个皇后都不能处于同一行、同一列或同一斜线上。

**核心思路**
我们可以逐行放置皇后，因为每行只能放置一个皇后，这样可以避免行冲突。对于每一行，我们尝试在每一列放置皇后，并检查该位置是否会与之前已经放置的皇后产生冲突。如果不冲突，则继续在下一行放置皇后；如果冲突，则尝试下一列。当我们成功放置了 N 个皇后时，就找到了一个有效的解决方案。


### 方法选择：回溯法 + 剪枝
通过逐行放置皇后，每次选择一列并标记冲突，递归探索所有可能的分支。若当前位置合法则继续，否则回溯。

#### **核心步骤**  
1. **初始化棋盘和标记数组**  
   - **棋盘**：初始化为全 `.` 的网格，表示空位。
   - **列标记**：记录每列是否被占用。
   - **主对角线标记**：通过 `row - col + n` 计算唯一索引，避免负数。
   - **副对角线标记**：通过 `row + col` 计算唯一索引。

2. **递归与回溯**  
   - **逐行处理**：从第 `0` 行开始，每行尝试所有列。
   - **冲突检查**：检查当前列、主对角线、副对角线是否已被占用。
   - **放置皇后**：标记当前位置为 `Q`，并更新冲突标记。
   - **递归下一行**：进入下一行继续放置。
   - **回溯恢复**：撤销当前选择，恢复棋盘和标记状态。

3. **终止条件**  
   - 所有行处理完毕时，保存当前棋盘状态到结果集。

### 具体步骤
1. **初始化数据结构**：
    - `checkCol`：长度为 `n` 的布尔数组，用于标记每一列是否已经有皇后。
    - `checkDiagonal` 和 `checkBackDiagonal`：长度为 `2 * n` 的布尔数组，分别用于标记主对角线和副对角线是否已经有皇后。
    - `path`：长度为 `n` 的字符串数组，用于表示当前的棋盘状态，初始时每个位置都为 `'.'`。
    - `result`：二维字符串数组，用于存储所有有效的解决方案。
    - `_n`：记录皇后的数量。
2. **逐行放置皇后**：
    - 从第 0 行开始，逐行尝试在每一列放置皇后。
    - 对于当前行的每一列，检查该位置是否会与之前已经放置的皇后产生冲突。具体来说，需要检查该列、主对角线和副对角线是否已经有皇后。
    - 如果不冲突，则将皇后放置在该位置，并更新相应的标记数组。
    - 递归调用 `dfs` 函数，继续在下一行放置皇后。
    - 回溯：将该位置恢复为 `'.'`，并更新相应的标记数组，尝试下一列。
3. **终止条件**：
    - 当 `row == n` 时，表示已经成功放置了 N 个皇后，将当前的棋盘状态 `path` 加入到结果数组 `result` 中。


## 代码实现
```cpp
class Solution {
    vector<bool> checkCol, checkDiagonal, checkBackDiagonal; // 列、主对角线、副对角线标记
    vector<string> path;      // 当前棋盘状态
    vector<vector<string>> result; // 所有合法解
    int _n;                   // 棋盘大小n

public:
    vector<vector<string>> solveNQueens(int n) {
        path.resize(n);        // 初始化棋盘为n行
        for (int i = 0; i < n; i++) {
            path[i].append(n, '.'); // 每行初始化为n个'.'
        }
        // 初始化标记数组
        checkCol.resize(n, false);
        checkDiagonal.resize(2 * n, false); // 主对角线索引范围：0到2n-1
        checkBackDiagonal.resize(2 * n, false); // 副对角线索引范围：0到2n-1
        _n = n;
        dfs(0);               // 从第0行开始递归
        return result;
    }

    void dfs(int row) {
        if (row == _n) {      // 所有行处理完毕，保存解
            result.push_back(path);
            return;
        }
        for (int col = 0; col < _n; col++) {
            // 检查当前列、主对角线、副对角线是否可用
            if (!checkCol[col] && !checkDiagonal[row - col + _n] && !checkBackDiagonal[row + col]) {
                path[row][col] = 'Q'; // 放置皇后
                checkCol[col] = checkDiagonal[row - col + _n] = checkBackDiagonal[row + col] = true; // 标记占用
                dfs(row + 1);  // 处理下一行
                path[row][col] = '.'; // 回溯：移除皇后
                checkCol[col] = checkDiagonal[row - col + _n] = checkBackDiagonal[row + col] = false; // 取消标记
            }
        }
    }
};
```



### **关键逻辑解析**
1. **冲突检测**  
   - **列冲突**：`checkCol[col]` 为 `false`。
   - **主对角线冲突**：同一主对角线上所有点满足 `row - col = 常数`，通过 `row - col + n` 转换为非负索引。
   - **副对角线冲突**：同一副对角线上所有点满足 `row + col = 常数`。

2. **标记数组的作用**  
   - **列标记**：确保每列只有一个皇后。
   - **主对角线标记**：确保左上到右下的对角线唯一。
   - **副对角线标记**：确保右上到左下的对角线唯一。

3. **回溯与恢复**  
   - 每次递归后，撤销当前行的皇后放置，恢复标记状态，确保其他分支的正确性。



### **复杂度分析**
- **时间复杂度**：**O(n!)**  
  每行有 `n` 种选择，但剪枝减少了实际分支数。例如，第 `i` 行最多有 `n - i` 种选择。
- **空间复杂度**：**O(n)**  
  标记数组和递归栈的空间占用为线性。

