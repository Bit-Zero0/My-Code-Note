---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-14 16:48
Finish-date: 
Modified-date: 2025-03-14 17:20
Publish: false
---


# 1219. 黄金矿工
[1219. 黄金矿工](https://leetcode.cn/problems/path-with-maximum-gold/)

## 题目描述
你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 `m * n` 的网格 `grid` 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 `0`。

为了使收益最大化，矿工需要按以下规则来开采黄金：
- 每当矿工进入一个单元，就会收集该单元格中的所有黄金。
- 矿工每次可以从当前位置向上下左右四个方向走。
- 每个单元格只能被开采（进入）一次。
- **不得开采**（进入）黄金数目为 `0` 的单元格。
- 矿工可以从网格中 **任意一个** 有黄金的单元格出发或者是停止。

**示例 1：**
**输入：** grid = `[[0,6,0],[5,8,7],[0,9,0]]`
**输出：** 24
**解释：**
```
[[0,6,0],
 [5,8,7],
 [0,9,0]]
```
一种收集最多黄金的路线是：9 -> 8 -> 7。

**示例 2：**
**输入：** grid = `[[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]`
**输出：**28
**解释：**
```
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
```
一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。

**提示：**
- `1 <= grid.length, grid[i].length <= 15`
- `0 <= grid[i][j] <= 100`
- 最多 **25** 个单元格中有黄金。

## 解题思路

本题要求在一个二维网格中找到一条路径，使得路径上的黄金数量总和最大，且每个单元格只能访问一次，网格中值为 0 的单元格不能进入。我们可以使用回溯算法来解决这个问题。回溯算法本质上是一种深度优先搜索算法，它会尝试所有可能的路径，并在搜索过程中记录下最大的黄金数量。

#### 具体步骤
1. **初始化**：
    - 获取网格的行数 `m` 和列数 `n`。
    - 初始化最大黄金数量 `result` 为 0。
    - 初始化 `used` 数组，用于标记每个单元格是否已经被访问过。
2. **遍历网格**：
    - 使用两层嵌套的 `for` 循环遍历整个网格。
    - 对于每个非零单元格，将其标记为已访问，并从该单元格开始进行深度优先搜索（DFS）。
    - 在 DFS 结束后，将该单元格标记为未访问，以便后续尝试其他路径。
3. **深度优先搜索（DFS）**：
    - 在 `dfs` 函数中，首先更新最大黄金数量 `result`，取当前路径的黄金数量 `path` 和 `result` 中的较大值。
    - 然后遍历当前单元格的四个相邻单元格（上、下、左、右）。
    - 对于每个相邻单元格，检查其是否在网格范围内、未被访问过且值不为 0。
    - 如果满足条件，将该相邻单元格标记为已访问，并递归调用 `dfs` 函数，更新路径的黄金数量。
    - 在递归调用返回后，将该相邻单元格标记为未访问，以便尝试其他路径。

> [!tip]+ 关键步骤
> 1. **初始化**：遍历网格，找到所有可能的起点（非零单元格）。
> 2. **DFS搜索**：从起点出发，递归探索四个方向，累加黄金量。
> 3. **回溯与状态恢复**：撤销当前位置的访问标记，尝试其他路径。
> 4. **终止条件**：当无法继续移动时，更新最大值。

## 代码实现

```cpp
class Solution {
    int m, n;
    int path;
    int result;
    bool used[16][16];
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

public:
    int getMaximumGold(vector<vector<int>>& grid) {
        m = grid.size();
        n = grid[0].size();
        result = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] != 0) {
                    used[i][j] = true;
                    dfs(grid, i, j, grid[i][j]);
                    used[i][j] = false;
                }
            }
        }
        return result;
    }

    void dfs(vector<vector<int>>& grid, int i, int j, int path) {
        result = max(path, result);

        for (int k = 0; k < 4; k++) {
            int x = i + dx[k];
            int y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && !used[x][y] && grid[x][y]) {
                used[x][y] = true;
                dfs(grid, x, y, path + grid[x][y]);
                used[x][y] = false;
            }
        }
    }
};
```


### 复杂度分析
- **时间复杂度**：$O(m \times n \times 3^{m \times n})$。对于每个非零单元格，我们最多有 3 个方向可以继续搜索（因为不能回到上一个单元格），所以总的时间复杂度为 $O(m \times n \times 3^{m \times n})$。
- **空间复杂度**：$O(m \times n)$。主要用于递归调用栈和 `used` 数组的空间。递归调用栈的深度最大为 $m \times n$，而 `used` 数组的大小为 $m \times n$，因此空间复杂度为 $O(m \times n)$。
