---
Type: Note
tags:
  - 算法
  - easy
Status: writing
Start-date: 2024-07-17 22:16
Finish-date: 
Modified-date: 2025-02-24 11:14
Publish: false
---


# 面试题 08.06. 汉诺塔问题
[面试题 08.06. 汉诺塔问题](https://leetcode.cn/problems/hanota-lcci/)

## 题目描述
在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**
```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

**示例2:**
```
 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]

```

**提示:**
A中盘子的数目不大于14个。


## 解题思路
这是一道递归方法的经典题目，我们可以先从最简单的情况考虑：
- 假设 n = 1，只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；
-  如果 n = 2 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 3 步（为了方便叙述，记 A 中的盘子从上到下为 1 号，2 号）：
	1) 1 号盘子放到 B 上；
	2) 2 号盘子放到 C 上；
	3) 1 号盘子放到 C 上。
至此，C 中的盘子从上到下为 1 号， 2 号。

• 如果 n > 2 呢？这是我们需要用到 n = 2 时的策略，将 A 上面的两个盘子挪到 B 上，再将最大的盘子挪到 C 上，最后将 B 上的小盘子挪到 C 上就完成了所有步骤。例如 `n = 3` 时如下图：
![[面试题 08.06. 汉诺塔问题.excalidraw]]
因为 A 中最后处理的是最大的盘子，所以在移动过程中不存在大盘子在小盘子上面的情况。
则本题可以被解释为：
1. 对于规模为 n 的问题，我们需要将 A 柱上的 n 个盘子移动到C柱上。
2. 规模为 n 的问题可以被拆分为规模为 `n-1` 的子问题：
	1) **将 A 柱上的上面 `n-1` 个盘子移动到B柱上**。
	2) **将 A 柱上的最大盘子移动到 C 柱上，然后将 B 柱上的 n-1 个盘子移动到C柱上**。
3. 当问题的规模变为 `n=1` 时，即只有一个盘子时，我们可以直接将其从 A 柱移动到 C 柱。
- 需要注意的是，步骤2.  b 考虑的是总体问题中的 子问题b 情况。在处理子问题的 子问题b 时，我们应该将 A 柱中的最上面的盘子移动到 C 柱，然后再将 B 柱上的盘子移动到 C 柱。在处理总体问题的 子问题b 时，A 柱中的最大盘子仍然是最上面的盘子，因此这种做法是通用的。


### 算法流程
递归函数设计：`void hanotaa(vector<int>& A, vector<int>& B, vector<int>& C, int n)`
1. 返回值：无；
2. 参数：三个柱子上的盘子，当前需要处理的盘子个数（当前问题规模）。
3. 函数作用：将 A 中的上面 n 个盘子挪到 C 中。


**递归步骤分解**
1. 1.**移动n-1个盘子到中间柱**：将A柱顶部的n-1个盘子借助C柱移动到B柱。此时，B柱作为目标柱，C柱作为辅助柱。
2. 2.**移动最底层盘子到目标柱**：将A柱剩下的最后一个（最大的）盘子直接移动到C柱。
3. 3.**移动n-1个盘子到目标柱**：将B柱上的n-1个盘子借助A柱移动到C柱。此时，A柱作为辅助柱，C柱作为目标柱。

**参数变化说明**  
递归过程中，每次调用函数时参数顺序会动态调整，以正确指定源柱、辅助柱和目标柱。例如：
- 第一次递归调用时，参数为`(A, C, B)`，表示将A的n-1个盘子通过C移动到B。
- 第二次递归调用时，参数为`(B, A, C)`，表示将B的n-1个盘子通过A移动到C。



## C++代码
```c
class Solution {
public:
    // 递归函数：将n个盘子从a柱移动到c柱，借助b柱
    void moveDisks(vector<int>& a, vector<int>& b, vector<int>& c, int n) {
        if (n == 1) { // 递归终止条件：仅剩一个盘子时直接移动
            c.push_back(a.back());
            a.pop_back();
            return;
        }
        // 步骤1：将n-1个盘子从a移动到b（借助c作为辅助）
        moveDisks(a, c, b, n - 1);
        // 步骤2：将a剩下的最大盘子移动到c
        c.push_back(a.back());
        a.pop_back();
        // 步骤3：将n-1个盘子从b移动到c（借助a作为辅助）
        moveDisks(b, a, c, n - 1);
    }

    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        moveDisks(A, B, C, A.size());
    }
};
```


### 复杂度分析
1. **时间复杂度**：
    - **O(2ⁿ)**：每个盘子需要两次递归操作，总移动次数为2ⁿ -1，n为盘子数。
2. **空间复杂度**：
    - **O(n)**：递归调用栈的深度为n，最坏情况下需要n层递归。




### 迭代解法

使用栈数据结构模拟递归调用栈，将每个待处理的汉诺塔任务（包含盘子数、源柱、辅助柱、目标柱）压入栈中。通过循环处理栈顶任务，分解为更小的子任务，直到所有盘子移动完成。

```cpp
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    void hanota(vector<int>& A, vector<int>& B, vector<int>& C) {
        struct Task {
            int n;          // 当前需移动的盘子数
            vector<int>& src; // 源柱子
            vector<int>& aux; // 辅助柱子
            vector<int>& dst; // 目标柱子
            Task(int n, vector<int>& s, vector<int>& a, vector<int>& d)
                : n(n), src(s), aux(a), dst(d) {}
        };

        stack<Task> task_stack;
        task_stack.push(Task(A.size(), A, B, C)); // 初始任务：移动A全部到C

        while (!task_stack.empty()) {
            Task task = task_stack.top();
            task_stack.pop();

            if (task.n == 1) { // 基础情况：直接移动一个盘子
                task.dst.push_back(task.src.back());
                task.src.pop_back();
            } else {
                // 分解为三个子任务，按逆序压入栈（保证执行顺序正确）
                // 子任务3：移动n-1从aux到dst（借助src）
                task_stack.push(Task(task.n - 1, task.aux, task.src, task.dst));
                // 子任务2：移动第n个盘子从src到dst
                task_stack.push(Task(1, task.src, task.aux, task.dst));
                // 子任务1：移动n-1从src到aux（借助dst）
                task_stack.push(Task(task.n - 1, task.src, task.dst, task.aux));
            }
        }
    }
};
```


#### 算法流程解析
1. **任务定义**：每个任务包含四个属性：
   - `n`：需移动的盘子数
   - `src`：源柱子（移动起点）
   - `aux`：辅助柱子（中转）
   - `dst`：目标柱子（移动终点）

2. **初始任务**：将A柱上的所有盘子移动到C柱，初始任务为 `(n=A.size(), src=A, aux=B, dst=C)`。

3. **任务分解**：
   - **任务n**：移动n个盘子从src到dst（借助aux）
     - **分解顺序**（逆序压栈）：
       1. **子任务1**：移动n-1个盘子从src到aux（此时aux成为新目标，dst成为辅助）
       2. **子任务2**：移动第n个盘子（最大的一个）从src到dst
       3. **子任务3**：移动n-1个盘子从aux到dst（此时src成为辅助）

4. **执行顺序**：
   - 由于栈的后进先出特性，实际执行顺序为：
     1. 子任务1：移动n-1到aux
     2. 子任务2：移动第n个到dst
     3. 子任务3：移动n-1到dst



### 复杂度分析
| 操作       | 时间复杂度 | 空间复杂度 |
|------------|------------|------------|
| 移动次数    | O(2ⁿ)      | O(n)       |
| 栈操作      | O(2ⁿ)      | O(n)       |



#### 示例推演（n=3）
```text
初始状态：
A = [3,2,1], B = [], C = []

任务栈演变：
1. 压入任务(3, A, B, C)
   → 弹出任务3，分解为：
     - 压入任务3.3 (2, B, A, C)
     - 压入任务3.2 (1, A, B, C)
     - 压入任务3.1 (2, A, C, B)
   
2. 弹出任务3.1 (2, A, C, B)
   → 分解为：
     - 压入任务3.1.3 (1, C, A, B)
     - 压入任务3.1.2 (1, A, C, B)
     - 压入任务3.1.1 (1, A, B, C)
   
3. 执行基础任务（n=1）：
   → 移动1到B，A变为[3,2], B=[1]
   → 移动2到C，A变为[3], C=[2]
   → 移动1到C，B=[], C=[2,1]
   
...（后续步骤类似，最终C得到[3,2,1]）
```

---

### 方法对比
| 方法   | 优势                     | 劣势                     |
|--------|--------------------------|--------------------------|
| 递归   | 代码简洁，逻辑清晰        | 栈深度受限，可能溢出       |
| 迭代   | 避免栈溢出，更易控制流程   | 代码复杂度较高            |

通过显式栈模拟递归流程，迭代方法在保持逻辑正确性的同时，适用于大规模数据场景，有效避免递归深度限制。