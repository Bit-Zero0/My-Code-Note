---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-15 14:20
Finish-date: 
Modified-date: 2025-03-15 14:43
Publish: false
---


# 200. 岛屿数量
[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)

## 题目描述
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1：**
**输入：** grid = 
```
[["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]]
```
**输出：** 1

**示例 2：**
**输入：** grid = 
```
[["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]]
```
**输出：** 3

**提示：**
- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`

## 解题思路

本题的目标是计算给定二维网格中岛屿的数量。岛屿是由相邻的陆地（用 `'1'` 表示）连接而成的，水（用 `'0'` 表示）将不同的岛屿分隔开。我们可以使用深度优先搜索（DFS）算法来解决这个问题，其核心思想是遍历整个网格，当遇到未被访问过的陆地时，将其作为一个新岛屿的起始点，通过 DFS 标记该岛屿的所有陆地，从而统计出岛屿的数量。

1. **遍历网格**：逐个检查每个单元格，若为未被访问过的陆地（`'1'`），则启动DFS。
2. **DFS标记连通区域**：从当前陆地出发，递归访问上下左右四个方向的相邻单元格，标记所有相连的陆地为已访问。
3. **计数岛屿**：每次启动DFS时，岛屿数量加一。

### 关键步骤
1. **初始化**：创建二维数组 `checked` 记录访问状态。
2. **双重循环遍历**：对每个单元格，若为未访问的陆地，触发DFS。
3. **DFS递归**：
    - 标记当前单元格为已访问。
    - 递归处理四个方向的相邻单元格，确保不越界且为未访问的陆地。


### 具体步骤
1. **初始化**：
    - 获取网格的行数 `m` 和列数 `n`。
    - 初始化一个二维布尔数组 `checked`，用于标记每个位置是否已经被访问过，初始值都为 `false`。
    - 初始化岛屿数量 `result` 为 0。
2. **遍历网格**：
    - 使用两层嵌套的 `for` 循环遍历整个网格。
    - 对于每个位置 `(i, j)`，检查其是否未被访问过且是陆地（即 `!checked[i][j] && grid[i][j] == '1'`）。
    - 如果满足条件，说明发现了一个新的岛屿，将 `result` 加 1，并从该位置开始进行深度优先搜索。
3. **深度优先搜索（DFS）**：
    - 在 `dfs` 函数中，首先将当前位置 `(i, j)` 标记为已访问（`checked[i][j] = true`）。
    - 遍历当前位置的四个相邻位置（上、下、左、右），通过 `dx` 和 `dy` 数组来实现。
    - 对于每个相邻位置 `(x, y)`，检查其是否在网格范围内（`x >= 0 && x < m && y >= 0 && y < n`）、未被访问过（`!checked[x][y]`）且是陆地（`grid[x][y] == '1'`）。
    - 如果满足条件，递归调用 `dfs` 函数，继续标记该岛屿的其他陆地。


## 代码实现
```cpp
class Solution {
    int m, n;                   // 网格的行数和列数
    int result = 0;              // 岛屿数量
    vector<vector<bool>> checked; // 标记已访问的单元格
    int dx[4] = {0, 0, 1, -1};   // 右、左、下、上
    int dy[4] = {1, -1, 0, 0};

public:
    int numIslands(vector<vector<char>>& grid) {
        m = grid.size();
        if (m == 0) return 0;
        n = grid[0].size();
        checked.resize(m, vector<bool>(n, false)); // 正确初始化
        result = 0; // 显式初始化计数器

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (!checked[i][j] && grid[i][j] == '1') {
                    result++; // 发现新岛屿
                    dfs(grid, i, j);
                }
            }
        }
        return result;
    }

    void dfs(vector<vector<char>>& grid, int i, int j) {
        checked[i][j] = true; // 标记当前为已访问
        for (int k = 0; k < 4; ++k) {
            int x = i + dx[k], y = j + dy[k];
            if (x >= 0 && x < m && y >= 0 && y < n && !checked[x][y] && grid[x][y] == '1') {
                dfs(grid, x, y); // 递归处理相邻陆地
            }
        }
    }
};
```
