---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-04 20:49
Finish-date: 
Modified-date: 2025-03-04 20:57
Publish: false
---


# 50. Pow(x, n)
[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)

## 题目描述
实现 [pow(_x_, _n_)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

**示例 1：**
**输入：** x = 2.00000, n = 10
**输出：** 1024.00000

**示例 2：**
**输入：** x = 2.10000, n = 3
**输出：** 9.26100

**示例 3：**
**输入：**x = 2.00000, n = -2
**输出：**0.25000
**解释：**2-2 = 1/22 = 1/4 = 0.25

**提示：**
- `-100.0 < x < 100.0`
- `-2^31 <= n <= 2^31 - 1`
- `n` 是一个整数
- 要么 `x` 不为零，要么 `n > 0` 。
- `-10^4 <= xn <= 10^4`

## 解题思路（快速幂算法）

实现计算 x 的 n 次幂函数，要求时间复杂度控制在 O(log n)。需要考虑以下关键点：

1. **指数为负数**：需转换为计算倒数
2. **大数计算**：避免直接暴力相乘导致的超时问题
3. **边界条件**：处理 n = 0 和 x = 0 的特殊情况
4. **整数溢出**：当 n = -2^31 时，直接取反会导致溢出


通过将指数分解为二进制形式，利用幂的平方性质将时间复杂度从 O(n) 优化到 O(log n)：
- $x^n = x^(n/2) * x^(n/2)$ （当 n 为偶数）
- $x^n = x^(n/2) * x^(n/2) * x$ （当 n 为奇数）

> [!tip]+ 关键点
> 1. **处理负数指数**：转化为计算倒数，注意处理整数溢出边界
> 2. **递归分解指数**：每次将指数折半，递归计算子问题
> 3. **合并结果**：根据指数奇偶性平方或平方后乘基数
> 4. **终止条件**：指数为 0 时返回 1（数学定义）


### 代码实现
```cpp
class Solution {
public:
    double myPow(double x, int n) {
        // 处理负指数：转换为计算倒数，使用long long避免INT_MIN取反溢出
        if(n < 0) return 1.0 / pow(x, -(long long)n);
        return pow(x, n);
    }

private:
    double pow(double x, long long n) {
        // 递归终止条件：任何数的0次方为1
        if(n == 0) return 1.0;

        // 分治：计算x的n/2次方
        double temp = pow(x, n / 2);
        
        // 合并结果：根据奇偶性处理
        return (n % 2 == 0) ? 
            temp * temp :          // 偶数情况：平方
            temp * temp * x;       // 奇数情况：平方后多乘一次基数
    }
};
```

### 复杂度分析
- 时间复杂度：O(log n) 每次递归指数减半
- 空间复杂度：O(log n) 递归调用栈深度


