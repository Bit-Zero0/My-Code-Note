---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-04 22:15
Finish-date: 
Modified-date: 2025-03-08 16:44
Publish: false
---


# 129. 求根节点到叶节点数字之和
[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

## 题目描述
给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：
- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

**示例 1：**
![](https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg)
**输入：** root = `[1,2,3]`
**输出：** 25
**解释：**
从根到叶子节点路径 `1->2` 代表数字 `12`
从根到叶子节点路径 `1->3` 代表数字 `13`
因此，数字总和 = 12 + 13 = `25`

**示例 2：**
![](https://assets.leetcode.com/uploads/2021/02/19/num2tree.jpg)
**输入：** root = `[4,9,0,5,1]`
**输出：** 1026
**解释：**
从根到叶子节点路径 `4->9->5` 代表数字 495
从根到叶子节点路径 `4->9->1` 代表数字 491
从根到叶子节点路径 `4->0` 代表数字 40
因此，数字总和 = 495 + 491 + 40 = `1026`

**提示：**
- 树中节点的数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 9`
- 树的深度不超过 `10`

## 解题思路


**问题分析**  
题目要求计算二叉树中所有从根节点到叶子节点路径组成的数字之和。例如路径 `1->2->3` 对应数字123。需要遍历所有路径并累加这些数值。

**方法选择：深度优先搜索（DFS）**  
采用前序遍历的方式递归处理每个节点，逐层构建路径对应的数值：

1. **路径数值构建**：当前路径值 = 父路径值 × 10 + 当前节点值
2. **递归终止条件**：到达叶子节点时，返回当前构建的数值
3. **结果累加**：非叶子节点将左右子树的路径和相加

**关键步骤**
1. **数值传递**：每个节点接收父层传递的累计值，更新为当前路径值
2. **叶子节点处理**：直接返回当前路径值作为该路径的最终数值
3. **非叶子节点处理**：递归计算左右子树的结果并累加


### 算法实现
1. **主函数入口**  
    `sumNumbers` 调用DFS函数，初始累计值设为0。
    
2. **DFS递归函数**
    
    - **参数说明**  
        `root`：当前处理的节点  
        `presum`：父路径累计值（不含当前节点）
3. **路径值更新**  
    `presum = presum * 10 + root->val`：将当前节点值加入路径数值系统，如父路径为12，当前节点3 → 123。
    
4. **叶子节点判断**  
    当左右子节点均为空时，直接返回当前路径值，结束递归。
    
5. **非叶子节点处理**
    
    - 分别递归处理存在的左右子树，将子树的路径和累加到 `sum`。
    - 通过判断子节点存在性避免空指针访问。
6. **结果汇总**  
    返回当前节点的子树路径和总和，实现自底向上的结果累积。



### 代码实现
```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root) {
        return dfs(root, 0);
    }

private:
    int dfs(TreeNode* root, int presum) {
        // 更新当前路径值：父路径值*10 + 当前节点值
        presum = presum * 10 + root->val;
        
        // 叶子节点：返回当前路径构成的数值
        if (root->left == nullptr && root->right == nullptr) {
            return presum;
        }
        
        int sum = 0;
        // 递归左子树，累加左子树所有路径和
        if (root->left) {
            sum += dfs(root->left, presum);
        }
        // 递归右子树，累加右子树所有路径和
        if (root->right) {
            sum += dfs(root->right, presum);
        }
        
        // 返回当前子树所有路径和的总和
        return sum;
    }
};
```


### 复杂度分析
- 时间复杂度：O(n) 每个节点访问一次
- 空间复杂度：O(h) 递归栈深度，h为树的高度（最坏情况O(n)）



  