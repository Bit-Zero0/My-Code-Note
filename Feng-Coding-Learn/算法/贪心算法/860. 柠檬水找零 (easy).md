---
Type: Note
tags:
  - 算法
  - easy
Status: writing
Start-date: 2025-02-24 14:38
Finish-date: 
Modified-date: 2025-02-24 14:50
Publish: false
---


# 860. 柠檬水找零
[860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

## 题目描述
在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

**示例 1：**
**输入：** bills = [5,5,5,10,20]
**输出：** true
**解释：**
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

**示例 2：**
**输入：** bills = [5,5,10,10,20]
**输出：** false
**解释：**
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。

**提示：**
- `1 <= bills.length <= 10^5`
- `bills[i]` 不是 `5` 就是 `10` 或是 `20`

### 算法思路

#### 问题特征分析

1. **支付场景限制**：仅接收5、10、20三种面额
2. **找零规则**：
    - 5元无需找零
    - 10元需找5元
    - 20元需找15元（优先10+5，次选3×5）

#### 贪心策略选择

**核心策略**：处理20元时优先使用10元+5元的组合找零，次选3×5元。该策略的正确性可通过以下两个引理证明：

**==引理1（局部最优性）==**  
当处理20元找零时，优先使用10元纸币能最大化保留5元纸币的数量。
**证明**：  
设当前有a张5元，b张10元
- 选择10+5找零：消耗1张10元和1张5元 → 剩余5元数a-1
- 选择3×5找零：消耗3张5元 → 剩余5元数a-3  
    显然a-1 > a-3（当a≥1时），保留更多5元更有利于后续找零


**==引理2（全局最优性）==**  
任何非贪心选择都无法得到更优解。
**证明**（反证法）：  
假设存在某个最优解在某次处理20元时未优先使用10元，则：
1. 该次找零使用3×5元（否则与贪心策略一致）
2. 后续必然存在某个10元支付无法找零（因5元被过度消耗）
3. 与"最优解"矛盾，故假设不成立

#### 数学归纳法证明

**基础情况**：当n=1时，只需处理首单，策略显然正确  
**归纳假设**：前k个顾客处理正确  
**归纳步骤**：  
对第k+1个顾客：

- 若支付5元：直接收取，不影响后续
- 若支付10元：必须存在5元，策略正确
- 若支付20元：根据引理1、2，贪心选择唯一最优

## 代码正确性验证

```cpp
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        int five = 0, ten = 0;
        for (int x : bills) {
            if (x == 5) {
                five++;
            } else if (x == 10) {
                if (five-- > 0) ten++;
                else return false;
            } else { // 处理20元
                if (ten > 0 && five > 0) { // 优先10+5
                    ten--; five--;
                } else if (five >= 3) { // 次选3×5
                    five -= 3;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(n)，单次遍历
- **空间复杂度**：O(1)，仅用两个计数器

