---
Type: Note
tags:
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2024-07-16 13:39
Finish-date: 
Modified-date: 2024-07-16 13:40
Publish: false
---

# 283. 移动零
[283. 移动零](https://leetcode.cn/problems/move-zeroes/)

## 题目描述
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**
```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```


**示例 2:**
```
输入: nums = [0]
输出: [0]
```

**提示**:
- `1 <= nums.length <= 104`
- `-231 <= nums[i] <= 231 - 1`


## 解题思路

在本题中，我们可以用一个 `cur` 指针来扫描整个数组，另一个 `dest` 指针用来记录非零数序列
的最后一个位置。根据 `cur` 在扫描的过程中，遇到的不同情况，分类处理，实现数组的划分。
可以理解为将数组分为三块
```
[0, dest] [dest+1, cur-1] [cur, n-1]
```

在 `cur` 遍历期间 , `[0, dest]` 这个区域的数据是 非零数据, `[dest+1, cur-1]`  这个区域的数据都是 0 , `[cur, n-1]` 则是未处理区域


**算法流程**:
1. 初始化 `cur = 0` （用来遍历数组）， `dest = -1` （dest 指向非零元素序列的最后一个位置。因为刚开始我们不知道最后一个非零元素在什么位置，因此初始化为 0 ）
2. cur 依次往后遍历每个元素，遍历到的元素会有下面两种情况：
	1. 遇到的元素是 0 ， `cur` 直接`++` 。因为我们的目标是让 `[dest + 1, cur - 1]` 内的元素全都是零，因此当 `cur` 遇到 `0` 的时候，直接`++` ，就可以让 0 在 cur - 1的位置上，从而在 `[dest + 1, cur - 1]` 内；
	2. 遇到的元素不是 0 ， `dest++` ，并且交换 `cur` 位置和 `dest` 位置的元素，之后让`cur++` ，扫描下一个元素。
		- `dest++` 之后，指向的元素就是 0 元素（因为非零元素区间末尾的后一个元素就是0 ），因此可以交换到 `cur` 所处的位置上，实现 `[0, dest]` 的元素全部都是非零元素， `[dest + 1, cur - 1]` 的元素全是零。


## C++代码
```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int dest = 0; 
        for(int cur = 0 ; cur < nums.size() ; cur++)
        {
            if(nums[cur] != 0) // // 处理非零元素, 与dest下标处的数据进行交换
                swap(nums[dest++] , nums[cur]);
        }    
    }
};
```
