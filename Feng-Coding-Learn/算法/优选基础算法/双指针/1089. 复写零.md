---
Type: Note
tags:
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2024-07-16 13:40
Finish-date: 
Modified-date: 2024-07-16 13:41
Publish: false
---
# 1089. 复写零
[1089. 复写零](https://leetcode.cn/problems/duplicate-zeros/)

## 题目描述
给你一个长度固定的整数数组 `arr` ，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。请对输入的数组 ==**就地**== 进行上述修改，不要从函数返回任何东西。

**示例 1：**
```
输入： arr = [1,0,2,3,0,4,5,0]
输出：[1,0,0,2,3,0,0,4]
解释： 调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]
```

**示例 2：**
```
输入： arr = [1,2,3]
输出：[1,2,3]
解释： 调用函数后，输入的数组将被修改为：[1,2,3]
```

## 解题思路
如果从前向后进行原地复写操作的话，由于 0 的出现会复写两次，导致没有复写的数被覆盖掉。因此我们选择从后往前的复写策略。

但是从后向前复写的时候，我们需要找到最后一个复写的数，因此我们的大体流程分两步：
1. 先找到最后一个复写的数；
2. 然后从后向前进行复写操作。


### 算法流程
1.  初始化两个指针 `cur = 0` ， `dest = -1`  ( dest 指向非零元素序列的最后一个位置。因为刚开始我们不知道最后一个非零元素在什么位置，因此初始化为 -1 ）；
2. 找到最后一个复写的数：
	-  当 `cur < n` 的时候，一直执行下面循环：
	- 判断 `cur` 位置的元素:
		- 如果是 0 的话， `dest` 往后移动两位；
		- 否则， `dest` 往后移动一位。
	- 判断 `dest` 时候已经到结束位置，如果结束就终止循环；
	- 如果没有结束， `cur++` ，继续判断。
3.  判断 `dest` 是否越界到 `n` 的位置：
	-  如果越界，执行下面三步：
		1. `n - 1` 位置的值修改成 0 ；
		2. `cur` 向移动一步；
		3. `dest` 向前移动两步。
4.  从 `cur` 位置开始往前遍历原数组，依次还原出复写后的结果数组：
	-  判断 `cur` 位置的值：
		1. 如果是 0 ： `dest` 以及` dest - 1` 位置修改成 0 ， `dest -= 2` ；
		2. 如果非零： `dest` 位置修改成 0 ， `dest -= 1` ；
	-  `cur--` ，复写下一个位置。


## C++代码
```cpp
class Solution {
public:
    void duplicateZeros(vector<int>& arr) {
        int cur = 0, dest = -1;
        int n = arr.size();

        // 先找到最后一个数
        while (cur < n) {
            if (arr[cur] != 0)
                dest++ ;
            else 
            dest += 2; 
            if (dest >= arr.size() - 1)
                break;
            cur++;
        }

        // 处理一下边界情况
        if (dest == n) {
            arr[n - 1] = 0;
            dest -= 2;
            cur--;
        }

        // 从后向前完成复写操作
        while (cur >= 0) {
            if (arr[cur] != 0)
                arr[dest--] = arr[cur--];
            else {
                arr[dest--] = 0;
                arr[dest--] = 0;
                cur--;
            }
        }
    }
};
```

