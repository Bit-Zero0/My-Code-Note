---
Type: Note
tags:
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2024-07-16 13:42
Finish-date: 
Modified-date: 2024-07-16 13:43
Publish: false
---

# 202. 快乐数
[202. 快乐数](https://leetcode.cn/problems/happy-number/)

## 题目描述
编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**
```
 输入： n = 19
 输出： true
 解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**
```
输入： n = 2
输出： false
```

**提示：**

- `1 <= n <= 231 - 1`

## 解题思路
为了方便叙述，将**对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和**这一个
操作记为 `x` 操作；

题目告诉我们，当我们不断重复 `x` 操作的时候，计算一定会「死循环」，死的方式有两种：
- 情况一：一直在 1 中死循环，即 1 -> 1 -> 1 -> 1......
- 情况二：在历史的数据中死循环，但始终变不到 1

由于上述两种情况只会出现一种，因此，只要我们能确定循环是在情况一中进行，还是在情
况二中进行，就能得到结果。


### 简单证明
a. 经过一次变化之后的最大值 `9^2 * 10 = 810` (` 2^31-1=2147483647` 。选一个更大的最
大 9999999999 )，也就是变化的区间在`[1, 810]` 之间；
b. 根据**鸽巢原理**，一个数变化 ==811== 次之后，必然会形成一个循环；
c. 因此，变化的过程最终会走到一个圈里面，因此可以用「快慢指针」来解决。
![[202.快乐数图.svg]]

### 算法流程
根据上述的题目分析，我们可以知道，当重复执行 x 的时候，数据会陷入到一个**循环**之中。而快慢指针有一个特性，就是在一个圆圈中，快指针总是会追上慢指针的，也就是说他们总会相遇在一个位置上。如果相遇位置的值是 `1` ，那么这个数一定是快乐数；如果相遇位置不是 1的话，那么就不是快乐数。

> [!info]+ 补充知识：如何求一个数 n 每个位置上的数字的平方和。
> 1. 把数` n` 每一位的数提取出来：
> 	- 循环迭代下面步骤：
> 		- `int t = n % 10` 提取个位；
> 		- `n /= 10` 干掉个位；
> 	- 直到 `n` 的值变为 0 ；
> 1. 提取每一位的时候，用一个变量 `tmp` 记录这一位的平方与之前提取位数的平方和
> 	- `tmp = tmp + t * t`


## C++代码
```cpp
class Solution {
public:
    int getNextNum(int n) // 返回 n 这个数每一位上的平方和, 也就是下一个数
    {
        int sum = 0;
        while (n) 
        {
            int t = n % 10;
            sum += t * t;
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) 
    {
        int slow = n;
        int fast = getNextNum(n);
        while (slow != fast) //如果相遇位置的值是 1 ，那么这个数一定是快乐数；如果相遇位置不是 1的话，那么就不是快乐数。
        {
            slow = getNextNum(slow);
            fast = getNextNum(getNextNum(fast));
        }
        return slow == 1;
    }
};
```


