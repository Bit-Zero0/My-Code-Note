---
Type: Note
tags:
  - 算法
  - CPP
Status: writing
Start-date: 2024-07-15 20:57
Finish-date: 
Modified-date: 2024-07-15 22:37
Publish: false
---




# 209. 长度最小的子数组
[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

## 题目描述
给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**
```
输入： target = 7, nums = [2,3,1,2,4,3]
输出： 2
解释： 子数组 `[4,3]` 是该条件下的长度最小的子数组。
```


**示例 2：**
```
输入： target = 4, nums = [1,4,4]
输出： 1
```

**示例 3：**
```
输入： target = 11, nums = [1,1,1,1,1,1,1,1]
输出： 0
```

## 解题思路
### 解法一: 暴力枚举(会超时)
「从前往后」枚举数组中的任意一个元素，把它当成起始位置。然后从这个「起始位置」开始，然后寻找一段最短的区间，使得这段区间的和「大于等于」目标值。

将所有元素作为起始位置所得的结果中，找到「最小值」即可。
```cpp
class Solution {
public:
	int minSubArrayLen(int target, vector<int>& nums) {
		// 记录结果
		int ret = INT_MAX;
		int n = nums.size();
		
		// 枚举出所有满足和大于等于 target 的子数组[start, end]
		// 由于是取到最小，因此枚举的过程中要尽量让数组的长度最小
		// 枚举开始位置
		for (int start = 0; start < n; start++)
		{
			int sum = 0; // 记录从这个位置开始的连续数组的和
			// 寻找结束位置
			for (int end = start; end < n; end++)
			{
				sum += nums[end]; // 将当前位置加上
				if (sum >= target) // 当这段区间内的和满足条件时
				{
					// 更新结果，start 开头的最短区间已经找到
					ret = min(ret, end - start + 1);
					break;
				}
			}
		}
		// 返回最后结果
		return ret == INT_MAX ? 0 : ret;
	}
};
```


### 解法二: 滑动窗口
由于此问题分析的对象是「一段连续的区间」，因此可以考虑「滑动窗口」的思想来解决这道题。

让滑动窗口满足：从 `i` 位置开始，窗口内所有元素的和小于 `target` （那么当窗口内元素之和第一次大于等于目标值的时候，就是 `i` 位置开始，满足条件的最小长度）。

做法：将右端元素划入窗口中，统计出此时窗口内元素的和：
- 如果窗口内元素之和大于等于 `target` ：更新结果，并且将左端元素划出去的同时继续判断是否满足条件并更新结果（因为左端元素可能很小，划出去之后依旧满足条件）
- 如果窗口内元素之和不满足条件： `right++` ，另下一个元素进入窗口。

> [!tip]+ 为何滑动窗口可以解决问题，并且时间复杂度更低？
> - 这个窗口寻找的是：以当前窗口最左侧元素（记为 `left1` ）为基准，符合条件的情况。也就是在这道题中，从 `left1` 开始，满足区间和 `sum >= target` 时的最右侧（记为`right1` ）能到哪里。
> - 我们既然已经找到从 `left1` 开始的最优的区间，那么就可以大胆舍去 `left1` 。但是如果继续像方法一一样，重新开始统计第二个元素（ `left2` ）往后的和，势必会有大量重复的计算（因为我们在求第一段区间的时候，已经算出很多元素的和了，这些和是可以在计算下次区间和的时候用上的）。
> - 此时， `rigth1` 的作用就体现出来了，我们只需将 `left1` 这个值从 `sum` 中剔除。从`right1` 这个元素开始，往后找满足 `left2` 元素的区间（此时 `right1` 也有可能是满足的，因为 `left1` 可能很小。`sum` 剔除掉 `left1` 之后，依旧满足大于等于`target` ）。这样我们就能省掉大量重复的计算。
> - 这样我们不仅能解决问题，而且效率也会大大提升。
> 
>时间复杂度：虽然代码是两层循环，但是我们的 `left` 指针和 `right` 指针都是不回退的，两者最多都往后移动 `n` 次。因此时间复杂度是 `O(N)` 。
## C++代码
```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int len = INT_MAX;
        int sum = 0;
        int left = 0 ;
        for(int right = 0 ; right < nums.size(); right++)
        {
            sum += nums[right]; // 进窗口
            while(sum >= target)// 判断
            {
                len = min(len , right - left + 1);// 更新结果
                sum -= nums[left++]; //出窗口
            }
        }
        return  len = len == INT_MAX ? 0 : len;
    }
};
```




# 3. 无重复字符的最长子串
[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 题目描述
给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串**的长度。

**示例 1:**
```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 `"abc"`，所以其长度为 3。
```



**示例 2:**
```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 `"b"`，所以其长度为 1。
```



**示例 3:**
```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 `"wke"`，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，`"pwke"` 是一个_子序列，_不是子串。
```

## 解题思路
### 解法一: 暴力枚举（不会超时，可以通过）
枚举「从每一个位置」开始往后，无重复字符的子串可以到达什么位置。找出其中长度最大的即可。
在往后寻找无重复子串能到达的位置时，可以利用「哈希表」统计出字符出现的频次，来判断什么时候子串出现了重复元素。

```cpp
class Solution {
public:
	int lengthOfLongestSubstring(string s) {
		int ret = 0; // 记录结果
		int n = s.length();
		// 1. 枚举从不同位置开始的最长重复子串
		// 枚举起始位置
		for (int i = 0; i < n; i++)
		{
			// 创建一个哈希表，统计频次
			int hash[128] = { 0 };
			// 寻找结束为止
			for (int j = i; j < n; j++)
			{
				hash[s[j]]++; // 统计字符出现的频次
				if (hash[s[j]] > 1) // 如果出现重复的
				break;
				// 如果没有重复，就更新 ret
				ret = max(ret, j - i + 1);
			}
		}
		// 2. 返回结果
		return ret;
	}
};
```

### 解法二: 滑动窗口
研究的对象依旧是一段连续的区间，因此继续使用「滑动窗口」思想来优化。

让滑动窗口满足：窗口内所有元素都是不重复的。

做法：右端元素 `ch` 进入窗口的时候，哈希表统计这个字符的频次：
- 如果这个字符出现的频次超过 `1` ，说明窗口内有重复元素，那么就从左侧开始划出窗口，直到 `ch` 这个元素的频次变为 `1` ，然后再更新结果。
- 如果没有超过 `1` ，说明当前窗口没有重复元素，可以直接更新结果


## C++代码
```c
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int result = 0;
        int hash[128] = {0}; // 使用数组来模拟哈希表

        for(int left = 0 , right = 0; right < s.size() ; right++)
        {
            hash[s[right]]++;
            while(hash[s[right]] == 2) //当hash[s[right]] == 2 时说明遇到相同字符
                hash[s[left++]]--;
            
            result = max(result , right - left + 1);// 更新结果
        }
        return result;
    }
};
```





# 1004. 最大连续1的个数 III
[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)
## 题目描述
给定一个二进制数组 `nums` 和一个整数 `k`，如果可以翻转最多 `k` 个 `0` ，则返回 数组中连续 `1` 的最大个数 。

**示例 1：**
```
输入： nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出： 6
解释：[1,1,1,0,0,1,1,1,1,1,1]
第六个数字从 0 翻转到 1，最长的子数组长度为 6。
```

**示例 2：**
```
输入： nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出： 10
解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
第五个数字从 0 翻转到 1，最长的子数组长度为 10。
```

## 解题思路
不要去想怎么翻转，不要把问题想的很复杂，这道题的结果无非就是一段连续的 `1` 中间塞了 `k` 个 `0` 嘛。

因此，我们可以把问题转化成：求数组中一段最长的连续区间，要求这段区间内 `0` 的个数不超
过 `k` 个。

既然是连续区间，可以考虑使用「滑动窗口」来解决问题。

![[1004. 最大连续1的个数 III图1.svg]]
### 算法流程
1. 初始化一个大小为 2 的数组就可以当做哈希表 hash 了；初始化一些变量` left = 0 ,right = 0 , ret = 0` ；
2. 当 `right` 小于数组大小的时候，一直下列循环：
	1) 让当前元素进入窗口，顺便统计到哈希表中；
	2) 检查 `0` 的个数是否超标：
		- 如果超标，依次让左侧元素滑出窗口，顺便更新哈希表的值，直到 `0` 的个数恢复正常；
	3) 程序到这里，说明窗口内元素是符合要求的，更新结果；
	4) `right++` ，处理下一个元素；
3. 循环结束后， `ret` 存的就是最终结果。

## C++代码
```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int result = 0;
        int zero_count = 0;
        for(int left = 0, right = 0; right < nums.size() ; right++)
        {
            if(nums[right] == 0) // 进窗口; 如果是 1 就无视, 是 0 就zero_count++
                zero_count++;
            while(zero_count > k)
            {
                if(nums[left++] == 0) // 出窗口
                    zero_count--;
            }
            result = max(result, right - left + 1 );// 更新结果
        }
        return result;
    }
};
```
