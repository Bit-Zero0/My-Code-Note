---
Type: Note
tags:
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2024-07-16 17:19
Finish-date: 
Modified-date: 2024-07-16 21:23
Publish: false
---

# 904. 水果成篮
[904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)

## 题目描述
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

**示例 1：**
```
输入： fruits = [_1,2,1_]
输出： 3
解释： 可以采摘全部 3 棵树。
```

**示例 2：**
```
输入： fruits = [0,1,2,2_]
输出： 3
解释： 可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

**示例 3：**
```
输入： fruits = [1,2,3,2,2_]
输出： 4
解释： 可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

**示例 4：**
```
输入： fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出： 5
解释： 可以采摘 [1,2,1,1,2] 这五棵树。
```

**提示：**

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

## 解题思路
研究的对象是一段连续的区间，可以使用**滑动窗口**思想来解决问题。
**让滑动窗口满足**：窗口内水果的种类只有两种。

做法：右端水果进入窗口的时候，用哈希表统计这个水果的频次。这个水果进来后，判断哈希表的
大小：
- 如果大小超过 2：说明窗口内水果种类超过了两种。那么就从左侧开始依次将水果划出窗口，直到哈希表的大小小于等于 2，然后更新结果；
- 如果没有超过 2，说明当前窗口内水果的种类不超过两种，直接更新结果 ret。
![[904. 水果成篮图1.svg]]

### 算法流程
1.  初始化哈希表 hash 来统计窗口内水果的种类和数量；
2. 初始化变量：左右指针 `left = 0，right = 0`，记录结果的变量 `ret = 0`；
3. 当 right 小于数组大小的时候，一直执行下列循环：
	1)  将当前水果放入哈希表中；
	2) 判断当前水果进来后，哈希表的大小：
		- 如果超过 `2`：
			- 将左侧元素滑出窗口，并且在哈希表中将该元素的频次减一；
			- 如果这个元素的频次减一之后变成了 `0`，就把该元素从哈希表中删除；
			- 重复上述两个过程，直到哈希表中的大小不超过 `2`；
	3) 更新结果 `ret`；
	4) `right++`，让下一个元素进入窗口；
4.  循环结束后，`ret` 存的就是最终结果。

## C++代码
```cpp
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        unordered_map<int ,int> hash; // 统计窗口内出现了多少种水果
        int result = 0;
        for(int left = 0 , right = 0 ; right < fruits.size(); right++)
        {
            hash[fruits[right]]++;
            while(hash.size() > 2)
            {
                hash[fruits[left]]--;    //去除之前加入的水果种类
                if(hash[fruits[left]] == 0)
                    hash.erase(fruits[left]);
                left++;
            }
            result = max(result , right - left + 1);
        }

        return result;
    }
};
```

