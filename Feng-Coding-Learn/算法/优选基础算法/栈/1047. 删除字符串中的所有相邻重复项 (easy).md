---
Type: Note
tags:
  - 算法
  - CPP
  - easy
Status: writing
Start-date: 2025-02-21 14:24
Finish-date: 
Modified-date: 2025-02-21 15:11
Publish: false
---


# 1047. 删除字符串中的所有相邻重复项
[1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

## 题目描述
给出由小写字母组成的字符串 `s`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 `s` 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**
**输入：**"abbaca"
**输出：**"ca"
**解释：**
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

**提示：**
1. `1 <= s.length <= 10^5`
2. `s` 仅由小写英文字母组成。

## 解题思路


我们需要**持续消除相邻重复字符**，直到字符串中不存在相邻重复项。例如：

```
输入：a → b → b → a → c → a
操作：发现 `bb` 相邻 → 消除 → 字符串变为 "aaca"
再次扫描：发现 `aa` 相邻 → 消除 → 最终结果 "ca"
```

- **消除的连锁反应**：一次消除可能**暴露新的相邻重复项**（如示例中的 `aaca → ca`）
- **消除顺序特性**：每次只需关注**当前字符与前一个字符**的关系，这提示可以使用**栈结构**来记录处理过程中的中间状态。

### 关键点解析

1. **栈的隐式使用**：  
    通过字符串的尾部操作模拟栈，代码简洁且运行高效，避免了显式栈结构的额外转换。
    
2. **消除的传递性**：  
    示例 `abba` 的处理过程：
    ```
    压入 a → 压入 b → 遇到 b 弹栈 → 遇到 a 弹栈 → 栈空
    ```
    这展示了栈如何自动处理多级嵌套消除。
    
3. **边界条件处理**：  
    检查 `result.empty()` 防止对空栈调用 `back()` 导致未定义行为。


### 算法设计

- ==栈==的**后进先出（LIFO）** 特性天然适合处理相邻元素的匹配问题。
- **操作逻辑**：
    1. 遍历字符串，依次将字符压入栈。
    2. **若当前字符与栈顶字符相同**，则弹出栈顶（消除重复对）。
    3. **否则**，将当前字符压入栈。

**实现优化**
- **用字符串模拟栈**：直接使用 `string` 的 `back()` 和 `pop_back()` 方法实现栈操作，避免显式栈结构的转换开销。


#### 示例分析

以输入 `s = "abbaca"` 为例：

1. 处理 `a`：栈为空，压入 → `result = "a"`。
2. 处理 `b`：栈顶为 `a`，不同，压入 → `result = "ab"`。
3. 处理 `b`：栈顶为 `b`，相同，弹出 → `result = "a"`。
4. 处理 `a`：栈顶为 `a`，相同，弹出 → `result = ""`。
5. 处理 `c`：栈为空，压入 → `result = "c"`。
6. 处理 `a`：栈顶为 `c`，不同，压入 → `result = "ca"`。


## C++代码

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string result = "";  // 用字符串模拟栈结构
        for (auto c : s) {   // 遍历每个字符
            // 当栈非空且栈顶字符等于当前字符时，触发消除操作
            if (!result.empty() && result.back() == c) {
                result.pop_back();  // 弹出栈顶字符（消除重复对）
            } else {
                result.push_back(c); // 压入当前字符
            }
        }
        return result; // 栈中剩余字符即为最终结果
    }
};
```

### 复杂度分析

- **时间复杂度**：**O(n)**  
    每个字符仅被处理一次（压栈或弹栈一次），总操作次数与输入规模 `n` 成线性关系。

- **空间复杂度**：**O(n)**  
    最坏情况下无重复字符（如输入为 "abcdef"），栈空间需要存储全部 `n` 个字符。
    


### 双指针优化
可以用快慢指针模拟栈操作，将空间复杂度优化到 O(1)（但需在原字符串上修改）：

```cpp
int slow = 0;
for (int fast=0; fast<s.size(); fast++) {
	if (slow > 0 && s[slow-1] == s[fast]) {
		slow--; // 模拟弹栈
	} else {
		s[slow++] = s[fast]; // 模拟压栈
	}
}
return s.substr(0, slow);
```

    





