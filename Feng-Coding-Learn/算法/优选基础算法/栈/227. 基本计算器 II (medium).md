---
Type: Note
tags:
  - 算法
  - CPP
  - medium
Status: writing
Start-date: 2025-02-21 15:55
Finish-date: 
Modified-date: 2025-02-21 17:07
Publish: false
---


# 227. 基本计算器 II
[227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

## 题目描述
给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 `[-231, 231 - 1]` 的范围内。

**注意：** 不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1：**
**输入：** s = "3+2*2"
**输出：** 7

**示例 2：**
**输入：** s = " 3/2 "
**输出：** 1

**示例 3：**
**输入：** s = " 3+5 / 2 "
**输出：** 5


**提示：**
- `1 <= s.length <= 3 * 10^5`
- `s` 由整数和算符 `('+', '-', '*', '/')` 组成，中间由一些空格隔开
- `s` 表示一个 **有效表达式**
- 表达式中的所有整数都是非负整数，且在范围 `[0, 231 - 1]` 内
- 题目数据保证答案是一个 **32-bit 整数**

## 解题思路

### 问题本质分析

需要处理运算符优先级问题：**乘除优先级高于加减**，且运算顺序从左到右。例如，`3+5*2` 应计算为 `3+(5*2)=13`，而非 `(3+5)*2=16`。

- **延迟计算加减**：加减运算的优先级较低，可以先将操作数存入栈中，最后统一求和。
- **立即计算乘除**：乘除运算优先级高，遇到时需立即计算，并将结果存入栈中。
- **符号处理**：通过维护前一个运算符的状态，决定当前数值的处理方式。



### 算法设计

#### 核心思路：栈模拟

- **选择原因**：栈的**后进先出（LIFO）** 特性适合处理需要延迟计算的加减操作。
- **操作逻辑**：
    1. 遍历字符串，解析数字和运算符。
    2. **遇到数字**：解析完整数值，根据前一个运算符决定操作：
        - `+`：将数值压入栈。
        - `-`：将负数值压入栈。
        - `*` 和`/`：立即计算栈顶元素与当前数值的乘除结果，更新栈顶。
    3. **遇到运算符/空格**：更新前一个运算符或跳过空格。
    4. **最终计算**：将栈中所有元素求和。

#### 实现细节
- **数字解析**：通过循环累加处理连续数字字符（如 `123` → `1*10 + 2 → 12*10 +3=123`）。
- **符号初始化**：初始运算符设为 `+`，确保第一个数字能被正确处理。


> [!warning]+ 关键点解析
> 1. **运算符状态维护**：  
>     通过变量 `op` 记录前一个运算符，确保正确处理当前数值。例如，在 `3-2*5` 中：
>     - 解析 `3` 时 `op` 为 `+`，压入 `3`。
>     - 遇到 `-` 更新 `op`。
>     - 解析 `2` 时 `op` 为 `-`，压入 `-2`。
>     - 遇到 `*` 更新 `op`。
>     - 解析 `5` 时立即计算 `-2*5=-10`，更新栈顶。
> 2. **立即计算乘除**：  
>     乘除的高优先级通过立即计算实现，避免后续操作干扰。例如，`3+4*2` 中，`4*2` 在解析到 `*` 后立即计算，保证结果正确。
> 3. **边界条件处理**：
>     - 处理连续空格（如 `" 3 + 4 "`）。
>     - 处理单个数字（如 `"42"`）。
>     - 处理除法的向零取整（如 `-3/2=-1`）。




## 代码实现

```cpp
class Solution {
public:
    int calculate(string s) {
        char op = '+'; // 初始运算符设为'+'，处理第一个数字
        int n = s.size();
        vector<int> st; // 用栈存储中间结果

        for (int i = 0; i < n;) {
            if (s[i] == ' ') { // 跳过空格
                i++;
            } else if (isdigit(s[i])) { // 处理数字
                int temp = 0;
                while (i < n && isdigit(s[i])) { // 解析完整数字
                    temp = temp * 10 + (s[i++] - '0');
                }
                // 根据前一个运算符处理当前数值
                if (op == '-') {
                    st.push_back(-temp);
                } else if (op == '+') {
                    st.push_back(temp);
                } else if (op == '*') {
                    st.back() *= temp; // 立即计算乘法
                } else {
                    st.back() /= temp; // 立即计算除法（向零取整）
                }
            } else { // 更新运算符
                op = s[i];
                i++;
            }
        }

        int result = 0;
        for (auto x : st) { // 累加栈中所有元素
            result += x;
        }
        return result;
    }
};
```


### 复杂度分析
- **时间复杂度**：**O(n)**  
    每个字符仅被处理一次，数字解析和栈操作均为 O(1) 时间。
- **空间复杂度**：**O(n)**  
    栈空间在最坏情况下（全为加减操作）需要存储所有数字。



## 拓展思考

### 处理括号的扩展

若题目增加括号（如 LeetCode 224. 基本计算器 #todo ），需引入递归或栈处理括号层级：

```
int calculate(string s) {
    stack<int> nums;
    stack<char> ops;
    // 增加括号处理逻辑
}
```

- **递归法**：遇到 `(` 时递归计算括号内表达式，遇到 `)` 时返回结果。
- **栈法**：用栈保存当前运算状态，遇到 `(` 压栈，遇到 `)` 弹栈计算。


