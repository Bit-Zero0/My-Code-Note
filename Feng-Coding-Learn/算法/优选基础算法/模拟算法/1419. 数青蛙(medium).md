---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-23 17:12
Finish-date: 
Modified-date: 2025-01-23 17:18
Publish: false
---


# 1419. 数青蛙
[1419. 数青蛙](https://leetcode.cn/problems/minimum-number-of-frogs-croaking/)

## 题目描述


## 解题思路

#### **问题背景**

题目要求计算最少需要多少只青蛙才能发出给定的“croak”叫声序列。每只青蛙发出的叫声必须是完整的“croak”，且叫声不能交叉。例如：
- 输入：`"croakcroak"`，输出：`1`（一只青蛙即可）。
- 输入：`"crcoakroak"`，输出：`2`（需要两只青蛙）。

#### **关键点分析**
1. **叫声的顺序性**  
    每只青蛙发出的叫声必须严格按“croak”的顺序，不能交叉。这意味着：
    - 如果某个字符（如 `'o'`）出现，那么它前面的字符（`'r'`）必须已经出现过。
    - 如果某个字符（如 `'k'`）出现，那么它前面的字符（`'a'`）必须已经出现过，并且可以“释放”一只青蛙去发出下一个“croak”。

2. **状态的模拟**  
    我们需要模拟每只青蛙的状态，记录当前每只青蛙处于“croak”中的哪个阶段。例如：
    - 如果一只青蛙当前发出了 `'c'`，那么它下一步只能发出 `'r'`。
    - 如果一只青蛙当前发出了 `'k'`，那么它完成了一个“croak”，可以重新发出 `'c'`。

3. **计数与校验**
    - 使用一个数组 `hash` 来记录每个字符的状态数量。例如，`hash[0]` 表示当前有多少只青蛙处于“c”阶段。
    - 如果某个字符的前一个字符数量不足，说明叫声顺序被打乱，返回 `-1`。
    - 最终，所有青蛙必须完成“croak”，即 `hash[0]` 到 `hash[3]` 应该为 0，只有 `hash[4]`（完成“croak”的青蛙数量）有值。


#### **难点应对**
1. **如何判断叫声是否合法？**  
    使用一个哈希表 `index` 来记录每个字符在“croak”中的位置，通过数组 `hash` 来模拟每只青蛙的状态。如果某个字符的前一个字符数量不足，说明叫声不合法，返回 `-1`。
2. **如何计算最少的青蛙数量？**
    - 当遇到 `'c'` 时，如果之前有完成“croak”的青蛙（`hash[4] > 0`），可以复用这只青蛙；否则，增加一只新青蛙。
    - 当遇到 `'k'` 时，表示一只青蛙完成了一个“croak”，可以复用这只青蛙去发出下一个“croak”。
3. **如何确保所有青蛙都完成叫声？**  
    最终检查 `hash[0]` 到 `hash[3]` 是否为 0，只有 `hash[4]` 有值。如果不是，说明叫声序列不合法，返回 `-1`。
    

### **算法逻辑**
1. **初始化：**
    - 定义字符串 `croak = "croak"`，表示青蛙的叫声。
    - 初始化数组 `hash`，长度为 5，用于记录每个状态的青蛙数量。
    - 初始化哈希表 `index`，记录每个字符在“croak”中的位置。
2. **遍历叫声序列：**
    - 对于每个字符 `ch`：
        - 如果是 `'c'`：
            - 如果有完成“croak”的青蛙（`hash[4] > 0`），复用这只青蛙；否则，增加一只新青蛙。
        - 如果是其他字符：
            - 检查前一个字符的数量是否足够。如果不足，说明叫声序列不合法，返回 `-1`。
            - 更新当前字符的状态数量。
3. **校验最终状态：**
    - 检查 `hash[0]` 到 `hash[3]` 是否为 0，只有 `hash[4]` 有值。如果不是，返回 `-1`。
4. **返回结果：**
    - 返回 `hash[4]`，即完成“croak”的青蛙数量。
        


## C++代码

```cpp
class Solution {
public:
    int minNumberOfFrogs(string croakOfFrogs) {
        string croak = "croak";  // 定义青蛙的叫声
        int n = croak.size();    // 叫声的长度
        vector<int> hash(n, 0);  // 用数组模拟哈希表，记录每个状态的青蛙数量

        // 哈希表，记录每个字符在“croak”中的位置
        unordered_map<char, int> index;
        for (int i = 0; i < n; i++) {
            index[croak[i]] = i;
        }

        // 遍历给定的叫声序列
        for (char ch : croakOfFrogs) {
            if (ch == 'c') {
                // 如果是 'c'：
                // 如果有完成“croak”的青蛙（hash[4] > 0），复用这只青蛙
                if (hash[n - 1] != 0) {
                    hash[n - 1]--;
                }
                // 增加一只新青蛙，处于 'c' 阶段
                hash[index[ch]]++;
            } else {
                // 如果是其他字符：
                // 检查前一个字符的数量是否足够
                if (hash[index[ch] - 1] > 0) {
                    hash[index[ch] - 1]--;
                } else {
                    // 如果前一个字符数量不足，说明叫声序列不合法
                    return -1;
                }
                // 更新当前字符的状态数量
                hash[index[ch]]++;
            }
        }

        // 校验最终状态：
        // 所有青蛙必须完成“croak”，即 hash[0] 到 hash[3] 应该为 0
        for (int i = 0; i < n - 1; i++) {
            if (hash[i] > 0) {
                return -1;
            }
        }

        // 返回完成“croak”的青蛙数量
        return hash[n - 1];
    }
};
```


### **代码解释**
1. **初始化：**
    - `string croak = "croak";` 定义青蛙的叫声。
    - `vector<int> hash(n, 0);` 初始化数组，记录每个状态的青蛙数量。
    - `unordered_map<char, int> index;` 初始化哈希表，记录每个字符在“croak”中的位置。

2. **遍历叫声序列：**
    - 如果当前字符是 `'c'`：
        - 如果有完成“croak”的青蛙（`hash[4] > 0`），复用这只青蛙；否则，增加一只新青蛙。
    - 如果是其他字符：
        - 检查前一个字符的数量是否足够。如果不足，说明叫声序列不合法，返回 `-1`。
        - 更新当前字符的状态数量。
    
3. **校验最终状态：**
    - 检查 `hash[0]` 到 `hash[3]` 是否为 0，只有 `hash[4]` 有值。如果不是，返回 `-1`。

4. **返回结果：**
    - 返回 `hash[4]`，即完成“croak”的青蛙数量。

### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是 `croakOfFrogs` 的长度。我们只需要遍历一次字符串。
- **空间复杂度**：`O(1)`，使用了固定大小的数组和哈希表。