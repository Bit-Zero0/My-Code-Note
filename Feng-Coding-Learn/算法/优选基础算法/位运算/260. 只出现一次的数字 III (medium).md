---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2025-01-22 12:49
Finish-date: 
Modified-date: 2025-01-22 13:28
Publish: false
---


# 260. 只出现一次的数字 III
[260. 只出现一次的数字 III](https://leetcode.cn/problems/single-number-iii/)

## 题目描述
给你一个整数数组 `nums`，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 **任意顺序** 返回答案。

你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

**示例 1：**
**输入：** nums = [1,2,1,3,2,5]
**输出：**[3,5]
**解释：**[5, 3] 也是有效的答案。

**示例 2：**
**输入：** nums = [-1,0]
**输出：**[-1,0]

**示例 3：**
**输入：** nums = [0,1]
**输出：**[1,0]

**提示：**
- `2 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- 除两个只出现一次的整数外，`nums` 中的其他数字都出现两次

## 解题思路
使用 **异或运算** 来解决这个问题。通过异或运算的性质，找到只出现一次的两个数字。

- 异或运算的性质：
	- 任何数和 0 异或，结果是它本身：`a ^ 0 = a`。
	- 任何数和它本身异或，结果是 0：`a ^ a = 0`。
	- 异或运算满足交换律和结合律：`a ^ b ^ a = b`。

### 算法流程
1. **计算所有数字的异或和**：
   - 将数组 `nums` 中的所有数字异或起来，得到一个临时值 `x`。
   - 最终 `x` 的值是只出现一次的两个数字的异或结果。

2. **找到区分两个数字的二进制位**：
   - 找到 `x` 中任意一个为 `1` 的二进制位，记为 `diff`。
   - 这个二进制位可以将所有数字分为两组：一组在该位上为 `1`，另一组在该位上为 `0`。

3. **分组异或**：
   - 将数组 `nums` 中的所有数字按照 `diff` 位分为两组。
   - 对每组分别进行异或运算，得到只出现一次的两个数字 `a` 和 `b`。

4. **返回结果**：
   - 返回 `{a, b}`。


#### 示例解释
以 `nums = [1, 2, 1, 3, 2, 5]` 为例：

1. **计算所有数字的异或和**：
   - `1 ^ 2 ^ 1 ^ 3 ^ 2 ^ 5 = 3 ^ 5 = 6`。
   - `x = 6`，二进制表示为 `110`。

2. **找到区分两个数字的二进制位**：
   - `x = 6`，二进制表示为 `110`。
   - `diff = 1`（第 1 位为 `1`）。

3. **分组异或**：
   - 分组：
     - 第 1 位为 `1` 的数字：`2`、`3`、`2`。
     - 第 1 位为 `0` 的数字：`1`、`1`、`5`。
   - 异或结果：
     - `a = 1 ^ 1 ^ 5 = 5`。
     - `b = 2 ^ 3 ^ 2 = 3`。

4. **最终结果**：
   - `{3, 5}`。

## C++代码

```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        int x = 0;

        // 第一步：计算所有数字的异或和
        for (int num : nums) {
            x ^= num;
        }

        // 第二步：找到区分两个数字的二进制位
        int diff = 0;
        while (1) {
            if ((x >> diff) & 1 == 1) break;
            diff++;
        }

        // 第三步：分组异或
        int a = 0, b = 0;
        for (int num : nums) {
            if ((num >> diff) & 1 == 1) {
                b ^= num;
            } else {
                a ^= num;
            }
        }

        // 第四步：返回结果
        return {a, b};
    }
};
```


### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。我们需要遍历数组两次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。

