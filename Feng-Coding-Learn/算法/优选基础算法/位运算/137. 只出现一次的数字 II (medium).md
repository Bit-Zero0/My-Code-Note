---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-21 22:39
Finish-date: 
Modified-date: 2025-01-21 22:44
Publish: false
---


# 137. 只出现一次的数字 II
[137. 只出现一次的数字 II](https://leetcode.cn/problems/single-number-ii/)

## 题目描述
给你一个整数数组 `nums` ，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次 。** 请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且使用常数级空间来解决此问题。

**示例 1：**

**输入：** nums = [2,2,3,2]
**输出：** 3

**示例 2：**

**输入：** nums = [0,1,0,1,0,1,99]
**输出：** 99

**提示：**
- `1 <= nums.length <= 3 * 104`
- `-231 <= nums[i] <= 231 - 1`
- `nums` 中，除某个元素仅出现 **一次** 外，其余每个元素都恰出现 **三次**

## 解题思路

核心思想是使用 **位运算** 来解决这个问题。通过统计每个二进制位上 `1` 的个数，找到只出现一次的数字。

- 对于每个二进制位，统计所有数字在该位上 `1` 的个数。
- 如果某个数字出现了三次，那么该数字在每个二进制位上的 `1` 的个数一定是 `3` 的倍数。
- 只出现一次的数字会在某些二进制位上贡献额外的 `1`。


### 算法流程

1. 初始化 `result` 为 0。
2. 遍历每个二进制位（从 0 到 31）：
   - 统计所有数字在该位上 `1` 的个数，记为 `sum`。
   - 将 `sum` 对 3 取模，得到只出现一次的数字在该位上的值。(若出现n次则取模 n)
   - 如果 `sum % 3 == 1`，则将 `result` 的该位设置为 1。
3. 返回 `result`。


### 示例解释
以 `nums = [2, 2, 3, 2]` 为例：

1. **二进制表示**：
   - `2` 的二进制表示为 `10`。
   - `3` 的二进制表示为 `11`。

2. **统计每个二进制位上的 `1` 的个数**：
   - 第 0 位：
     - `2` 的第 0 位是 `0`。
     - `3` 的第 0 位是 `1`。
     - `sum = 1`。
   - 第 1 位：
     - `2` 的第 1 位是 `1`。
     - `3` 的第 1 位是 `1`。
     - `sum = 4`。

3. **对 `sum` 取模**：
   - 第 0 位：`sum % 3 = 1`，所以 `result` 的第 0 位设置为 `1`。
   - 第 1 位：`sum % 3 = 1`，所以 `result` 的第 1 位设置为 `1`。

4. **最终结果**：
   - `result` 的二进制表示为 `11`，即 `3`。


### 代码注释
```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int result = 0; // 初始化结果为 0

        // 遍历每个二进制位
        for (int i = 0; i < 32; i++) {
            int sum = 0; // 统计当前位上 1 的个数

            // 遍历所有数字
            for (int x : nums) {
                // 检查当前位是否为 1
                if ((x >> i) & 1 == 1) {
                    sum++;
                }
            }

            // 对 3 取模，得到只出现一次的数字在当前位的值
            sum %= 3;

            // 如果 sum 为 1，则将 result 的当前位设置为 1
            if (sum == 1) {
                result |= 1 << i;
            }
        }

        return result; // 返回结果
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。我们需要遍历每个数字的每个二进制位。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。


