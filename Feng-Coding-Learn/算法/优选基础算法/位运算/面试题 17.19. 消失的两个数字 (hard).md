---
Type: Note
tags:
  - 算法
  - hard
Status: writing
Start-date: 2025-01-21 23:14
Finish-date: 
Modified-date: 2025-02-11 22:21
Publish: false
---


# 面试题 17.19. 消失的两个数字
[面试题 17.19. 消失的两个数字](https://leetcode.cn/problems/missing-two-lcci/)

## 题目描述
给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？

以任意顺序返回这两个数字均可。

**示例 1:**
**输入:** `[1]`
**输出:** [2,3]

**示例 2:**
**输入:** `[2,3]`
**输出:** [1,4]

**提示：**
- `nums.length <= 30000`

## 解题思路
本题就是 [[268. 丢失的数字]] + [[260. 只出现一次的数字 III (medium)]] 组合起来的题.

使用 **异或运算** 来解决这个问题。通过异或运算的性质，找到缺失的两个数字。

#### 1异或运算的基本思想
- 异或运算的性质：
  - 任何数和 0 异或，结果是它本身：`a ^ 0 = a`。
  - 任何数和它本身异或，结果是 0：`a ^ a = 0`。
  - 异或运算满足交换律和结合律：`a ^ b ^ a = b`。


### 算法流程
1. **计算所有数字的异或和**：
   - 将 `1` 到 `N` 的所有数字异或起来，得到一个临时值 `temp`。
   - 将数组 `nums` 中的所有数字异或到 `temp` 中。
   - 最终 `temp` 的值是缺失的两个数字的异或结果。

2. **找到区分两个数字的二进制位**：
   - 找到 `temp` 中任意一个为 `1` 的二进制位，记为 `diff`。
   - 这个二进制位可以将所有数字分为两组：一组在该位上为 `1`，另一组在该位上为 `0`。

3. **分组异或**：
   - 将 `1` 到 `N` 的所有数字和数组 `nums` 中的所有数字按照 `diff` 位分为两组。
   - 对每组分别进行异或运算，得到缺失的两个数字 `a` 和 `b`。

4. **返回结果**：
   - 返回 `{a, b}`。


### 示例解释
以 `nums = [1]` 为例：

1. **计算所有数字的异或和**：
   - `1` 到 `3` 的异或和：`1 ^ 2 ^ 3 = 0`。
   - 数组 `nums` 的异或和：`1`。
   - `temp = 0 ^ 1 = 1`。

2. **找到区分两个数字的二进制位**：
   - `temp = 1`，二进制表示为 `01`。
   - `diff = 0`（最低位为 `1`）。

3. **分组异或**：
   - 分组：
     - 第 0 位为 `1` 的数字：`1` 和 `3`。
     - 第 0 位为 `0` 的数字：`2`。
   - 异或结果：
     - `a = 2`。
     - `b = 1 ^ 3 = 2`。

4. **最终结果**：
   - `{2, 3}`。

## C++代码
```cpp
class Solution {
public:
    vector<int> missingTwo(vector<int>& nums) {
        int temp = 0;

        // 第一步：计算所有数字的异或和
        for (int i = 1; i <= nums.size() + 2; i++) {
            temp ^= i;
        }
        for (int x : nums) {
            temp ^= x;
        }

        // 第二步：找到区分两个数字的二进制位
        int diff = 0;
        while (1) {
            if ((temp >> diff) & 1 == 1) break;
            diff++;
        }

        // 第三步：分组异或
        int a = 0, b = 0;
        for (int i = 1; i <= nums.size() + 2; i++) {
            if ((i >> diff) & 1 == 1) {
                b ^= i;
            } else {
                a ^= i;
            }
        }
        for (int x : nums) {
            if ((x >> diff) & 1 == 1) {
                b ^= x;
            } else {
                a ^= x;
            }
        }

        // 第四步：返回结果
        return {a, b};
    }
};
```


### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。我们需要遍历数组和数字范围各两次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。
