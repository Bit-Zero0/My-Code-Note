---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-20 16:23
Finish-date: 
Modified-date: 2025-01-20 16:36
Publish: false
---


# 268. 丢失的数字
[268. 丢失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number/)

## 题目描述
给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

**示例 1：**
**输入：** nums = [3,0,1]
**输出：** 2
**解释：**`n = 3`，因为有 3 个数字，所以所有的数字都在范围 `[0,3]` 内。2 是丢失的数字，因为它没有出现在 `nums` 中。

**示例 2：**
**输入：** nums = [0,1]
**输出：** 2
**解释：**`n = 2`，因为有 2 个数字，所以所有的数字都在范围 `[0,2]` 内。2 是丢失的数字，因为它没有出现在 `nums` 中。

**示例 3：**
**输入：** nums = [9,6,4,2,3,5,7,0,1]
**输出：** 8
**解释：**`n = 9`，因为有 9 个数字，所以所有的数字都在范围 `[0,9]` 内。8 是丢失的数字，因为它没有出现在 `nums` 中。

**提示：**
- `n == nums.length`
- `1 <= n <= 104`
- `0 <= nums[i] <= n`
- `nums` 中的所有数字都 **独一无二**

**进阶：** 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

## 解题思路
这道题的核心是利用 **异或运算** 的性质：
1. 任何数和 0 异或，结果是它本身：`a ^ 0 = a`。
2. 任何数和它本身异或，结果是 0：`a ^ a = 0`。
3. 异或运算满足交换律和结合律：`a ^ b ^ a = b`。

我们可以利用这些性质来解决这个问题：
1. 初始化一个变量 `ret` 为 0。
2. 遍历数组 `nums`，将 `ret` 与每个元素异或。
3. 再遍历 `[0, n]` 的所有数，将 `ret` 与每个数异或。
4. 最终 `ret` 的值就是丢失的数字。

**为什么这样做？**
- 假设数组是 `[3, 0, 1]`，完整的范围是 `[0, 1, 2, 3]`。
- 异或运算会将相同的数抵消为 0，最终剩下的就是丢失的数字。

### 算法流程
1. 初始化 `ret = 0`。
2. 遍历数组 `nums`，对每个元素 `num`，执行 `ret ^= num`。
3. 遍历 `[0, n]` 的所有数，对每个数 `i`，执行 `ret ^= i`。
4. 返回 `ret`，即为丢失的数字。

## C++代码
```cpp
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int ret = 0; // 初始化结果为 0

        // 第一次遍历：将 ret 与数组中的每个数异或
        for (int num : nums) {
            ret ^= num; // 异或运算
        }

        // 第二次遍历：将 ret 与 [0, n] 的每个数异或
        for (int i = 0; i <= nums.size(); i++) {
            ret ^= i; // 异或运算
        }

        // 最终 ret 就是丢失的数字
        return ret;
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。我们只需要遍历数组和范围 `[0, n]` 各一次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。