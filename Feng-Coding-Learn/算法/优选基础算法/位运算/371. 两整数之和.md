---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2025-01-20 16:36
Finish-date: 
Modified-date: 2025-01-20 20:01
Publish: false
---


# 371. 两整数之和
[371. 两整数之和](https://leetcode.cn/problems/sum-of-two-integers/)

## 题目描述


## 解题思路
这道题的核心是利用 **位运算** 来实现加法操作：
1. **异或运算 `^`**：本质是「无进位加法」。例如，`1 ^ 1 = 0`，`1 ^ 0 = 1`。
2. **按位与运算 `&`**：可以得到「进位」。例如，`1 & 1 = 1`，`1 & 0 = 0`。
3. **左移运算 `<<`**：将进位左移一位，得到实际的进位值。

通过循环操作：
1. 先计算无进位加法的结果 `x = a ^ b`。
2. 再计算进位 `carry = (a & b) << 1`。
3. 将无进位加法的结果 `x` 和进位 `carry` 作为新的 `a` 和 `b`，继续循环，直到进位为 0。
4. 最终 `a` 就是两数之和。

### 算法流程
1. 初始化 `a` 和 `b` 为输入的两个整数。
2. 循环直到 `b` 为 0：
   - 计算无进位加法的结果 `x = a ^ b`。
   - 计算进位 `carry = (a & b) << 1`。
   - 更新 `a = x`，`b = carry`。
3. 返回 `a`，即为两数之和。

#### 示例解释
以 `a = 5`（二进制 `0101`）和 `b = 3`（二进制 `0011`）为例：
1. 第一次循环：
   - `x = 5 ^ 3 = 6`（二进制 `0110`）。
   - `carry = (5 & 3) << 1 = 1 << 1 = 2`（二进制 `0010`）。
   - 更新 `a = 6`，`b = 2`。
2. 第二次循环：
   - `x = 6 ^ 2 = 4`（二进制 `0100`）。
   - `carry = (6 & 2) << 1 = 2 << 1 = 4`（二进制 `0100`）。
   - 更新 `a = 4`，`b = 4`。
3. 第三次循环：
   - `x = 4 ^ 4 = 0`（二进制 `0000`）。
   - `carry = (4 & 4) << 1 = 4 << 1 = 8`（二进制 `1000`）。
   - 更新 `a = 0`，`b = 8`。
4. 第四次循环：
   - `x = 0 ^ 8 = 8`（二进制 `1000`）。
   - `carry = (0 & 8) << 1 = 0`（二进制 `0000`）。
   - 更新 `a = 8`，`b = 0`。
5. 循环结束，返回 `a = 8`。


## C++代码

```cpp
class Solution {
public:
    int getSum(int a, int b) {
        while (b != 0) { // 循环直到进位为 0
            int x = a ^ b; // 计算无进位加法的结果
            int carry = (a & b) << 1; // 计算进位
            a = x; // 更新 a 为无进位加法的结果
            b = carry; // 更新 b 为进位
        }
        return a; // 返回最终结果
    }
};
```


### 复杂度分析
- **时间复杂度**：`O(1)`，因为整数的位数是固定的（例如 32 位），循环次数最多为 32 次。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。





