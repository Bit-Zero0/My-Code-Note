---
Type: Note
tags:
  - 算法
  - easy
Status: writing
Start-date: 2025-02-23 16:40
Finish-date: 
Modified-date: 2025-02-23 16:48
Publish: false
---


# 1046. 最后一块石头的重量
[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/)

## 题目描述
有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

**示例：**
**输入：**[2,7,4,1,8,1]
**输出：** 1
**解释：**
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。

**提示：**
- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 1000`

## 解题思路

### 问题本质分析

需要动态维护石头的最大重量，并在每次操作后更新剩余石头的集合。核心需求：

1. 1.**快速获取最大元素**：每次操作需要选取当前最重的两个石头。
2. 2.**动态更新集合**：根据碰撞结果调整剩余石头的重量。

### 关键观察

- **最大堆特性**：优先队列（最大堆）能在O(1)时间获取当前最大值，适合快速选取最重石头。
- **操作终止条件**：当堆中元素少于2个时停止操作。

#### 算法流程
#### 核心思路：最大堆（优先队列）

1. **初始化**：将所有石头放入最大堆。
2. **循环处理**：
    - 取出堆顶的两个最大元素。
    - 若两元素不等，将差值重新入堆。
3. **终止条件**：堆中元素少于2个时结束循环。

> [!question]+ 关键点解析
> 1. **堆的特性应用**：
>    - 每次弹出操作保证取到当前最大元素
>    - 自动维护剩余石头的顺序关系
> 
> 2. **边界条件处理**：
>    - 输入为空时直接返回0
>    - 最终堆空时返回0的逻辑
> 
> 3. **碰撞结果处理**：
>    - 仅当 `first > second` 时产生新碎片
>    - 差值重新入堆参与后续碰撞
> 


### 完整代码及注释
```cpp
#include <vector>
#include <queue>
using namespace std;

class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        // 创建最大堆（优先队列默认是最大堆）
        priority_queue<int> heap;

        // 将所有石头放入堆中，初始化 O(n log n)
        for (int& x : stones) {
            heap.push(x);
        }

        // 循环处理直到堆中最多剩1个元素
        while (heap.size() > 1) {
            // 取出当前最大的两块石头
            int first = heap.top(); 
            heap.pop();
            int second = heap.top();
            heap.pop();

            // 处理碰撞后的碎片（仅当有剩余时重新入堆）
            if (first > second) {
                heap.push(first - second);
            }
        }

        // 返回最终结果（堆空返回0，否则返回剩余值）
        return heap.empty() ? 0 : heap.top();
    }
};
```

---

### 复杂度分析

- **时间复杂度**：O(n log n)  
    每个元素最多被插入和删除两次，每次堆操作的时间复杂度为O(log n)，总时间复杂度为O(n log n)。
- **空间复杂度**：O(n)  
    堆中最多存储所有n个元素。
