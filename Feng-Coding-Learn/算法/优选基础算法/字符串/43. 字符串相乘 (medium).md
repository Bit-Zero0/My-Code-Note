---
Type: Note
tags:
  - 算法
  - CPP
  - medium
Status: writing
Start-date: 2025-02-20 21:53
Finish-date: 
Modified-date: 2025-02-20 22:09
Publish: false
---


# 43. 字符串相乘
[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

## 题目描述
给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：** 不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

**示例 1:**
**输入:** num1 = "2", num2 = "3"
**输出:** "6"

**示例 2:**
**输入:** num1 = "123", num2 = "456"
**输出:** "56088"

**提示：**
- `1 <= num1.length, num2.length <= 200`
- `num1` 和 `num2` 只能由数字组成。
- `num1` 和 `num2` 都不包含任何前导零，除了数字0本身。

## 解题思路
整体思路就是模拟我们小学**列竖式**计算两个数相乘的过程。但是为了我们书写代码的方便性，我们选择一种优化版本的，就是在**计算两数相乘的时候，先不考虑进位，等到所有结果计算完毕之后，再去考虑进位**。

### 关键点解析
1. **索引位置计算**：`num1[i] * num2[j]`的结果应存储在`i+j`的位置，这符合竖式乘法的位权规则
2. **延迟进位处理**：先累加所有乘积再统一处理进位，简化计算逻辑
3. **反转操作的意义**：
   - 原始字符串高位在前，但计算需要从低位开始
   - 反转后字符串低位在数组头部，方便顺序处理

### 特殊情况处理
- 当任意一个输入为"0"时，结果必为"0"
- 处理乘积为0时的前导零问题
- 处理最高位进位的情况（如`99*99=9801`）


### 算法流程

1. **反转字符串**：将两个输入字符串反转，方便从最低位开始计算（模拟手工竖式乘法）
2. **创建临时数组**：长度为m+n（两数长度之和），用于存储各位相乘的累加结果
3. **双重循环计算乘积**：
   - 遍历两个数的每一位进行相乘
   - 将乘积结果累加到临时数组对应的i+j位置
4. **统一处理进位**：
   - 从低位到高位依次处理进位
   - 每位保留个位数字，进位传递到下一位
5. **处理前导零**：
   - 去除结果字符串末尾多余的零（反转前是前导零）
   - 保证至少保留一个零（当结果为0时）
6. **反转结果字符串**：得到最终的正确顺序


## C++代码

```cpp
class Solution {
public:
    string multiply(string num1, string num2) {
        // 反转字符串方便从低位开始计算
        reverse(num1.begin(), num1.end());
        reverse(num2.begin(), num2.end());

        // 临时数组存储各位乘积之和，长度最多为m+n
        vector<int> temp(num1.size() + num2.size());
        for(int i = 0; i < num1.size(); i++) {
            for(int j = 0; j < num2.size(); j++) {
                // 关键步骤：将乘积累加到i+j的位置
                temp[i+j] += (num1[i] - '0') * (num2[j] - '0');
            }
        }

        int carry = 0;
        string result;
        // 处理进位和构建结果字符串
        for(int i = 0; i < temp.size() || carry;) {
            if(i < temp.size()) carry += temp[i++];
            result += carry % 10 + '0';  // 取个位
            carry /= 10;  // 计算进位
        }

        // 去除前导零（至少保留一个零）
        while(result.size() > 1 && result.back() == '0') result.pop_back();
        
        reverse(result.begin(), result.end());
        return result;
    }
};
```


### **复杂度分析**

- **时间复杂度**：O(mn)，其中 m 和 n 为输入字符串的长度。遍历所有位相乘。
- **空间复杂度**：O(m+n)，存储 `temp` 数组和结果字符串。