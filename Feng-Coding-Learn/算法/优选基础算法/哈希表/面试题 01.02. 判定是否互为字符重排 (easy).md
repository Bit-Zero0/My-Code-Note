---
Type: Note
tags:
  - 算法
  - CPP
Status: writing
Start-date: 2025-02-19 21:17
Finish-date: 
Modified-date: 2025-02-19 21:49
Publish: false
---


# 面试题 01.02. 判定是否互为字符重排 (easy)
[面试题 01.02. 判定是否互为字符重排](https://leetcode.cn/problems/check-permutation-lcci/)

## 题目描述
给定两个由小写字母组成的字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**
**输入:** `s1` = "abc", `s2` = "bca"
**输出:** true 

**示例 2：**
**输入:** `s1` = "abc", `s2` = "bad"
**输出:** false

**说明：**
- `0 <= len(s1) <= 100`
- `0 <= len(s2) <= 100`


## 解题思路

### 问题本质分析
要判断两个字符串是否为字符重排，本质是验证两个条件：
1. 字符集合完全相同（不存在对方没有的字符）
2. 每个字符的出现次数严格一致

### 算法选择依据
选择哈希表法的核心优势：
- **O(1)时间复杂度访问**：数组直接寻址比红黑树/哈希表更快
- **空间预分配**：固定26个元素的数组空间（小写字母场景）
- **即时验证机制**：在遍历s2时即可实时发现不匹配情况


### 算法设计思路
1. **长度优先校验**：长度不同直接返回false
2. **哈希数组计数**：使用长度26的数组模拟哈希表（小写字母专用）
3. **双向抵消策略**：
    - 正向遍历s1时增加计数
    - 遍历s2时减少计数并实时校验

### 详细步骤解析
1. **前置校验阶段**
   ```cpp
   if(s1.size() != s2.size()) return false;
   ```
   - 必要性：长度不等时字符数量必然不同
   - 复杂度优化：避免后续无效计算
   - 边界情况：处理空字符串场景（两个空字符串返回true）

2. **哈希表初始化**
   ```cpp
   int hash[26] = {0}; // 显式初始化为全0
   ```
   - 内存安全：未初始化数组可能包含随机值导致计算错误
   - 空间分配：连续内存访问效率高
   - 局限性：仅适用于纯小写字母场景（ASCII 97-122）

3. **正向统计阶段**
   ```cpp
   for(int i=0; i<s1.size(); i++) 
       hash[s1[i]-'a']++;
   ```
   - 字符映射：通过`字符 - 'a'`将ASCII码转换为0-25的索引
     - 例：'a'→0，'b'→1，...，'z'→25
   - 频率记录：每个索引位置存储对应字符的出现次数

4. **反向验证阶段**
   ```cpp
   for(int i=0; i<s2.size(); i++){
       hash[s2[i]-'a']--;
       if(hash[s2[i]-'a'] < 0) 
           return false;
   }
   ```
   - **实时检测机制**：递减后立即检查负数
     - 负数出现的三种可能：
       1. s2包含s1没有的字符（对应位置初始为0）
       2. s2中某字符出现次数超过s1
   - **提前终止**：发现第一个不匹配立即返回，避免无效计算

5. **最终验证**
   ```cpp
   return true;
   ```
   - 隐含条件：所有字符计数刚好归零
   - 无需二次遍历验证：因长度相等且无负数，剩余计数必为0


## 代码及注释
```cpp
class Solution {
public:
    bool CheckPermutation(string s1, string s2) {
        // 边界条件：长度不同直接返回false
        if(s1.size() != s2.size())
            return false;
        
        int hash[26] = {0}; // 初始化哈希数组（修正：添加初始化）
        // 统计s1字符出现次数
        for(int i = 0 ; i < s1.size() ; i++) {
            hash[s1[i] - 'a']++; // 只处理小写字母
        }
        
        // 验证s2字符组成
        for(int i = 0 ; i < s2.size() ; i++) {
            hash[s2[i] - 'a']--;
            // 出现负数说明字符数量不匹配
            if(hash[s2[i] - 'a'] < 0)
                return false;
        }

        return true;
    }
};
```

### 关键问题解答
**Q1：为什么不用两次完整遍历？**  
A：采用"统计+验证"模式而非"统计+二次统计+比较"：
- 减少一次完整遍历
- 内存访问局部性更好
- 提前发现错误能力


### 复杂度深度分析
- 时间复杂度：O(n)
  - 2次独立遍历：O(n) + O(n) = O(2n) → 简化为O(n)
  - 常数项说明：每个循环内部只有算术和比较操作
- 空间复杂度：O(1)
  - 固定空间：26个int（通常为104字节）
  - 与输入规模无关：空间消耗不随n增大而改变



