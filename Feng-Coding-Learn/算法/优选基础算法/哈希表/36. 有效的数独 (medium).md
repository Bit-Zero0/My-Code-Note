---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-03-13 22:24
Finish-date: 
Modified-date: 2025-03-13 22:31
Publish: false
---


# 36. 有效的数独
[36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)

## 题目描述
请你判断一个 `9 x 9` 的数独是否有效。只需要 **根据以下规则** ，验证已经填入的数字是否有效即可。
1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

**注意：**
- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 空白格用 `'.'` 表示。

**示例 1：**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png)
**输入：** board = 
```
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```
**输出：** true

**示例 2：**
**输入：** board = 
```
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
```
**输出：** false
**解释：** 除了第一行的第一个数字从 **5** 改为 **8** 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。

**提示：**
- `board.length == 9`
- `board[i].length == 9`
- `board[i][j]` 是一位数字（`1-9`）或者 `'.'`

## 解题思路

**空间换时间 + 哈希表思想**  
**核心思路**：  
通过三个二维数组分别记录每行、每列和每个小九宫格中数字的出现情况，遍历整个数独时实时检查是否重复。

**具体步骤**：
1. **定义三个布尔数组**：
   - `checkRow[i][num]`：表示第 `i` 行中数字 `num` 是否已经出现。
   - `checkCol[j][num]`：表示第 `j` 列中数字 `num` 是否已经出现。
   - `checkGrip[i / 3][j / 3][num]`：表示第 `i / 3` 行第 `j / 3` 列的小九宫格中数字 `num` 是否已经出现。
2. **遍历每个单元格**：
   - 若当前单元格为 `.`（空白），跳过。
   - 否则，将字符转换为数字 `num`，检查三个数组中对应的位置是否为 `true`。
   - 若任意一个数组对应的位置为 `true`，说明重复，返回 `false`。
   - 否则，将三个数组对应的位置标记为 `true`。
3. **遍历结束后返回 `true`**。

**关键点**：
- **小九宫格的索引计算**：通过 `i / 3` 和 `j / 3` 确定当前单元格属于哪个小九宫格（共 3x3 个）。
- **实时检查**：在遍历过程中立即检查重复，避免后续无效操作。

> [!question]+ 常见疑问解答
> - **为什么使用数组而不是哈希表？**  
>   由于数独的大小固定且数字范围较小（1-9），数组的访问效率更高，且无需处理哈希冲突。
> 
> - **如何处理小九宫格的索引？**  
>   每个小九宫格的行索引为 `i / 3`，列索引为 `j / 3`，例如：
>   - `i=0,1,2` → `x=0`（第一行小九宫格）
>   - `i=3,4,5` → `x=1`（第二行小九宫格）
>   - `i=6,7,8` → `x=2`（第三行小九宫格）
>   列同理。
> 
> - **是否需要处理输入为空的情况？**  
>   根据题目描述，输入保证是 9x9 的数独，因此无需额外处理。



## 代码实现
```cpp
class Solution {
    // 定义三个全局数组，分别记录行、列、小九宫格中的数字出现情况
    bool checkRow[9][10];  // checkRow[i][num]：第i行是否存在数字num（num范围1-9）
    bool checkCol[9][10];  // checkCol[j][num]：第j列是否存在数字num
    bool checkGrip[3][3][10]; // checkGrip[x][y][num]：第x行第y列的小九宫格是否存在数字num

public:
    bool isValidSudoku(vector<vector<char>>& board) {
        // 初始化数组为false（全局数组默认初始化为false）
        // 遍历整个数独
        for (int i = 0; i < 9; ++i) {
            for (int j = 0; j < 9; ++j) {
                if (board[i][j] == '.') { // 跳过空白格
                    continue;
                }
                int num = board[i][j] - '0'; // 转换字符为数字（1-9）
                // 计算小九宫格的索引（x,y）
                int x = i / 3;
                int y = j / 3;
                // 检查是否重复
                if (checkRow[i][num] || checkCol[j][num] || checkGrip[x][y][num]) {
                    return false;
                }
                // 标记当前数字已出现
                checkRow[i][num] = true;
                checkCol[j][num] = true;
                checkGrip[x][y][num] = true;
            }
        }
        return true;
    }
};
```

### **复杂度分析**
- **时间复杂度**：O(1)，数独的大小固定为 9x9，遍历次数固定。
- **空间复杂度**：O(1)，三个数组的大小均为固定值（9x9x9）。



