---
Type: Note
tags:
  - 算法
  - CPP
  - easy
Status: writing
Start-date: 2025-02-19 20:54
Finish-date: 
Modified-date: 2025-02-19 21:17
Publish: false
---


# 1. 两数之和
[1. 两数之和](https://leetcode.cn/problems/two-sum/)

## 题目描述
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**
**输入：** nums = [2,7,11,15], target = 9
**输出：**[0,1]
**解释：** 因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

**示例 2：**
**输入：** nums = [3,2,4], target = 6
**输出：**[1,2]

**示例 3：**
**输入：** nums = [3,3], target = 6
**输出：**[0,1]

**提示：**
- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

## 解题思路

### 算法设计思路
1. **哈希表映射**：用哈希表存储 `<数值, 索引>` 的映射关系，实现O(1)查找。  
2. **单次遍历策略**：遍历时动态维护哈希表，同时检查是否存在互补数。  
3. **逆向思维**：寻找 `target - nums[i]` 而非直接配对。


### 关键问题深度剖析
1. 为什么哈希表不预先存储所有元素？
	- **避免元素重复使用**：若先构建完整哈希表再查找，可能遇到 `nums[i] == target/2` 的特殊情况导致错误。例如 `nums=[3,3], target=6`，若预先存储，第二个3会覆盖第一个3的索引，导致无法找到正确解。

2. 如何处理元素顺序？
	- **自然保证顺序**：由于遍历时先存储前面的元素，当后续发现互补数时，哈希表中存储的索引一定比当前索引小，因此直接返回 `{hash[x], i}` 即可满足顺序要求。

 3. 为什么选择 `unordered_map`？
	- **哈希表特性**：`unordered_map` 基于哈希桶实现，查找时间复杂度为O(1)，而 `map` 基于红黑树实现，查找为O(logn)。本题需要最大化效率。


### 边界情况分析
1. **最小输入**：`nums = [0,0], target = 0` → 返回 `[0,1]`  
2. **负数处理**：`nums = [-1,2], target = 1` → 返回 `[0,1]`  
3. **大数测试**：`nums = [9999999,1], target = 10000000` → 正确处理


### 算法逻辑
（以 `nums = [2,7,11,15], target = 9` 为例）

阶段1：初始化哈希表
```cpp
unordered_map<int, int> hash; // 初始为空
```

阶段2：遍历数组元素
**i=0时（nums[0]=2）**：  
1. 计算互补数 `x = 9 - 2 = 7`  
2. 检查哈希表中是否存在7 → 不存在  
3. 将当前值存入哈希表：`hash[2] = 0`  
**哈希表状态**：`{2:0}`

**i=1时（nums[1]=7）**：  
1. 计算互补数 `x = 9 - 7 = 2`  
2. 检查哈希表中是否存在2 → 存在（对应索引0）  
3. 立即返回 `{0, 1}`



## 代码及注释
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 创建哈希表，存储<数值, 索引>映射
        unordered_map<int, int> hash;

        for(int i = 0; i < nums.size(); i++) {
            int x = target - nums[i]; // 计算当前元素需要的互补数
            
            // 检查互补数是否已存在于哈希表中
            if(hash.count(x)) { // hash.count(x) 返回是否存在x的键
                return {hash[x], i}; // 找到解，立即返回
            }
            
            // 若未找到，将当前数值与索引存入哈希表（延迟存储避免自重复）
            hash[nums[i]] = i;
        }
        
        // 题目保证有解，此处仅为语法需要
        return {-1, -1}; 
    }
};
```


### 复杂度分析
时间复杂度
- **O(n)**：最坏情况下遍历n个元素，每次哈希表操作均为O(1)。
空间复杂度
- **O(n)**：哈希表最多存储n个元素。


