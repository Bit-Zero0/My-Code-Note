---
Type: Note
tags:
  - 算法
  - easy
Status: writing
Start-date: 2025-02-24 16:06
Finish-date: 
Modified-date: 2025-03-15 14:20
Publish: false
---


# 733. 图像渲染
[733. 图像渲染](https://leetcode.cn/problems/flood-fill/)

## 题目描述
有一幅以 `m x n` 的二维整数数组表示的图画 `image` ，其中 `image[i][j]` 表示该图画的像素值大小。你也被给予三个整数 `sr` ,  `sc` 和 `color` 。你应该从像素 `image[sr][sc]` 开始对图像进行上色 **填充** 。

为了完成 **上色工作**：

1. 从初始像素开始，将其颜色改为 `color`。
2. 对初始坐标的 **上下左右四个方向上** 相邻且与初始像素的原始颜色同色的像素点执行相同操作。
3. 通过检查与初始像素的原始颜色相同的相邻像素并修改其颜色来继续 **重复** 此过程。
4. 当 **没有** 其它原始颜色的相邻像素时 **停止** 操作。

最后返回经过上色渲染 **修改** 后的图像 。
**示例 1:**
![](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)
**输入：** image = `[[1,1,1],[1,1,0],[1,0,1]]`，sr = 1, sc = 1, color = 2
**输出：** `[[2,2,2],[2,2,0],[2,0,1]]`
**解释：** 在图像的正中间，坐标 `(sr,sc)=(1,1)` （即红色像素）,在路径上所有符合条件的像素点的颜色都被更改成相同的新颜色（即蓝色像素）。

>注意，右下角的像素 **没有** 更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。


**示例 2:**
**输入：** image = `[[0,0,0],[0,0,0]]`, sr = 0, sc = 0, color = 0
**输出：** `[[0,0,0],[0,0,0]]`
**解释：** 初始像素已经用 0 着色，这与目标颜色相同。因此，不会对图像进行任何更改。

**提示:**
- `m == image.length`
- `n == image[i].length`
- `1 <= m, n <= 50`
- `0 <= image[i][j], color < 216`
- `0 <= sr < m`
- `0 <= sc < n`

## 解题思路（BFS）

**图像渲染（FloodFill算法）**  
本题要求将二维图像中与起始点 `(sr, sc)` 颜色相同且连通的区域，全部修改为目标颜色 `color`。采用广度优先搜索（BFS）算法，核心思想是：**从起点出发，逐层向外扩散，将所有符合条件的相邻像素染色**。具体步骤如下：


### 问题分析
- **输入**：二维图像矩阵 `image`，起始坐标 `(sr, sc)`，目标颜色 `color`。
- **输出**：修改后的图像矩阵。
- **关键约束**：仅修改与起点颜色相同且连通的区域，若起点颜色等于目标颜色则直接返回原图。


### 详细步骤
1. **初始判断**  
   - 若起点颜色 `image[sr][sc]` 等于目标颜色 `color`，直接返回原图，避免无效操作。

2. **记录原始颜色**  
   - 保存起点原始颜色 `preColor`，后续仅处理与此颜色相同的像素。

3. **初始化队列**  
   - 将起点 `(sr, sc)` 加入队列，作为BFS的初始节点。

4. **BFS遍历**  
   - 循环取出队列中的节点，将其颜色修改为 `color`。
   - 检查该节点的四个方向（上、下、左、右）：
     - 若相邻像素在矩阵范围内且颜色为 `preColor`，则加入队列。

5. **终止条件**  
   - 队列为空时，所有连通区域处理完毕，返回修改后的图像。

> [!tip]+ 关键点说明
> 1. **颜色相同判断**：  
>    初始判断 `image[sr][sc] == color` 避免无限循环和重复操作。
> 2. **染色即标记**：  
>    修改像素颜色后，该像素相当于被标记为已访问，无需额外空间记录状态。
> 3. **方向遍历技巧**：  
>    使用方向数组 `dx/dy` 简化代码，避免手动枚举四个方向。
> 4. **边界检查**：  
>    确保新坐标 `(x, y)` 在矩阵范围内，防止越界访问。


## 代码实现
```cpp
class Solution {
    typedef pair<int, int> PairII;  // 定义坐标对类型

    // 方向数组：上下左右四个方向的坐标偏移量
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        // 若起点颜色已为目标颜色，无需处理
        if (image[sr][sc] == color) 
            return image;

        int preColor = image[sr][sc];  // 记录原始颜色
        queue<PairII> queue;           // 初始化BFS队列
        queue.push({sr, sc});          // 起点入队

        while (!queue.empty()) {
            auto [a, b] = queue.front();  // 取出队首坐标
            queue.pop();
            image[a][b] = color;          // 修改当前像素颜色

            // 遍历四个方向
            for (int i = 0; i < 4; i++) {
                int x = a + dx[i], y = b + dy[i];
                // 检查新坐标是否合法且颜色为原始颜色
                if (x >= 0 && x < image.size() && 
                    y >= 0 && y < image[0].size() && 
                    image[x][y] == preColor) {
                    queue.push({x, y});    // 合法像素入队
                }
            }
        }

        return image;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(mn)  
  最坏情况下需要遍历整个矩阵，其中 `m` 和 `n` 分别为矩阵的行数和列数。
- **空间复杂度**：O(mn)  
  队列可能存储最多所有像素的坐标，例如整个矩阵颜色相同的情况。


## DFS解法
本题是一个经典的图像填充问题，也可以理解为连通分量的染色问题，使用深度优先搜索（DFS）算法可以很好地解决。其核心思想是从给定的起始点开始，将与该起始点颜色相同且相连通的所有像素点的颜色都替换为目标颜色。


1. **确定初始状态**：记录起始点的原始颜色 `preColor`，若与新颜色相同则直接返回。
2. **DFS递归填充**：从起始点出发，向四个方向递归填充颜色。
3. **终止条件**：当前位置超出边界或颜色与 `preColor` 不同时停止递归。

### 关键步骤
1. **初始化检查**：若起始点颜色等于目标颜色，无需处理。
2. **DFS递归**：将当前点颜色修改为新颜色，递归处理四个相邻点。
3. **边界与合法性检查**：确保移动后的位置在矩阵范围内且颜色为 `preColor`。

### 具体步骤
1. **边界检查**：
    - 在 `floodFill` 函数中，首先检查起始点 `(sr, sc)` 的颜色是否已经等于目标颜色 `color`。如果相等，说明不需要进行填充操作，直接返回原图像。
2. **初始化参数**：
    - 获取图像的行数 `m` 和列数 `n`。
    - 记录起始点的原始颜色 `preColor`，后续在填充过程中，只有颜色与 `preColor` 相同的像素点才会被填充。
3. **深度优先搜索（DFS）**：
    - 调用 `dfs` 函数从起始点 `(sr, sc)` 开始进行深度优先搜索。
    - 在 `dfs` 函数中，将当前位置 `(i, j)` 的颜色修改为目标颜色 `color`。
    - 遍历当前位置的四个相邻位置（上、下、左、右），通过 `dx` 和 `dy` 数组来实现。
    - 对于每个相邻位置 `(x, y)`，检查其是否在图像范围内（即 `x >= 0 && x < m && y >= 0 && y < n`），并且颜色是否与起始点的原始颜色 `preColor` 相同。
    - 如果满足条件，则递归调用 `dfs` 函数对该相邻位置进行填充操作。

```cpp
class Solution {
    int preColor; // 初始颜色
    int m, n;     // 图像的行列数
    int dx[4] = {0, 0, 1, -1}; // 右、左、下、上
    int dy[4] = {1, -1, 0, 0};

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        if (image[sr][sc] == color) return image; // 颜色相同无需处理
        m = image.size();
        n = image[0].size();
        preColor = image[sr][sc]; // 保存初始颜色
        
        dfs(image, sr, sc, color); // 从起点开始DFS
        
        return image;
    }

    void dfs(vector<vector<int>>& image, int i, int j, int color) {
        image[i][j] = color; // 修改当前点颜色
        
        // 遍历四个方向
        for (int k = 0; k < 4; ++k) {
            int x = i + dx[k], y = j + dy[k];
            // 检查新坐标合法性及颜色是否匹配原颜色
            if (x >= 0 && x < m && y >= 0 && y < n && image[x][y] == preColor) {
                dfs(image, x, y, color); // 递归处理相邻点
            }
        }
    }
};
```


- **时间复杂度**：O(m×n)，其中 m 是图像的行数，n 是图像的列数。在最坏情况下，需要遍历图像中的所有像素点。
- **空间复杂度**：O(m×n)，主要是递归调用栈的空间开销。在最坏情况下，递归的深度可能达到图像的所有像素点。