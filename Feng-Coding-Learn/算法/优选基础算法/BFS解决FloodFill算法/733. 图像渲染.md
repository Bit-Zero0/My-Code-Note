---
Type: Note
tags:
  - 算法
Status: writing
Start-date: 2025-02-24 16:06
Finish-date: 
Modified-date: 2025-03-03 22:25
Publish: false
---


# 733. 图像渲染
[733. 图像渲染](https://leetcode.cn/problems/flood-fill/)

## 题目描述
有一幅以 `m x n` 的二维整数数组表示的图画 `image` ，其中 `image[i][j]` 表示该图画的像素值大小。你也被给予三个整数 `sr` ,  `sc` 和 `color` 。你应该从像素 `image[sr][sc]` 开始对图像进行上色 **填充** 。

为了完成 **上色工作**：

1. 从初始像素开始，将其颜色改为 `color`。
2. 对初始坐标的 **上下左右四个方向上** 相邻且与初始像素的原始颜色同色的像素点执行相同操作。
3. 通过检查与初始像素的原始颜色相同的相邻像素并修改其颜色来继续 **重复** 此过程。
4. 当 **没有** 其它原始颜色的相邻像素时 **停止** 操作。

最后返回经过上色渲染 **修改** 后的图像 。
**示例 1:**
![](https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg)
**输入：** image = `[[1,1,1],[1,1,0],[1,0,1]]`，sr = 1, sc = 1, color = 2
**输出：** `[[2,2,2],[2,2,0],[2,0,1]]`
**解释：** 在图像的正中间，坐标 `(sr,sc)=(1,1)` （即红色像素）,在路径上所有符合条件的像素点的颜色都被更改成相同的新颜色（即蓝色像素）。

>注意，右下角的像素 **没有** 更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。


**示例 2:**
**输入：** image = `[[0,0,0],[0,0,0]]`, sr = 0, sc = 0, color = 0
**输出：** `[[0,0,0],[0,0,0]]`
**解释：** 初始像素已经用 0 着色，这与目标颜色相同。因此，不会对图像进行任何更改。

**提示:**
- `m == image.length`
- `n == image[i].length`
- `1 <= m, n <= 50`
- `0 <= image[i][j], color < 216`
- `0 <= sr < m`
- `0 <= sc < n`

## 解题思路（FloodFill算法）

**图像渲染（FloodFill算法）**  
本题要求将二维图像中与起始点 `(sr, sc)` 颜色相同且连通的区域，全部修改为目标颜色 `color`。采用广度优先搜索（BFS）算法，核心思想是：**从起点出发，逐层向外扩散，将所有符合条件的相邻像素染色**。具体步骤如下：


#### 1. 问题分析
- **输入**：二维图像矩阵 `image`，起始坐标 `(sr, sc)`，目标颜色 `color`。
- **输出**：修改后的图像矩阵。
- **关键约束**：仅修改与起点颜色相同且连通的区域，若起点颜色等于目标颜色则直接返回原图。



#### 2. 算法选择：BFS
- **为什么选择BFS**：  
  BFS按层遍历，天然适合模拟“洪水扩散”过程，确保所有相邻像素被依次处理。
- **与DFS对比**：  
  DFS通过递归或栈实现，可能因递归深度过大导致栈溢出，而BFS队列操作更安全可控。



#### 3. 详细步骤
1. **初始判断**  
   - 若起点颜色 `image[sr][sc]` 等于目标颜色 `color`，直接返回原图，避免无效操作。

2. **记录原始颜色**  
   - 保存起点原始颜色 `preColor`，后续仅处理与此颜色相同的像素。

3. **初始化队列**  
   - 将起点 `(sr, sc)` 加入队列，作为BFS的初始节点。

4. **BFS遍历**  
   - 循环取出队列中的节点，将其颜色修改为 `color`。
   - 检查该节点的四个方向（上、下、左、右）：
     - 若相邻像素在矩阵范围内且颜色为 `preColor`，则加入队列。

5. **终止条件**  
   - 队列为空时，所有连通区域处理完毕，返回修改后的图像。

> [!tip]+ 关键点说明
> 1. **颜色相同判断**：  
>    初始判断 `image[sr][sc] == color` 避免无限循环和重复操作。
> 2. **染色即标记**：  
>    修改像素颜色后，该像素相当于被标记为已访问，无需额外空间记录状态。
> 3. **方向遍历技巧**：  
>    使用方向数组 `dx/dy` 简化代码，避免手动枚举四个方向。
> 4. **边界检查**：  
>    确保新坐标 `(x, y)` 在矩阵范围内，防止越界访问。


## 代码实现
```cpp
class Solution {
    typedef pair<int, int> PairII;  // 定义坐标对类型

    // 方向数组：上下左右四个方向的坐标偏移量
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        // 若起点颜色已为目标颜色，无需处理
        if (image[sr][sc] == color) 
            return image;

        int preColor = image[sr][sc];  // 记录原始颜色
        queue<PairII> queue;           // 初始化BFS队列
        queue.push({sr, sc});          // 起点入队

        while (!queue.empty()) {
            auto [a, b] = queue.front();  // 取出队首坐标
            queue.pop();
            image[a][b] = color;          // 修改当前像素颜色

            // 遍历四个方向
            for (int i = 0; i < 4; i++) {
                int x = a + dx[i], y = b + dy[i];
                // 检查新坐标是否合法且颜色为原始颜色
                if (x >= 0 && x < image.size() && 
                    y >= 0 && y < image[0].size() && 
                    image[x][y] == preColor) {
                    queue.push({x, y});    // 合法像素入队
                }
            }
        }

        return image;
    }
};
```

### 复杂度分析
- **时间复杂度**：O(mn)  
  最坏情况下需要遍历整个矩阵，其中 `m` 和 `n` 分别为矩阵的行数和列数。
- **空间复杂度**：O(mn)  
  队列可能存储最多所有像素的坐标，例如整个矩阵颜色相同的情况。

