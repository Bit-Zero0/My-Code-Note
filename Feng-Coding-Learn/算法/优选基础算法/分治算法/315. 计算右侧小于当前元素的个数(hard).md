---
Type: Note
tags:
  - 算法
  - CPP
  - hard
Status: writing
Start-date: 2025-01-25 21:12
Finish-date: 
Modified-date: 2025-01-25 21:29
Publish: false
---


# 315. 计算右侧小于当前元素的个数
[315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/)

## 题目描述
给你一个整数数组 `nums` ，按要求返回一个新数组 `counts` 。数组 `counts` 有该性质： `counts[i]` 的值是  `nums[i]` 右侧小于 `nums[i]` 的元素的数量。

**示例 1：**
**输入：**nums = [5,2,6,1]
**输出：**`[2,1,1,0]  **解释：**`
5 的右侧有 **2** 个更小的元素 (2 和 1)
2 的右侧仅有 **1** 个更小的元素 (1)
6 的右侧有 **1** 个更小的元素 (1)
1 的右侧有 **0** 个更小的元素

**示例 2：**
**输入：** nums = [-1]
**输出：**[0]

**示例 3：**
**输入：** nums = [-1,-1]
**输出：**[0,0]

**提示：**
- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

## 解题思路
### **解题思路**

#### **问题背景**
题目要求计算数组中每个元素右侧小于当前元素的个数。这是一个经典的算法问题，通常可以通过**归并排序**来解决。归并排序不仅能够对数组进行排序，还可以在排序过程中统计每个元素右侧小于它的元素数量。

#### **关键点分析**
![[315. 计算右侧小于当前元素的个数 2025-01-25 21.15.42.excalidraw]]
#### **关键点分析**
1. **问题的难点**
    - **直接遍历的低效性**：直接遍历数组计算每个元素右侧小于它的元素数量的时间复杂度为 **O(n^2)**，对于大规模数据效率较低。
    - **归并排序的应用**：使用归并排序可以在 **O(n log n)** 的时间复杂度内解决问题。
    - **找到当前元素的原始下标**：在归并排序过程中，需要记录每个元素的原始下标，以便正确更新结果。
2. **归并排序的应用**
    - 归并排序是一种分治算法，通过递归地将数组分为两部分，分别排序后再合并。
    - 在合并过程中，可以统计每个元素右侧小于它的元素数量。
3. **合并过程中的统计**
    - 在合并两个有序数组时，如果左半部分的当前元素大于右半部分的当前元素，则说明左半部分中当前元素及其之后的所有元素都大于右半部分的当前元素。
    - 因此，右半部分的当前元素及其之后的所有元素都小于左半部分的当前元素，可以统计逆序对的数量。
4. **辅助数组的使用**
    - 使用一个辅助数组 `temp`，在合并过程中存储合并后的结果。
    - 使用一个索引数组 `index`，记录每个元素在原始数组中的位置，以便在合并过程中更新结果。
5. **找到当前元素的原始下标**
    - 在归并排序过程中，使用索引数组 `index` 来记录每个元素的原始下标。
    - 在合并过程中，通过索引数组更新结果数组 `result`，确保每个元素的统计结果与原始下标对应。

#### **难点应对**
1. **如何高效统计每个元素右侧小于它的元素数量？**
    - 在归并排序的合并过程中，通过双指针法统计每个元素右侧小于它的元素数量，时间复杂度为 **O(n log n)**。

2. **如何避免重复计算？**
    - 使用递归分治的方法，将数组分为两部分，分别统计每个元素右侧小于它的元素数量，最后合并结果。

3. **如何处理边界条件？**
    - 递归的终止条件是当数组的长度为1时，此时数组已经是有序的，右侧小于它的元素数量为0。

4. **如何找到当前元素的原始下标？**
    - 使用索引数组 `index`，在归并排序过程中记录每个元素的原始下标。
    - 在合并过程中，通过索引数组更新结果数组 `result`，确保每个元素的统计结果与原始下标对应。


### 算法流程
1. **初始化：**
    - 初始化结果数组 `result`，大小与输入数组 `nums` 相同，所有值初始化为 `0`。
    - 初始化索引数组 `index`，记录每个元素在原始数组中的位置。
    - 定义归并排序函数 `mergerSort`，接收数组、左边界和右边界作为参数。
2. **递归划分：**
    - 如果区间无效（`left >= right`），直接返回。
    - 计算中间位置 `mid`，将数组分为两部分。
    - 递归地对左半部分和右半部分进行排序，并统计每个元素右侧小于它的元素数量。
3. **合并过程：**
    - 使用两个指针 `cur1` 和 `cur2`，分别指向左半部分和右半部分的起始位置。
    - 比较两个指针所指的元素，将较小的元素放入 `temp` 中，并移动相应的指针。
    - 如果左半部分的当前元素大于右半部分的当前元素，则统计右半部分的当前元素及其之后的所有元素数量，并更新结果数组。
    - 最后，将 `temp` 中的元素复制回原数组的相应位置。
4. **返回结果：**
    - 返回结果数组 `result`。

## C++代码

```cpp
class Solution {
    vector<int> result;  // 用于存储每个元素右侧小于它的元素数量
    vector<int> index;   // 用于记录每个元素在原始数组中的位置
    int temp[500010];    // 辅助数组，用于合并过程
    int tempIndex[500010];  // 辅助索引数组，用于合并过程

public:
    vector<int> countSmaller(vector<int>& nums) {
        int n = nums.size();  // 获取数组的大小
        result.resize(n, 0);  // 初始化结果数组，所有值为0
        index.resize(n);      // 初始化索引数组

        // 初始化索引数组，记录每个元素在原始数组中的位置
        for (int i = 0; i < n; i++) {
            index[i] = i;
        }

        // 调用归并排序函数
        mergerSort(nums, 0, n - 1);

        return result;  // 返回结果数组
    }

    void mergerSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;  // 如果区间无效，直接返回

        int mid = (left + right) >> 1;  // 计算中间位置
        mergerSort(nums, left, mid);  // 递归排序左半部分
        mergerSort(nums, mid + 1, right);  // 递归排序右半部分

        int cur1 = left, cur2 = mid + 1, i = 0;  // 初始化指针
        // 合并两个有序数组
        while (cur1 <= mid && cur2 <= right) {
            if (nums[cur1] <= nums[cur2]) {
                // 如果左半部分的当前元素小于等于右半部分的当前元素
                temp[i] = nums[cur2];
                tempIndex[i++] = index[cur2++];
            } else {
                // 如果左半部分的当前元素大于右半部分的当前元素
                result[index[cur1]] += right - cur2 + 1;  // 统计右侧小于当前元素的数量
                temp[i] = nums[cur1];
                tempIndex[i++] = index[cur1++];
            }
        }

        // 处理剩余的左半部分
        while (cur1 <= mid) {
            temp[i] = nums[cur1];
            tempIndex[i++] = index[cur1++];
        }

        // 处理剩余的右半部分
        while (cur2 <= right) {
            temp[i] = nums[cur2];
            tempIndex[i++] = index[cur2++];
        }

        // 将合并后的结果复制回原数组
        for (int i = left; i <= right; i++) {
            nums[i] = temp[i - left];
            index[i] = tempIndex[i - left];
        }
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n log n)`，其中 `n` 是数组的长度。归并排序的时间复杂度为 `O(n log n)`。
- **空间复杂度**：`O(n)`，用于存储临时数组和 `index` 数组。