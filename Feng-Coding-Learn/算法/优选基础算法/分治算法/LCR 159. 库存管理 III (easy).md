---
Type: Note
tags:
  - 算法
  - CPP
  - easy
Status: writing
Start-date: 2025-01-24 14:57
Finish-date: 
Modified-date: 2025-01-25 13:58
Publish: false
---


# LCR 159. 库存管理 III
[LCR 159. 库存管理 III](https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/)

## 题目描述
仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。

**示例 1：**
**输入：** stock = [2,5,7,4], cnt = 1
**输出：**[2]

**示例 2：**
**输入：** stock = [0,2,3,6], cnt = 2
**输出：**[0,2] 或 [2,0]

**提示：**
- `0 <= cnt <= stock.length <= 10000   0 <= stock[i] <= 10000`

## 解题思路
#### **问题背景**
题目要求从一个数组中找出**最小的 K 个数**。这是一个经典的“选择问题”，可以通过多种方法解决，例如排序、堆排序或快速选择算法。这里使用的是 **快速选择算法**（Quick Select），它是快速排序的一个变种，专门用于解决这类问题。

#### **关键点分析**
1. **快速选择算法的基本思想**  
    快速选择算法是基于快速排序的划分思想。通过选择一个“基准值”（pivot），将数组分为两部分：
    - 左侧部分的所有元素都小于等于基准值。
    - 右侧部分的所有元素都大于基准值。
    - 根据划分结果，可以判断最小的 **K** 个数的位置，从而减少不必要的排序。
2. **随机化基准值**  
    为了提高算法的平均性能，避免性能退化（如数组已经有序时），可以随机选择基准值。这种方法可以显著提高算法的效率。
3. **划分数组**  
    在划分过程中，使用三指针法：
    - `left`：指向小于基准值的区域的末尾。
    - `right`：指向大于基准值的区域的开头。
    - `i`：用于遍历数组。
    - 这种方法可以高效地将数组划分为三部分：小于基准值、等于基准值和大于基准值。
4. **递归选择**  
    根据划分结果，判断最小的 **K** 个数的位置：
    - 如果最小的 **K** 个数在左侧部分，则递归处理左侧部分。
    - 如果最小的 **K** 个数在中间部分，则直接返回。
    - 如果最小的 **K** 个数在右侧部分，则递归处理右侧部分。


#### **难点应对**
1. **如何避免性能退化？**  
    使用随机化选择基准值，避免了数组有序或接近有序时的性能退化问题。
2. **如何高效划分数组？**  
    使用三指针划分法，可以高效地将数组划分为三部分，避免了多次遍历。
3. **如何减少不必要的排序？**  
    通过划分数组，只递归处理包含最小的 **K** 个数的部分，减少了不必要的排序操作。


### 算法流程
1. **初始化：**
    - 定义一个随机化函数 `getRandom`，用于随机选择基准值。
    - 定义快速选择函数 `qSelect`，接收数组、左边界、右边界和目标数量 **K** 作为参数。
2. **随机选择基准值：**
    - 在当前区间 `[l, r]` 内随机选择一个基准值。
3. **划分数组：**
    - 使用三指针法：
        - `left` 指向小于基准值的区域的末尾。
        - `right` 指向大于基准值的区域的开头。
        - `i` 用于遍历数组。
    - 遍历数组，根据当前元素与基准值的大小关系，将其移动到相应的位置。
4. **递归选择：**
    - 根据划分结果，判断最小的 **K** 个数的位置：
        - 如果在左侧部分，递归处理左侧。
        - 如果在中间部分，直接返回。
        - 如果在右侧部分，递归处理右侧。
5. **返回结果：**
    - 返回数组的前 **K** 个元素。

## C++代码

```cpp
class Solution {
public:
    vector<int> inventoryManagement(vector<int>& stock, int cnt) {
        srand(time(NULL));  // 初始化随机数种子
        qSelect(stock, 0, stock.size() - 1, cnt);  // 调用快速选择函数
        return vector<int>(stock.begin(), stock.begin() + cnt);  // 返回前 K 个元素
    }

    void qSelect(vector<int>& stock, int l, int r, int cnt) {
        if (l >= r) return;  // 如果区间无效，直接返回

        int key = getRandom(stock, l, r);  // 随机选择基准值
        int left = l - 1, right = r + 1, i = l;  // 初始化三指针

        while (i < right) {
            if (stock[i] < key) {
                swap(stock[++left], stock[i++]);  // 小于基准值，交换到左侧
            } else if (stock[i] == key) {
                i++;  // 等于基准值，直接跳过
            } else {
                swap(stock[--right], stock[i]);  // 大于基准值，交换到右侧
            }
        }

        // 分情况讨论
        // [l, left] [left + 1, right - 1] [right, r]
        int a = left - l + 1;  // 左侧部分的大小
        int b = right - left - 1;  // 中间部分的大小

        if (a > cnt) {
            qSelect(stock, l, left, cnt);  // 如果最小的 K 个数在左侧部分，递归处理左侧
        } else if (a + b >= cnt) {
            return;  // 如果最小的 K 个数在中间部分，直接返回
        } else {
            qSelect(stock, right, r, cnt - a - b);  // 如果最小的 K 个数在右侧部分，递归处理右侧
        }
    }

    int getRandom(vector<int>& nums, int left, int right) {
        int r = rand();  // 生成随机数
        return nums[r % (right - left + 1) + left];  // 随机选择一个基准值
    }
};
```

---

### **代码解释**

1. **初始化随机数种子：**
    
    - `srand(time(NULL))`：根据当前时间初始化随机数种子，确保随机性。
        
2. **快速选择函数 `qSelect`：**
    
    - 如果区间无效（`l >= r`），直接返回。
        
    - 初始化三指针：`left`、`right` 和 `i`。
        
    - 随机选择基准值 `key`。
        
3. **划分数组：**
    
    - 使用三指针法：
        
        - 如果当前元素小于基准值，将其与 `left` 指针所指的元素交换，并将 `left` 和 `i` 同时向右移动。
            
        - 如果当前元素等于基准值，直接将 `i` 向右移动。
            
        - 如果当前元素大于基准值，将其与 `right` 指针所指的元素交换，并将 `right` 向左移动。
            
4. **递归选择：**
    
    - 根据划分结果，判断最小的 **K** 个数的位置：
        
        - 如果在左侧部分，递归处理左侧。
            
        - 如果在中间部分，直接返回。
            
        - 如果在右侧部分，递归处理右侧。
            
5. **随机化基准值：**
    
    - 在当前区间 `[l, r]` 内随机选择一个基准值，避免性能退化。
        

---

### **总结**

通过快速选择算法，我们可以在平均情况下达到 **O(n)** 的时间复杂度，显著优于排序算法（如快速排序的 **O(n log n)**）。随机化基准值的引入可以有效避免性能退化问题，使算法更加鲁棒。

希望这些内容能帮助你更好地理解这个算法问题！如果你还有其他问题，欢迎随时提问。