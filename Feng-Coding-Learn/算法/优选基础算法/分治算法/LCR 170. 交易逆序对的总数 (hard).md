---
Type: Note
tags:
  - 算法
  - CPP
  - hard
Status: writing
Start-date: 2025-01-25 12:35
Finish-date: 
Modified-date: 2025-02-03 22:24
Publish: false
---


# LCR 170. 交易逆序对的总数
[LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

## 题目描述
在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 `record`，返回其中存在的「交易逆序对」总数。

**示例 1：**
**输入：** record = [9, 7, 5, 4, 6]
**输出：** 8
**解释：** 交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。

**提示：**
`0 <= record.length <= 50000`

## 解题思路

#### **问题背景**
题目要求计算一个数组中的**逆序对数量**。逆序对是指在数组中，如果满足 `i < j` 且 `nums[i] > nums[j]`，则称 `(i, j)` 是一个逆序对。这是一个经典的算法问题，通常可以通过**归并排序**来解决。


#### **关键点分析**
![[LCR 170. 交易逆序对的总数 (hard) 2025-01-25 12.36.34.excalidraw]]

> [!tip]- 为什么可以使用归并排序解决逆序对问题？
> 1. **归并排序的核心思想**
> 归并排序是一种 **分治算法**，它将数组分成两个子数组，分别对这两个子数组进行排序，然后将它们合并成一个有序的数组。在合并的过程中，归并排序会 **比较两个子数组的元素**，并将较小的元素放入临时数组中。
> 
> 2. **逆序对的定义**
> 逆序对的定义是：对于数组中的两个元素 `nums[i]` 和 `nums[j]`，如果 `i < j` 且 `nums[i] > nums[j]`，则 `(nums[i], nums[j])` 构成一个逆序对。
> 
> 3. **归并排序与逆序对的关系**
> 在归并排序的 **合并过程** 中，当我们将两个有序的子数组合并时，如果发现 **左子数组的当前元素 `nums[cur1]` 大于右子数组的当前元素 `nums[cur2]`**，那么：
> - 由于左子数组和右子数组都是有序的，`nums[cur1]` 及其后面的所有元素都大于 `nums[cur2]`。
> - 因此，`nums[cur1]` 与 `nums[cur2]` 以及右子数组中 `nums[cur2]` 后面的所有元素都构成逆序对。
> - 逆序对的数量为 `mid - cur1 + 1`，其中 `mid` 是左子数组的右边界。
> 
> 4. **归并排序如何统计逆序对**
> - **分治**：将数组分成两个子数组，递归地对左子数组和右子数组进行排序，并统计它们内部的逆序对数量。
> - **合并**：在合并两个有序子数组的过程中，统计跨越左右子数组的逆序对数量。
> - **总逆序对数量**：左子数组内部的逆序对数量 + 右子数组内部的逆序对数量 + 跨越左右子数组的逆序对数量。
> 
> 5. **为什么归并排序适合解决逆序对问题？**
> - **有序性**：归并排序在合并过程中会保证左右子数组是有序的，这使得我们可以高效地统计跨越左右子数组的逆序对数量。
> - **分治思想**：通过递归地将问题分解为更小的子问题，归并排序能够高效地处理大规模数据。
> - **时间复杂度**：归并排序的时间复杂度为 `O(n log n)`，这使得它非常适合处理逆序对问题。
> 
> 
> **示例解释**
> 以数组 `nums = [7, 5, 6, 4]` 为例：
> 
> 1. **初始数组**：
>    ```
>    nums = [7, 5, 6, 4]
>    ```
> 
> 2. **递归分解**：
>    - 将数组分为 `[7, 5]` 和 `[6, 4]`。
>    - 继续分解 `[7, 5]` 为 `[7]` 和 `[5]`。
>    - 继续分解 `[6, 4]` 为 `[6]` 和 `[4]`。
> 
> 3. **合并过程**：
>    - 合并 `[7]` 和 `[5]`：
>      - `7 > 5`，因此 `(7, 5)` 是一个逆序对。
>      - 合并结果为 `[5, 7]`。
>    - 合并 `[6]` 和 `[4]`：
>      - `6 > 4`，因此 `(6, 4)` 是一个逆序对。
>      - 合并结果为 `[4, 6]`。
>    - 合并 `[5, 7]` 和 `[4, 6]`：
>      - `5 > 4`，因此 `(5, 4)` 和 `(7, 4)` 是逆序对。
>      - `5 <= 6`，直接放入 `5`。
>      - `7 > 6`，因此 `(7, 6)` 是一个逆序对。
>      - 合并结果为 `[4, 5, 6, 7]`。
> 
> 4. **统计逆序对**：
>    - 左子数组 `[5, 7]` 内部的逆序对数量：`1`（`(7, 5)`）。
>    - 右子数组 `[4, 6]` 内部的逆序对数量：`1`（`(6, 4)`）。
>    - 跨越左右子数组的逆序对数量：`3`（`(5, 4)`、`(7, 4)`、`(7, 6)`）。
>    - 总逆序对数量：`1 + 1 + 3 = 5`。
> 


1. **逆序对的定义**  
    逆序对是指满足 `i < j` 且 `nums[i] > nums[j]` 的数对 `(i, j)`。计算逆序对的数量需要在排序过程中统计。
2. **归并排序的应用**  
    归并排序是一种分治算法，通过递归地将数组分为两部分，分别排序后再合并。在合并过程中，可以统计逆序对的数量：
    - 左半部分的逆序对数量。
    - 右半部分的逆序对数量。
    - 跨越左右两部分的逆序对数量。
3. **合并过程中的逆序对统计**  
    在合并两个有序数组时，如果左半部分的当前元素大于右半部分的当前元素，则说明左半部分中当前元素及其之后的所有元素都与右半部分的当前元素构成逆序对。因此，逆序对的数量为 `mid - cur1 + 1`。
4. **辅助数组的使用**  
    使用一个辅助数组 `temp`，在合并过程中存储合并后的结果，避免直接在原数组上操作，从而简化逻辑。
### 算法流程
1. **初始化：**
    - 初始化辅助数组 `temp`，大小与输入数组 `nums` 相同。
    - 定义归并排序函数 `mergeSort`，接收数组、左边界和右边界作为参数。
2. **递归划分：**
    - 如果区间无效（`left >= right`），直接返回0。
    - 计算中间位置 `mid`，将数组分为两部分。
    - 递归地对左半部分和右半部分进行排序，并统计逆序对的数量。
3. **合并过程：**
    - 使用两个指针 `cur1` 和 `cur2`，分别指向左半部分和右半部分的起始位置。
    - 比较两个指针所指的元素，将较小的元素放入 `temp` 中，并移动相应的指针。
    - 如果左半部分的当前元素大于右半部分的当前元素，则统计逆序对的数量。
    - 最后，将 `temp` 中的元素复制回原数组的相应位置。
4. **返回结果：**
    - 返回总逆序对的数量。

> [!example]- 示例解释
> 以 `record = [7, 5, 6, 4]` 为例：
> 
> 1. **初始化**：
>     - `temp` 数组初始化为 `[0, 0, 0, 0]`。
> 2. **递归排序**：
>     - 第一次递归调用 `mergeSort(nums, 0, 3)`：
>         - 计算 `mid = 1`。
>         - 递归调用 `mergeSort(nums, 0, 1)` 和 `mergeSort(nums, 2, 3)`。
>     - 第二次递归调用 `mergeSort(nums, 0, 1)`：
>         - 计算 `mid = 0`。
>         - 递归调用 `mergeSort(nums, 0, 0)` 和 `mergeSort(nums, 1, 1)`。
>     - 第三次递归调用 `mergeSort(nums, 0, 0)` 和 `mergeSort(nums, 1, 1)`：
>         - 直接返回 `0`。
>     - 合并 `[0, 1]`：
>         - `temp = [5, 7]`。
>         - 统计逆序对的数量：`1`（`(7, 5)`）。
>         - 复制回原数组，`nums = [5, 7, 6, 4]`。
>     - 第四次递归调用 `mergeSort(nums, 2, 3)`：
>         - 计算 `mid = 2`。
>         - 递归调用 `mergeSort(nums, 2, 2)` 和 `mergeSort(nums, 3, 3)`。
>     - 第五次递归调用 `mergeSort(nums, 2, 2)` 和 `mergeSort(nums, 3, 3)`：
>         - 直接返回 `0`。
>     - 合并 `[2, 3]`：
>         - `temp = [4, 6]`。
>         - 统计逆序对的数量：`1`（`(6, 4)`）。
>         - 复制回原数组，`nums = [5, 7, 4, 6]`。
>     - 合并 `[0, 3]`：
>         - `temp = [4, 5, 6, 7]`。
>         - 统计逆序对的数量：`2`（`(5, 4)` 和 `(7, 4)`）。
>         - 复制回原数组，`nums = [4, 5, 6, 7]`。
> 3. **最终结果**：
>     - 返回逆序对的总数 `5`。
> 


## C++代码

```cpp
class Solution {
    vector<int> temp;  // 辅助数组，用于合并过程

public:
    int reversePairs(vector<int>& record) {
        temp.resize(record.size());  // 初始化辅助数组大小与输入数组相同
        return mergeSort(record, 0, record.size() - 1);  // 调用归并排序函数
    }

    int mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right) return 0;  // 如果区间无效，直接返回0

        int result = 0;  // 用于存储逆序对的数量
        int mid = (left + right) >> 1;  // 计算中间位置

        // 递归地对左半部分和右半部分进行排序，并统计逆序对的数量
        result += mergeSort(nums, left, mid);
        result += mergeSort(nums, mid + 1, right);

        int cur1 = left, cur2 = mid + 1, i = 0;  // 初始化指针
        // 合并两个有序数组
        while (cur1 <= mid && cur2 <= right) {
            if (nums[cur1] <= nums[cur2]) {
                temp[i++] = nums[cur1++];  // 如果左半部分的当前元素小于等于右半部分的当前元素
            } else {
                // 如果左半部分的当前元素大于右半部分的当前元素
                result += mid - cur1 + 1;  // 统计逆序对的数量
                temp[i++] = nums[cur2++];
            }
        }

        // 处理剩余的左半部分
        while (cur1 <= mid) {
            temp[i++] = nums[cur1++];
        }

        // 处理剩余的右半部分
        while (cur2 <= right) {
            temp[i++] = nums[cur2++];
        }

        // 将合并后的结果复制回原数组
        for (int i = left; i <= right; i++) {
            nums[i] = temp[i - left];
        }

        return result;  // 返回总逆序对的数量
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n log n)`，其中 `n` 是数组的长度。归并排序的时间复杂度为 `O(n log n)`。
- **空间复杂度**：`O(n)`，用于存储临时数组。