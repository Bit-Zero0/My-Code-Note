---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-02-03 21:01
Finish-date: 
Modified-date: 2025-02-03 22:31
Publish: false
---


# 493. 翻转对
[493. 翻转对](https://leetcode.cn/problems/reverse-pairs/)

## 题目描述


## 解题思路


**1. 翻转对的定义**

翻转对是指在数组中，满足 `i < j` 且 `nums[i] > 2 * nums[j]` 的数对 `(i, j)`。简单来说，翻转对表示数组中“顺序颠倒”的元素对，且左边的元素大于右边元素的两倍。

**2. 归并排序的原理**

归并排序是一种分治算法，其核心思想是将数组分为两部分，分别对这两部分进行排序，然后再将排序后的两部分合并成一个有序数组。归并排序的关键在于**合并过程**，在这个过程中，我们可以统计翻转对的数量。

 **3. 归并排序与翻转对的关系**
归并排序的合并过程是解决翻转对问题的关键。具体来说：
- 在合并两个有序数组时，假设左半部分为 `[left, mid]`，右半部分为 `[mid+1, right]`。
- 如果左半部分的当前元素 `nums[cur1]` 大于右半部分的当前元素 `nums[cur2]` 的两倍，则说明左半部分中 `cur1` 及其之后的所有元素都大于 `nums[cur2]` 的两倍。
- 因此，这些元素都与 `nums[cur2]` 构成翻转对，翻转对的数量为 `mid - cur1 + 1`。
![[493. 翻转对 2025-02-03 21.01.57.excalidraw]]

#### **4. 详细解释**
假设我们有一个数组 `nums = [1, 3, 2, 3, 1]`，我们通过归并排序来统计翻转对数量：

1. **第一次划分**：
    - 左半部分：`[1, 3]`
    - 右半部分：`[2, 3, 1]`
2. **对左半部分 `[1, 3]` 进行归并排序**：
    - 左半部分：`[1]`
    - 右半部分：`[3]`
    - 合并时，`1 <= 3`，不构成翻转对。
3. **对右半部分 `[2, 3, 1]` 进行归并排序**：
    - 左半部分：`[2, 3]`
    - 右半部分：`[1]`
    - 合并时，`2 > 1 * 2`，构成翻转对 `(2, 1)`，翻转对数量为 `1`。
    - `3 > 1 * 2`，构成翻转对 `(3, 1)`，翻转对数量为 `1`。
4. **合并 `[1, 3]` 和 `[1, 2, 3]`**：
    - 左半部分：`[1, 3]`（已经排序）
    - 右半部分：`[1, 2, 3]`（已经排序）
    - 合并时：
        - `1 <= 1`，不构成翻转对。
        - `1 <= 2`，不构成翻转对。
        - `1 <= 3`，不构成翻转对。
        - `3 > 1 * 2`，构成翻转对 `(3, 1)`，翻转对数量为 `1`。
        - `3 > 2 * 2`，不构成翻转对。
        - `3 <= 3`，不构成翻转对。
5. **最终结果**：
    - 总翻转对数量为 `0 + 2 + 1 = 3`。


### 算法流程
1. 初始化
- 初始化临时数组 `temp`，大小为 `record.size()`。

2. 归并排序
- 调用 `mergeSort` 函数，传入数组 `record`、左边界 `0` 和右边界 `record.size() - 1`。


3. 递归排序
- 如果 `left >= right`，则直接返回 `0`。
- 计算中间位置 `mid = (left + right) >> 1`。
- 递归地对左半部分 `[left, mid]` 进行排序，并统计翻转对的数量。
- 递归地对右半部分 `[mid + 1, right]` 进行排序，并统计翻转对的数量。

4. 合并
- 使用两个指针 `cur1` 和 `cur2` 分别指向左半部分和右半部分的起始位置。
- 比较两个子数组的元素，将较小的元素放入 `temp` 中。
- 如果 `nums[cur1] > 2 * nums[cur2]`，则统计翻转对的数量。
- 将剩余的元素放入 `temp` 中。
- 将 `temp` 中的元素复制回原数组。

5. 返回结果
- 返回翻转对的总数。

## C++代码

```cpp
class Solution {
    vector<int> temp;  // 辅助数组，用于合并过程

public:
    int reversePairs(vector<int>& record) {
        temp.resize(record.size());  // 初始化辅助数组大小与输入数组相同
        return mergeSort(record, 0, record.size() - 1);  // 调用归并排序函数
    }

    int mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right) return 0;  // 如果区间无效，直接返回0

        int result = 0;  // 用于存储翻转对的数量
        int mid = (left + right) >> 1;  // 计算中间位置

        // 递归地对左半部分和右半部分进行排序，并统计翻转对的数量
        result += mergeSort(nums, left, mid);
        result += mergeSort(nums, mid + 1, right);

        int cur1 = left, cur2 = mid + 1, i = 0;  // 初始化指针
        // 合并两个有序数组
        while (cur1 <= mid && cur2 <= right) {
			if (nums[cur1] <= 2LL * nums[cur2]) {
			    temp[i++] = nums[cur1++];  // 如果左半部分的当前元素小于等于右半部分的当前元素的两倍
			} else {
		    // 如果左半部分的当前元素大于右半部分的当前元素的两倍
			    result += mid - cur1 + 1;  // 统计翻转对的数量
			    temp[i++] = nums[cur2++];
			}
        }

        // 处理剩余的左半部分
        while (cur1 <= mid) {
			temp[i++] = nums[cur1++];
        }

        // 处理剩余的右半部分
        while (cur2 <= right) {
			temp[i++] = nums[cur2++];
        }

        // 将合并后的结果复制回原数组
        for (int i = left; i <= right; i++) {
			nums[i] = temp[i - left];
        }

        return result;  // 返回总翻转对的数量
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n log n)`，其中 `n` 是数组的长度。归并排序的时间复杂度为 `O(n log n)`。
- **空间复杂度**：`O(n)`，用于存储临时数组。
