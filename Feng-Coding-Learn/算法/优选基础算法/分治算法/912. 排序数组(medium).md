---
Type: Note
tags:
  - 算法
  - 基础
  - CPP
Status: done
Start-date: 2025-01-24 11:57
Finish-date: 2025-01-24
Modified-date: 2025-08-05 21:31
Publish: false
---


# 912. 排序数组
[912. 排序数组](https://leetcode.cn/problems/sort-an-array/)

## 题目描述
给你一个整数数组 `nums`，请你将该数组升序排列。

你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

**示例 1：**
**输入：** nums = [5,2,3,1]
**输出：**[1,2,3,5]

**示例 2：**
**输入：** nums = [5,1,1,2,0,0]
**输出：**[0,0,1,1,2,5]

**提示：**

- `1 <= nums.length <= 5 * 104`
- `-5 * 104 <= nums[i] <= 5 * 104`

## 解题思路
#### **问题背景**
题目要求对一个整数数组进行排序，返回排序后的数组。这是一个经典的排序问题，可以使用多种排序算法来解决。这里使用的是 **快速排序**，并且引入了随机化来优化性能。

快排最核心的一步就是 Partition (分割数据)：将数据按照一个标准，分成左右两部分。前置题目([[75. 颜色分类(medium)]])

#### **关键点分析**
1. **快速排序的基本思想**  
    快速排序是一种分治算法，通过选择一个“基准值”（pivot），将数组分为两部分：
    - 左侧部分的所有元素都小于等于基准值。
    - 右侧部分的所有元素都大于基准值。
    - 然后递归地对左右两部分进行排序。

2. **随机化基准值**  
    传统的快速排序通常选择数组的第一个或最后一个元素作为基准值，但这可能导致性能退化（如数组已经有序时）。为了避免这种情况，可以随机选择基准值，从而提高算法的平均性能。

3. **三指针划分法**  
    在快速排序的划分过程中，使用三个指针：
    - `left`：指向小于基准值的区域的末尾。
    - `right`：指向大于基准值的区域的开头。
    - `i`：用于遍历数组。
    - 这种方法可以高效地将数组划分为三部分：小于基准值、等于基准值和大于基准值。
4. **递归排序**  
    完成一次划分后，递归地对左右两部分进行排序，直到数组完全有序。

#### **难点应对**
1. **如何避免性能退化？**  
    使用随机化选择基准值，避免了数组有序或接近有序时的性能退化问题。
2. **如何高效划分数组？**  
    使用三指针划分法，可以高效地将数组划分为三部分，避免了多次遍历。
3. **如何实现原地排序？**  
    快速排序是一种原地排序算法，通过交换元素完成排序，不需要额外的存储空间。

#### **算法逻辑**
1. **初始化随机数种子：**
    - `srand(time(NULL))`：根据当前时间初始化随机数种子，确保随机性。
        
2. **快速排序函数 `qsort`：**
    - 如果区间无效（`l >= r`），直接返回。
    - 初始化三指针：`left`、`right` 和 `i`。
    - 随机选择基准值 `key`。
3. **划分数组：**
    - 使用三指针法：
        - 如果当前元素小于基准值，将其与 `left` 指针所指的元素交换，并将 `left` 和 `i` 同时向右移动。
        - 如果当前元素大于基准值，将其与 `right` 指针所指的元素交换，并将 `right` 向左移动。
        - 如果当前元素等于基准值，直接将 `i` 向右移动。
4. **递归排序：**
    - 对小于基准值的区域 `[l, left]` 进行递归排序。
    - 对大于基准值的区域 `[right, r]` 进行递归排序。
5. **随机化基准值：**
    - 在当前区间 `[l, r]` 内随机选择一个基准值，避免性能退化。

### C++代码
```cpp
class Solution {
public:
    vector<int> sortArray(vector<int>& nums) {
        srand(time(NULL));  // 初始化随机数种子
        qsort(nums, 0, nums.size() - 1);  // 调用快速排序函数
        return nums;  // 返回排序后的数组
    }

    void qsort(vector<int>& nums, int l, int r) {
        if (l >= r) return;  // 如果区间无效，直接返回

        int left = l - 1, right = r + 1, i = l;  // 初始化三指针
        int key = getRandom(nums, l, r);  // 随机选择基准值

        while (i < right) {
            if (nums[i] < key) {
                swap(nums[++left], nums[i++]);  // 小于基准值，交换到左侧
            } else if (nums[i] > key) {
                swap(nums[--right], nums[i]);  // 大于基准值，交换到右侧
            } else {
                i++;  // 等于基准值，直接跳过
            }
        }

        qsort(nums, l, left);  // 递归排序左侧
        qsort(nums, right, r);  // 递归排序右侧
    }

    int getRandom(vector<int>& nums, int left, int right) {
        int r = rand();  // 生成随机数
        return nums[r % (right - left + 1) + left];  // 随机选择一个基准值
    }
};
```

### 复杂度分析
- **时间复杂度**：平均情况下为 `O(n log n)`，其中 `n` 是数组的长度。最坏情况下为 `O(n^2)`，但通过随机化基准元素可以避免最坏情况。
- **空间复杂度**：`O(log n)`，用于递归调用栈。


## 归并排序

1. **归并排序的基本思想**  
    归并排序是一种分治算法，通过递归地将数组分为两部分，分别排序后再合并。具体步骤如下：
    - **分**：将数组分为两部分，分别对左半部分和右半部分进行排序。
    - **治**：将排序后的两部分合并为一个有序数组。
        
2. **递归划分**
    - 使用递归函数 `mergeSort`，将数组分为两部分，分别对左半部分和右半部分进行排序。
    - 递归的终止条件是当数组的长度为1时，此时数组已经是有序的。
3. **合并过程**
    - 使用一个辅助数组 `temp`，用于存储合并后的结果。
    - 使用两个指针 `cur1` 和 `cur2`，分别指向左半部分和右半部分的起始位置。
    - 比较两个指针所指的元素，将较小的元素放入 `temp` 中，并移动相应的指针。
    - 如果某一侧的元素已经全部处理完，将另一侧剩余的元素直接复制到 `temp` 中。
    - 最后，将 `temp` 中的元素复制回原数组的相应位置。
4. **优化空间复杂度**
    - 使用一个全局辅助数组 `temp`，避免在每次合并时重新分配内存，从而优化空间复杂度。

#### **难点应对**
1. **如何实现高效的合并过程？**  
    使用辅助数组 `temp`，通过双指针法逐个比较并合并两个有序数组，时间复杂度为 **O(n)**。

2. **如何避免重复分配内存？**  
    使用一个全局辅助数组 `temp`，在合并过程中直接使用该数组，避免每次合并时重新分配内存。

3. **如何处理边界条件？**  
    递归的终止条件是当数组的长度为1时，此时数组已经是有序的。


#### **算法逻辑**
1. **初始化：**
    - 初始化辅助数组 `temp`，大小与输入数组 `nums` 相同。
    - 定义归并排序函数 `mergeSort`，接收数组、左边界和右边界作为参数。
2. **递归划分：**
    - 如果区间无效（`left >= right`），直接返回。
    - 计算中间位置 `mid`，将数组分为两部分。
    - 递归地对左半部分和右半部分进行排序。
3. **合并过程：**
    - 使用两个指针 `cur1` 和 `cur2`，分别指向左半部分和右半部分的起始位置。
    - 比较两个指针所指的元素，将较小的元素放入 `temp` 中，并移动相应的指针。
    - 如果某一侧的元素已经全部处理完，将另一侧剩余的元素直接复制到 `temp` 中。
    - 最后，将 `temp` 中的元素复制回原数组的相应位置。
4. **返回结果：**
    - 返回排序后的数组 `nums`。

```cpp
class Solution {
    vector<int> temp;  // 辅助数组，用于合并过程

public:
    vector<int> sortArray(vector<int>& nums) {
        temp.resize(nums.size());  // 初始化辅助数组大小与输入数组相同
        mergeSort(nums, 0, nums.size() - 1);  // 调用归并排序函数
        return nums;  // 返回排序后的数组
    }

    void mergeSort(vector<int>& nums, int left, int right) {
        if (left >= right) return;  // 如果区间无效，直接返回

        int mid = (right + left) >> 1;  // 计算中间位置
        mergeSort(nums, left, mid);  // 递归排序左半部分
        mergeSort(nums, mid + 1, right);  // 递归排序右半部分

        int cur1 = left, cur2 = mid + 1, i = 0;  // 初始化指针
        // 合并两个有序数组
        while (cur1 <= mid && cur2 <= right) {
            temp[i++] = nums[cur1] <= nums[cur2] ? nums[cur1++] : nums[cur2++];
        }

        // 处理剩余的左半部分
        while (cur1 <= mid) {
            temp[i++] = nums[cur1++];
        }

        // 处理剩余的右半部分
        while (cur2 <= right) {
            temp[i++] = nums[cur2++];
        }

        // 将合并后的结果复制回原数组
        for (int i = left; i <= right; i++) {
            nums[i] = temp[i - left];
        }
    }
};
```

---

### **代码解释**

1. **初始化辅助数组：**
    - `vector<int> temp;`：定义一个全局辅助数组，用于合并过程。
    - `temp.resize(nums.size());`：初始化辅助数组大小与输入数组相同。
        
2. **归并排序函数 `mergeSort`：**
    - 如果区间无效（`left >= right`），直接返回。
    - 计算中间位置 `mid`，将数组分为两部分。
    - 递归地对左半部分和右半部分进行排序。
        
3. **合并过程：**
    - 使用两个指针 `cur1` 和 `cur2`，分别指向左半部分和右半部分的起始位置。
    - 比较两个指针所指的元素，将较小的元素放入 `temp` 中，并移动相应的指针。
    - 如果某一侧的元素已经全部处理完，将另一侧剩余的元素直接复制到 `temp` 中。
    - 最后，将 `temp` 中的元素复制回原数组的相应位置。
        
4. **返回结果：**
    - 返回排序后的数组 `nums`。


通过归并排序，我们可以在 **O(n log n)** 的时间复杂度内完成排序，并且使用辅助数组 `temp` 优化了空间复杂度。这种方法简单高效，适用于处理大规模数据的排序问题。
