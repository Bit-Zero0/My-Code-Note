---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-23 23:22
Finish-date: 
Modified-date: 2025-01-23 23:52
Publish: false
---


# 75. 颜色分类
[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

## 题目描述
给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

**示例 1：**
**输入：** nums = [2,0,2,1,1,0]
**输出：**[0,0,1,1,2,2]

**示例 2：**
**输入：** nums = [2,0,1]
**输出：**[0,1,2]

**提示：**
- `n == nums.length`
- `1 <= n <= 300`
- `nums[i]` 为 `0`、`1` 或 `2`

## 解题思路
#### **问题背景**
题目要求对一个数组进行排序，数组中只包含三种颜色的编号：0（红色）、1（白色）和2（蓝色）。目标是将数组按照 **0 -> 1 -> 2** 的顺序排序，且要求 **原地排序**，即不能使用额外的存储空间。

![[75. 颜色分类 2025-01-23 23.23.05.excalidraw|543]]

#### **关键点分析**
1. **三色问题的特殊性**  
    由于数组中只有三种颜色，我们可以利用这一特性，通过一次遍历完成排序，而不是使用传统的排序算法（如快速排序、归并排序等）。这种方法的时间复杂度为 **O(n)**，并且满足原地排序的要求。
2. **双指针法的扩展**  
    使用三个指针来解决这个问题：
    - `left` 指针：指向数组的起始位置，用于存放颜色 0（红色）。
    - `right` 指针：指向数组的末尾位置，用于存放颜色 2（蓝色）。
    - `i` 指针：遍历数组，用于检查当前元素的颜色。
3. **状态转移逻辑**
    - 如果当前元素是 **0**，将其与 `left` 指针所指的元素交换，并将 `left` 和 `i` 同时向右移动。
    - 如果当前元素是 **2**，将其与 `right` 指针所指的元素交换，并将 `right` 向左移动。注意，此时 `i` 不移动，因为交换过来的元素需要重新检查。
    - 如果当前元素是 **1**，直接将 `i` 向右移动。
4. **边界条件**
    - `left` 指针始终指向下一个应该存放颜色 0 的位置。
    - `right` 指针始终指向下一个应该存放颜色 2 的位置。
    - 当 `i` 超过 `right` 时，排序完成。


#### **难点应对**
1. **如何避免额外空间？**  
    使用双指针法，直接在原数组上操作，避免使用额外的存储空间。
2. **如何处理交换后的元素？**
    - 当交换颜色 2 时，`i` 不移动，因为交换过来的元素可能需要再次处理。
    - 当交换颜色 0 时，`i` 和 `left` 同时移动，因为交换过来的元素已经处理过。
3. **如何确保时间复杂度为 O(n)？**  
    通过一次遍历完成排序，避免多次遍历数组。

#### **算法逻辑**

1. **初始化指针：**
    - `left` 指向数组的起始位置（-1）。
    - `right` 指向数组的末尾位置（`nums.size()`）。
    - `i` 从数组的起始位置开始遍历。
2. **遍历数组：**
    - 如果当前元素是 **0**，将其与 `left` 指针所指的元素交换，并将 `left` 和 `i` 同时向右移动。
    - 如果当前元素是 **2**，将其与 `right` 指针所指的元素交换，并将 `right` 向左移动。此时 `i` 不移动。
    - 如果当前元素是 **1**，直接将 `i` 向右移动。
3. **结束条件：**
    - 当 `i` 超过 `right` 时，排序完成。


## C++代码
```cpp
class Solution {
public:
    void sortColors(vector<int>& nums) {
        int left = -1, right = nums.size();  // 初始化指针
        for (int i = 0; i < right;) {
            if (nums[i] == 0) {
                // 如果当前元素是 0，将其与 left 指针所指的元素交换
                swap(nums[++left], nums[i++]);
            } else if (nums[i] == 2) {
                // 如果当前元素是 2，将其与 right 指针所指的元素交换
                swap(nums[--right], nums[i]);
                // 注意：此时 i 不移动，因为交换过来的元素需要重新检查
            } else {
                // 如果当前元素是 1，直接将 i 向右移动
                i++;
            }
        }
    }
};
```

### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。我们只需要遍历一次数组。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。