---
Type: Note
tags: 
  - 算法
  - 基础
  - CPP
Status: writing
Start-date: 2025-01-24 13:39
Finish-date: 
Modified-date: 2025-01-24 13:45
Publish: false
---


# 215. 数组中的第K个最大元素
[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 题目描述
给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**
**输入:** `[3,2,1,5,6,4],` k = 2
**输出:** 5

**示例 2:**
**输入:** `[3,2,3,1,2,4,5,5,6],` k = 4
**输出:** 4

**提示：**
- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

## 解题思路
#### **问题背景**
题目要求找出数组中的第 **K** 个最大元素。这是一个经典的“选择问题”，可以通过多种方法解决，例如排序、堆排序或快速选择算法。这里使用的是 **快速选择算法**（Quick Select），它是快速排序的一个变种，专门用于解决这类问题。

#### **关键点分析**

1. **快速选择算法的基本思想**  
    快速选择算法是基于快速排序的划分思想。通过选择一个“基准值”（pivot），将数组分为两部分：
    - 左侧部分的所有元素都小于等于基准值。
    - 右侧部分的所有元素都大于基准值。
    - 根据划分结果，可以判断第 **K** 个最大元素的位置，从而减少不必要的排序。
2. **随机化基准值**  
    为了提高算法的平均性能，避免性能退化（如数组已经有序时），可以随机选择基准值。这种方法可以显著提高算法的效率。
3. **划分数组**  
    在划分过程中，使用三指针法：
    - `left`：指向小于基准值的区域的末尾。
    - `right`：指向大于基准值的区域的开头。
    - `i`：用于遍历数组。
    - 这种方法可以高效地将数组划分为三部分：小于基准值、等于基准值和大于基准值。
4. **递归选择**  
    根据划分结果，判断第 **K** 个最大元素的位置：
    - 如果第 **K** 个最大元素在右侧部分，则递归处理右侧部分。
    - 如果第 **K** 个最大元素在中间部分，则直接返回基准值。
    - 如果第 **K** 个最大元素在左侧部分，则递归处理左侧部分。

#### **难点应对**
1. **如何避免性能退化？**  
    使用随机化选择基准值，避免了数组有序或接近有序时的性能退化问题。
2. **如何高效划分数组？**  
    使用三指针划分法，可以高效地将数组划分为三部分，避免了多次遍历。
3. **如何减少不必要的排序？**  
    通过划分数组，只递归处理包含第 **K** 个最大元素的部分，减少了不必要的排序操作。


### 算法流程
1. **初始化：**
    - 定义一个随机化函数 `getRandom`，用于随机选择基准值。
    - 定义快速选择函数 `qSelect`，接收数组、左边界、右边界和目标索引 **K** 作为参数。
2. **随机选择基准值：**
    - 在当前区间 `[l, r]` 内随机选择一个基准值。
3. **划分数组：**
    - 使用三指针法：
        - `left` 指向小于基准值的区域的末尾。
        - `right` 指向大于基准值的区域的开头。
        - `i` 用于遍历数组。
    - 遍历数组，根据当前元素与基准值的大小关系，将其移动到相应的位置。
4. **递归选择：**
    - 根据划分结果，判断第 **K** 个最大元素的位置：
        - 如果第 **K** 个最大元素在右侧部分，则递归处理右侧部分。
        - 如果第 **K** 个最大元素在中间部分，则直接返回基准值。
        - 如果第 **K** 个最大元素在左侧部分，则递归处理左侧部分。
5. **返回结果：**
    - 返回第 **K** 个最大元素。


## C++代码
```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        srand(time(NULL));  // 初始化随机数种子
        return qSelect(nums, 0, nums.size() - 1, k);  // 调用快速选择函数
    }

    int qSelect(vector<int>& nums, int l, int r, int k) {
        if (l >= r) return nums[l];  // 如果区间无效，直接返回

        int left = l - 1, right = r + 1, i = l;  // 初始化三指针
        int key = getRandom(nums, l, r);  // 随机选择基准值

        while (i < right) {
            if (nums[i] < key) {
                swap(nums[++left], nums[i++]);  // 小于基准值，交换到左侧
            } else if (nums[i] > key) {
                swap(nums[--right], nums[i]);  // 大于基准值，交换到右侧
            } else {
                i++;  // 等于基准值，直接跳过
            }
        }

        // 计算划分后的区间大小
        int c = r - right + 1;  // 右侧部分的大小
        int b = right - left - 1;  // 中间部分的大小

        // 判断第 K 个最大元素的位置
        if (c >= k) {
            return qSelect(nums, right, r, k);  // 如果在右侧部分，递归处理右侧
        } else if (b + c >= k) {
            return key;  // 如果在中间部分，直接返回基准值
        } else {
            return qSelect(nums, l, left, k - b - c);  // 如果在左侧部分，递归处理左侧
        }
    }

    int getRandom(vector<int>& nums, int left, int right) {
        int r = rand();  // 生成随机数
        return nums[r % (right - left + 1) + left];  // 随机选择一个基准值
    }
};
```

### 复杂度分析
- **时间复杂度**：平均情况下为 `O(n)`，其中 `n` 是数组的长度。最坏情况下为 `O(n^2)`，但通过随机化基准元素可以避免最坏情况。
- **空间复杂度**：`O(1)`，只使用了常数级别的额外空间。
