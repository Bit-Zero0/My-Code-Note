---
Type: Note
tags:
  - 算法
  - medium
Status: writing
Start-date: 2025-02-11 22:20
Finish-date: 
Modified-date: 2025-02-18 14:12
Publish: false
---


# 2. 两数相加

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)
## 题目描述
给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

**输入：** l1 = [2,4,3], l2 = [5,6,4]
**输出：**[7,0,8]
**解释：**342 + 465 = 807.

**示例 2：**
**输入：** l1 = [0], l2 = [0]
**输出：**[0]

**示例 3：**
**输入：** l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
**输出：**[8,9,9,9,0,0,0,1]

**提示：**
- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零



## 解题思路
题目要求将两个表示非负整数的链表相加。每个链表中的节点包含一个数字，数字存储顺序为逆序（即最低位在链表头部）。需要返回一个新的链表，表示两个数相加的结果。

#### **关键点分析**
1. **链表的逆序表示**  
    每个链表的节点从低到高表示数字的每一位。例如，链表 `1 -> 2 -> 3` 表示数字 `321`。
    
2. **逐位相加**  
    从链表的头部开始逐位相加，同时处理进位。如果两个链表长度不同，较短的链表可以视为在高位补零。
    
3. **处理进位**  
    在每次相加时，需要考虑前一位的进位，并计算当前位的进位。如果最后一位相加后仍有进位，需要在结果链表中添加一个新的节点。
    
4. **构建结果链表**  
    使用一个虚拟头节点（dummy head）简化链表操作，避免处理边界条件。


#### **难点应对**
1. **如何逐位相加并处理进位？**  
    使用一个循环，逐位相加两个链表的节点值，并加上前一位的进位。计算当前位的值和新的进位。
    
2. **如何处理链表长度不同？**  
    如果一个链表已经遍历完，可以将其视为在高位补零，继续相加。
    
3. **如何处理最后的进位？**  
    如果最后一位相加后仍有进位，需要在结果链表中添加一个新的节点。
    
4. **如何简化链表操作？**  
    使用一个虚拟头节点（dummy head），可以避免处理链表为空的情况，简化代码逻辑。
    

### **算法逻辑**
1. **初始化：**
    - 创建一个虚拟头节点 `head`，用于简化链表操作。
    - 初始化两个指针 `cur1` 和 `cur2`，分别指向两个输入链表的头部。
    - 初始化一个指针 `cur`，指向结果链表的当前节点。
    - 初始化变量 `num` 和 `carry`，分别用于存储当前位的值和进位。

2. **逐位相加：**
    - 使用一个循环，直到两个链表都遍历完且没有剩余的进位：
        - 如果 `cur1` 不为空，将 `cur1` 的值加到 `num`，并将 `cur1` 移动到下一个节点。
        - 如果 `cur2` 不为空，将 `cur2` 的值加到 `num`，并将 `cur2` 移动到下一个节点。
        - 将 `carry` 加到 `num`，计算当前位的值和新的进位。
        - 创建一个新的节点，存储当前位的值（`num % 10`），并将 `cur` 移动到下一个节点。
        - 重置 `num` 为 0。

3. **返回结果：**
    - 返回虚拟头节点的下一个节点，即结果链表的头部。


## C++代码

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // 创建一个虚拟头节点，简化链表操作
        ListNode* head = new ListNode(0);
        ListNode* cur1 = l1, *cur2 = l2, *cur = head;
        int num = 0, carry = 0;  // num 用于存储当前位的值，carry 用于存储进位

        // 遍历两个链表，直到两个链表都为空且没有剩余的进位
        while (cur1 || cur2 || carry != 0) {
            // 如果 cur1 不为空，将 cur1 的值加到 num，并移动 cur1
            if (cur1) {
                num += cur1->val;
                cur1 = cur1->next;
            }
            // 如果 cur2 不为空，将 cur2 的值加到 num，并移动 cur2
            if (cur2) {
                num += cur2->val;
                cur2 = cur2->next;
            }

            // 加上前一位的进位，并计算新的进位
            num += carry;
            if (num > 9) {
                carry = num / 10;  // 计算新的进位
            } else {
                carry = 0;  // 如果 num <= 9，进位为 0
            }

            // 创建一个新的节点，存储当前位的值（num % 10），并移动 cur
            cur->next = new ListNode(num % 10);
            cur = cur->next;

            // 重置 num 为 0，准备下一次循环
            num = 0;
        }

        // 返回虚拟头节点的下一个节点，即结果链表的头部
        return head->next;
    }
};
```

- **时间复杂度**：`O(max(m, n))`，其中 `m` 和 `n` 分别是 `l1` 和 `l2` 的长度。我们需要遍历两个链表的每个节点。
    
- **空间复杂度**：`O(max(m, n))`，用于存储结果链表。

