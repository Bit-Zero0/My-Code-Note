---
Type: Note
tags:
  - 算法
  - CPP
Status: writing
Start-date: 2025-02-19 15:00
Finish-date: 
Modified-date: 2025-02-19 20:53
Publish: false
---


# 23. 合并 K 个升序链表
[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

## 题目描述
给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

**输入：** lists = `[[1,4,5],[1,3,4],[2,6]]`
**输出：** `[1,1,2,3,4,4,5,6]`
**解释：** 链表数组如下：
```
[
  1->4->5,
  1->3->4,
  2->6
]
```
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

**示例 2：**
**输入：** lists = `[]`
**输出：**`[]`

**示例 3：**
**输入：** lists = `[[]]`
**输出：**`[]`

## 解题思路1 (分治)
分治法是一种将复杂问题分解为多个子问题解决的方法。对于合并 K 个链表的问题，我们可以递归地将链表数组分成两部分，分别合并，然后再将两个合并后的链表合并。

> [!tip] 推荐先学习一下分治：[[readme - 分治,归并]]


具体步骤如下：
1. **递归划分**：将链表数组分成两部分，分别递归合并。
2. **合并两个链表**：递归到最底层时，每次合并两个链表。
3. **合并结果**：递归返回时，将合并后的链表逐层返回，最终得到一个完整的升序链表。

**合并两个链表**
合并两个升序链表是整个问题的核心操作。我们可以通过双指针法实现：
- 使用两个指针分别遍历两个链表。
- 比较当前节点的值，将较小的节点连接到结果链表中。
- 当一个链表遍历完成后，直接将另一个链表的剩余部分连接到结果链表。



### **算法流程**

 **1. 分治合并**
1. **递归终止条件**：
    - 如果 `left > right`，返回 `nullptr`。
    - 如果 `left == right`，直接返回 `lists[left]`。
2. **递归划分**：
    - 计算中间位置 `mid`。
    - 递归合并左半部分 `merge(lists, left, mid)`。
    - 递归合并右半部分 `merge(lists, mid + 1, right)`。
3. **合并结果**：
    - 将左右两部分的合并结果传递给 `mergeTwoList` 函数。

 **2. 合并两个链表**
1. **边界条件**：
    - 如果其中一个链表为空，直接返回另一个链表。
2. **双指针合并**：
    - 使用一个虚拟头节点 `head`，方便操作。
    - 使用两个指针 `cur1` 和 `cur2` 分别遍历两个链表。
    - 比较当前节点的值，将较小的节点连接到结果链表中。
    - 当一个链表遍历完成后，将另一个链表的剩余部分连接到结果链表。

### C++代码
```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 调用分治合并函数，从左到右合并链表数组
        return merge(lists, 0, lists.size() - 1);
    }

    // 分治合并函数
    ListNode* merge(vector<ListNode*>& lists, int left, int right) {
        // 如果左边界大于右边界，返回 nullptr
        if (left > right) return nullptr;
        // 如果左边界等于右边界，直接返回当前链表
        if (left == right) return lists[left];

        // 计算中间位置
        int mid = (left + right) / 2;
        // 递归合并左半部分
        ListNode* l1 = merge(lists, left, mid);
        // 递归合并右半部分
        ListNode* l2 = merge(lists, mid + 1, right);

        // 合并两个链表的结果
        return mergeTwoList(l1, l2);
    }

    // 合并两个升序链表
    ListNode* mergeTwoList(ListNode* l1, ListNode* l2) {
        // 如果其中一个链表为空，直接返回另一个链表
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;

        // 创建一个虚拟头节点，方便操作
        ListNode head;
        head.next = nullptr;
        ListNode* prev = &head;

        // 使用双指针合并两个链表
        while (l1 && l2) {
            if (l1->val < l2->val) {
                // 如果 l1 的当前节点较小，连接到结果链表
                prev->next = l1;
                l1 = l1->next;  // 移动 l1 指针
            } else {
                // 如果 l2 的当前节点较小，连接到结果链表
                prev->next = l2;
                l2 = l2->next;  // 移动 l2 指针
            }
            prev = prev->next;  // 移动结果链表的指针
        }

        // 如果其中一个链表还有剩余，直接连接到结果链表
        if (l1) prev->next = l1;
        if (l2) prev->next = l2;

        // 返回虚拟头节点的下一个节点，即合并后的链表头
        return head.next;
    }
};
```

### 复杂度分析

- **时间复杂度**：O(N log K)
    - 分治法将 K 个链表分成两半，递归深度为 log K。
    - 每一层需要遍历所有节点，总节点数为 N。
    - 因此，总时间复杂度为 O(N log K)。

- **空间复杂度**：O(log K)
    - 递归调用栈的深度为 log K。
    - 额外空间仅用于递归栈，无其他额外空间消耗。


## 解题思路2 (优先级队列)

优先队列（最小堆）是一种非常适合解决此类问题的数据结构。它的主要优点是能够高效地获取当前所有链表中的最小节点。具体步骤如下：
1. **初始化优先队列**：将每个链表的头节点加入优先队列。
2. **逐步合并**：每次从优先队列中取出最小节点，将其加入结果链表，并将该节点的下一个节点（如果存在）加入优先队列。
3. **重复上述过程**，直到优先队列为空。
    

**自定义比较函数**
为了使优先队列能够正确比较链表节点的值，我们需要定义一个自定义比较函数 `cmp`，确保优先队列能够按照节点值从小到大的顺序排列。



### **算法流程**
1. **定义比较函数**：
    - 使用自定义比较函数 `cmp`，使得优先队列按照节点值从小到大排列。
2. **初始化优先队列**：
    - 遍历链表数组，将每个链表的头节点（如果存在）加入优先队列。
3. **逐步合并链表**：
    - 创建一个虚拟头节点 `ret`，方便操作。
    - 每次从优先队列中取出最小节点，将其连接到结果链表中。
    - 如果该节点有下一个节点，将其下一个节点加入优先队列。
    - 重复上述过程，直到优先队列为空。
4. **返回结果**：
    - 返回虚拟头节点的下一个节点，即合并后的链表头。




### C++代码
```cpp
class Solution {
public:
    // 自定义比较函数，用于优先队列
    struct cmp {
        bool operator()(const ListNode* l1, const ListNode* l2) {
            // 优先队列默认是最大堆，因此这里返回 l1->val > l2->val
            // 使得优先队列按照节点值从小到大排列
            return l1->val > l2->val;
        }
    };

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 初始化优先队列
        priority_queue<ListNode*, vector<ListNode*>, cmp> heap;

        // 将每个链表的头节点（如果存在）加入优先队列
        for (auto l : lists) {
            if (l) heap.push(l);
        }

        // 创建一个虚拟头节点，方便操作
        ListNode* ret = new ListNode(0);
        ListNode* prev = ret;

        // 逐步合并链表
        while (!heap.empty()) {
            // 从优先队列中取出最小节点
            ListNode* temp = heap.top();
            heap.pop();

            // 将该节点连接到结果链表中
            prev->next = temp;
            prev = prev->next;

            // 如果该节点有下一个节点，将其加入优先队列
            if (temp->next) heap.push(temp->next);
        }

        // 返回虚拟头节点的下一个节点，即合并后的链表头
        return ret->next;
    }
};
```

#### **代码说明**

1. **优先队列（最小堆）**：
    - 使用 `priority_queue` 存储链表节点，通过自定义比较函数 `cmp`，使得优先队列能够按照节点值从小到大排列。
2. **初始化优先队列**：
    - 遍历链表数组，将每个链表的头节点（如果存在）加入优先队列。
3. **逐步合并链表**：
    - 每次从优先队列中取出最小节点，将其连接到结果链表中。
    - 如果该节点有下一个节点，将其下一个节点加入优先队列。
    - 重复上述过程，直到优先队列为空。
4. **虚拟头节点**：
    - 使用虚拟头节点 `ret`，方便操作合并后的链表。



### **复杂度分析**

- **时间复杂度**：O(N log K)，其中 N 是所有链表中节点的总数，K 是链表的数量。
    - 每次从优先队列中取出最小节点的时间复杂度为 O(log K)。
    - 总共需要处理 N 个节点。
- **空间复杂度**：O(K)，优先队列中最多存储 K 个节点。





