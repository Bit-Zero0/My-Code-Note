---
Type: Note
tags:
  - 算法
  - CPP
Status: writing
Start-date: 2025-02-18 17:15
Finish-date: 
Modified-date: 2025-02-19 15:00
Publish: false
---


# 143. 重排链表
[143. 重排链表](https://leetcode.cn/problems/reorder-list/)

## 题目描述
给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：
L0 → L1 → … → Ln - 1 → Ln

请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1：**
![](https://pic.leetcode-cn.com/1626420311-PkUiGI-image.png)
**输入：** head = [1,2,3,4]
**输出：**[1,4,2,3]


**示例 2：**
![](https://pic.leetcode-cn.com/1626420320-YUiulT-image.png)
**输入：** head = [1,2,3,4,5]
**输出：**[1,5,2,4,3]

**提示：**
- 链表的长度范围为 `[1, 5 * 104]`
- `1 <= node.val <= 1000`

## 解题思路

#### **题目描述**

给定一个单链表，要求将其重新排序，使得链表的前半部分和反转后的后半部分交替连接。例如：
- 输入：`1->2->3->4->5->6`
- 输出：`1->6->2->5->3->4`


##### **1. 找到链表的中点**
为了将链表重新排序，我们需要将其分为两部分：前半部分和后半部分。为此，我们使用快慢指针法找到链表的中点。
- **快指针（fast）**：每次移动两步。
- **慢指针（slow）**：每次移动一步。
- 当快指针到达链表末尾时，慢指针恰好指向链表的中点。


**示例**： 对于链表 `1->2->3->4->5->6`：
- 初始时，`slow` 和 `fast` 都指向头节点 `1`。
- 第一次循环：`slow` 移动到 `2`，`fast` 移动到 `3`。
- 第二次循环：`slow` 移动到 `3`，`fast` 移动到 `5`。
- 第三次循环：`slow` 移动到 `4`，`fast` 移动到 `6`。
- 此时，`fast` 到达末尾，`slow` 指向中点 `4`。

**结果**：
- 中点是 `4`，链表被分为两部分：
    - **前半部分**：`1->2->3->4`
    - **后半部分**：`5->6`



##### **2. 分割链表并反转后半部分**
在找到中点后，我们将链表从中间分割为两部分，并反转后半部分。
- **分割链表**：将 `slow->next` 设置为 `nullptr`，这样前半部分结束于 `4`，后半部分从 `5` 开始。
- **反转后半部分**：从 `5` 开始反转链表，最终得到反转后的链表 `6->5`。


**示例**： 原链表：`1->2->3->4->5->6`
- 分割后：
    - **前半部分**：`1->2->3->4`
    - **后半部分**：`5->6`
- 反转后半部分：
    - 反转前：`5->6`
    - 反转后：`6->5`

##### **3. 合并链表**
最后一步是将前半部分和反转后的后半部分交替合并。具体操作如下：
- 使用两个指针分别指向前半部分和后半部分的当前节点。
- 每次从两个链表中各取一个节点，交替连接。

**示例**：
- **前半部分**：`1->2->3->4`
- **后半部分（反转后）**：`6->5`
    
合并过程：
1. 取前半部分的第一个节点 `1`，连接后半部分的第一个节点 `6`：
    - `1->6`
2. 取前半部分的下一个节点 `2`，连接到 `6` 的后面：
    - `1->6->2`
3. 取后半部分的下一个节点 `5`，连接到 `2` 的后面：
    - `1->6->2->5`
4. 取前半部分的下一个节点 `3`，连接到 `5` 的后面：
    - `1->6->2->5->3`
5. 取后半部分的下一个节点（此时后半部分结束），连接到 `3` 的后面：
    - `1->6->2->5->3->4`


**最终结果**： 合并后的链表为：`1->6->2->5->3->4`


### 算法流程
1. **快慢指针找到中点**：
    - 快指针 `fast` 每次移动两步，慢指针 `slow` 每次移动一步。
    - 当 `fast` 到达链表末尾时，`slow` 恰好指向中点。

2. **分割链表并反转后半部分**：
    - 从 `slow->next` 开始反转后半部分。
    - 使用 `prev` 和 `cur` 指针完成链表反转。
    - 最终，`prev` 指向反转后的后半部分的头节点。

3. **合并链表**：
    - 使用两个指针分别指向前半部分和反转后的后半部分。
    - 交替连接两个链表的节点，直到后半部分的节点全部连接完成。

## C++代码

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        // 如果链表为空或只有一个/两个节点，无需操作
        if (!head || !head->next || !head->next->next)
            return;

        // 1. 使用快慢指针找到链表的中点
        ListNode* slow = head;  // 慢指针，每次移动一步
        ListNode* fast = head;  // 快指针，每次移动两步
        while (fast && fast->next) {
            slow = slow->next;  // 慢指针移动到中点
            fast = fast->next->next;  // 快指针移动到链表末尾
        }

        // 此时，slow 指向中点（对于偶数长度链表，指向中间偏左的节点）
        // 例如：1->2->3->4->5->6，slow 指向 3

        // 2. 分割链表，并反转后半部分
        // 分割链表：从 slow->next 开始反转后半部分
        ListNode* prev = nullptr;  // 用于反转链表的前一个节点
        ListNode* cur = slow->next;  // 从后半部分的第一个节点开始
        slow->next = nullptr;  // 分割链表，前半部分结束

        // 反转后半部分链表
        while (cur) {
            ListNode* next = cur->next;  // 保存当前节点的下一个节点
            cur->next = prev;  // 当前节点的 next 指向前一个节点
            prev = cur;  // 更新 prev 为当前节点
            cur = next;  // 移动到下一个节点
        }

        // 此时，prev 指向反转后的后半部分的头节点
        // 例如：原链表 1->2->3->4->5->6，反转后后半部分为 6->5

        // 3. 合并链表：交替连接前半部分和反转后的后半部分
        ListNode* cur1 = head;  // 前半部分的当前节点
        ListNode* cur2 = prev;  // 反转后的后半部分的当前节点

        // 交替合并两个链表
        while (cur2) {  // 当后半部分还有节点时继续合并
            ListNode* next1 = cur1->next;  // 保存前半部分的下一个节点
            ListNode* next2 = cur2->next;  // 保存后半部分的下一个节点

            cur1->next = cur2;  // 将后半部分的节点连接到前半部分
            cur2->next = next1;  // 将前半部分的下一个节点连接到后半部分的当前节点

            cur1 = next1;  // 移动到前半部分的下一个节点
            cur2 = next2;  // 移动到后半部分的下一个节点
        }

        // 最终结果：1->6->2->5->3->4
    }
};
```