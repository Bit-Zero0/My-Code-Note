---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-08 22:30
Finish-date: 
Modified-date: 2025-08-10 22:32
Publish: false
---
红黑树（Red-Black Tree）是数据结构中的一个“重量级”内容，它在理论和工程实践中都有着举足轻重的地位，例如 C++ STL 中的 `std::map` 和 `std::set` 通常就是用红黑树实现的。


## 红黑树深度解析（上）：为何需要“红”与“黑”？

> [!SUMMARY] 前言
> 
> 在我们学习了AVL树后，可能会有一个疑问：AVL树通过严格的平衡因子（高度差不超过1）保证了树的绝对平衡和 O(logn) 的性能，这看起来已经很完美了，为什么我们还需要另一种自平衡二叉搜索树——红黑树呢？
> 
> 答案在于**工程上的权衡**。AVL树的平衡过于“洁癖”，为了维持这种严格的平衡，它可能会进行频繁的旋转操作，这在“写操作”（插入、删除）密集的场景下，会带来较大的性能开销。
> 
> 红黑树则采取了一种更“中庸”、更“务实”的平衡策略。它允许树有轻微的不平衡，以此**换取插入和删除时更少的旋转次数和更快的调整速度**。这种设计哲学上的差异，使得红黑树在写密集型应用中备受青睐。本文作为系列的第一篇，将带你了解红黑树的“世界观”——它的五条核心规则。

### 一、 红黑树的五条核心规则

红黑树本质上也是一棵二叉搜索树，但它额外给每个节点赋予了一个“颜色”属性（**红色**或**黑色**），并通过以下五条规则来维持一种“大致的平衡”：

1. **规则一：** 每个节点要么是**红色**，要么是**黑色**。
    
    - 这是最基本的颜色定义。
        
2. **规则二：** 根节点永远是**黑色**。
    
    - 这条规则为整棵树的颜色和路径计算提供了一个固定的起点。
        
3. **规则三：** 所有叶子节点都是**黑色**的（这里的叶子节点指 `NIL` 或 `NULL` 节点）。
    
    - 在很多实现中，我们并不真的创建这些 `NIL` 节点，而是将 `nullptr` 视为黑色节点。这条规则极大地简化了平衡条件的判断。
        
4. **规则四：** **红色**节点的子节点必须是**黑色**的。
    
    - 换句话说，==从根到叶子的任何路径上，都不能出现两个连续的红色节点==。这是限制树“向高处生长”的关键规则之一。
        
5. **规则五：** 从任意一个节点出发，到达其所有后代叶子节点的**每一条简单路径**上，都包含相同数量的**黑色节点**。
    
    - 这个数量被称为该节点的“**黑高（Black-Height）**”。==这是红黑树保持平衡的、最核心、最精妙的一条规则==。
        

_上图是一棵合法的红黑树。你可以自行验证它是否满足以上五条规则。_

### 二、 五条规则如何保证平衡？

初看这五条规则，可能会觉得有些晦涩和杂乱。但正是它们共同的作用，巧妙地保证了红黑树的高度始终维持在 O(logn) 级别。

其核心逻辑可以这样推导：

- 根据规则4，一条路径上不能有连续的红色节点。这意味着，在任何一条路径上，黑色节点的数量至少占一半（或接近一半）。
    
- 根据规则5，从根到所有叶子节点的路径，其黑色节点的数量（即树的黑高 `bh`）是相等的。
    
- 结合以上两点，我们可以得出结论：
    
    - **最短路径**：完全由黑色节点组成，其长度为 `bh`。
        
    - **最长路径**：由红色和黑色节点交替组成（红-黑-红-黑...），其长度最多为 `2 * bh`。
        

**结论**：一棵红黑树中，==最长路径的长度不会超过最短路径长度的两倍==。这个性质强有力地约束了树的形态，防止其变得过于“瘦高”，从而保证了树的高度 `h` 始终是 O(logn) 的，所有关键操作的性能也就得到了保障。

### 三、 红黑树 vs. AVL树：平衡策略的差异

现在，我们可以更清晰地对比这两种自平衡树：

|特性|AVL树|红黑树|
|---|---|---|
|**平衡策略**|**严格的高度平衡**|**宽松的颜色与黑高平衡**|
|**平衡条件**|任意节点的左右子树高度差绝对值 **≤ 1**|满足五条红黑规则|
|**树的高度**|更低，更接近完美平衡|可能比AVL树稍高|
|**查找性能**|由于树更矮，理论上**查找效率更高**|略低于AVL树，但同为 O(logn)|
|**插入/删除开销**|可能需要**多次旋转**来恢复平衡|**旋转次数更少**（最多2次），更多是通过颜色翻转来调整|
|**综合性能**|**读密集型**场景下有优势|**写密集型**（频繁增删）场景下有优势|



## 红黑树深度解析（中）：庖丁解牛，逐层剖析插入操作

> [!SUMMARY] 前言
> 
> 欢迎来到红黑树系列的中篇。在上篇中，我们已经牢记了定义红黑树的五条核心规则。我们知道，任何一次修改操作都有可能打破这些神圣的“铁律”，而树的自我修复能力，正是其价值所在。
> 
> 本文将聚焦于**插入操作 (Insertion)**，它比删除操作略微简单，是理解红黑树动态平衡的最佳入口。我们将以“庖丁解牛”的精神，放慢脚步，详细拆解插入时的每一种情况、每一步操作、以及其背后的原理。读完本文，你将对红黑树的“红-红冲突”修复机制有一个透彻的理解。

### 一、 插入的第一原则：新节点为何必须是红色？

在深入修复逻辑前，我们必须先理解一个颠扑不破的初始设定：

==向红黑树中插入一个新节点时，我们总是将它标记为红色==。

这是一个基于“最小化破坏”原则的精妙选择。

- **如果插入黑色节点**：
    - **破坏性**：**一定会**违反**规则五**（黑高相等）。因为新节点所在的那条路径上，凭空多出了一个黑色节点，其黑高变为 `bh+1`，而其他路径的黑高仍为 `bh`。
        
    - **修复难度**：修复黑高是一个全局性的问题，通常需要从根节点开始进行复杂的、大范围的调整。
        
- **如果插入红色节点**：
    - **破坏性**：**永远不会**违反规则五，因为红色节点不影响黑高。它唯一可能违反的是**规则四**（无连续红节点），且==**仅在父节点也是红色的情况下才会发生**==。
        
    - **修复难度**：修复“红-红冲突”是一个**局部性**的问题，通常只需要考察祖父节点周围的环境，通过少数几次颜色翻转和旋转即可解决。
        

结论：**插入红色节点，是一种将“必然发生的大麻烦”转化为“可能发生的小麻烦”的高明策略。**

### 二、 家庭会议：定位冲突中的关键角色

当插入一个红色节点 `z`，而其父节点 `p` 恰好也是红色时，“红-红冲突”就爆发了。为了解决冲突，我们需要召开一次“家庭会议”，明确几位关键角色的身份：

- **z**: 新插入的红色节点，是本次冲突的“导火索”。
- **p (Parent)**: `z` 的父节点，也是红色，冲突的直接参与者。
- **g (Grandparent)**: `z` 的祖父节点。由于 `p` 是红色，根据规则四，`g` **必须是黑色**。
- **u (Uncle)**: `z` 的叔叔节点，即 `g` 的另一个孩子。==叔叔的颜色，是解决所有问题的关键钥匙==。
    

### 三、 核心决策：依据叔叔节点的颜色

红黑树的插入修复逻辑，其顶层设计异常简洁，就是一个 `if-else` 判断：

- **`if` 叔叔 `u` 是红色**：执行情况一的处理。
- **`else` (叔叔 `u` 是黑色)**：执行情况二或情况三的处理。

现在，我们来逐一拆解这几种情景。



### **情景一：叔叔是红色 —— “责任共担，矛盾上传”**

这是最简单的一种情况，可以不通过旋转，仅通过**颜色翻转 (Recoloring)** 来解决。

- **类比**：这好比一个局部的“家庭矛盾”，起因是 `p` 和 `z` 两个红色节点“过于亲密”。解决方案是让`p`和`u`两个同辈“承担责任”（变为黑色），同时让长辈`g`“引咎”变为红色，将问题上升一个层级。
    
- **操作步骤**：
    1. 将父节点 `p` 变为**黑色**。
    2. 将叔叔节点 `u` 变为**黑色**。
    3. 将祖父节点 `g` 变为**红色**。

- **图示**：    
    ```
         g(黑)                 g(红) <-- 新的z，问题可能上传
        /   \                 /   \
       p(红) u(红)  ----->   p(黑) u(黑)
      /                     /
     z(红)                 z(红)
    ```
    
- 原理剖析（为何黑高不变？）：
    对于祖父节点 g 之外的任何节点，通往 g 子树的路径上，黑高都没有变化。在 g 的子树内部，原先 ...->g(黑)->p(红)->z(红) 路径的黑高，与翻转后 ...->g(红)->p(黑)->z(红) 路径的黑高是相同的。因此，规则五（黑高相等）得到了完美维持。
    
- 后续影响：
    这次颜色翻转虽然解决了 z 和 p 之间的冲突，但它将祖父节点 g 变成了红色。这可能会导致 g 和它的父节点（曾祖父）产生新的“红-红冲突”。因此，我们需要将 g 视为新的 z，从 g 节点开始，递归地向上继续进行检查和修复。如果 g 是根节点，则直接将其变回黑色，修复结束。
    



### **情景二 & 三：叔叔是黑色 —— “结构性调整，就地解决”**

当叔叔是黑色时，问题无法再通过简单的颜色翻转来“内部消化”，必须通过**旋转**来调整树的结构，从根本上解决冲突。

#### **子情景 2：三角形（Triangle / Zig-Zag）—— “拨乱反正，化曲为直”**
- **成因**：新节点 `z`、父节点 `p` 和祖父节点 `g` 形成了一个“拐角”或“之”字形。例如，`p`是`g`的左孩子，而`z`是`p`的右孩子（LR型）。
    
- **解决方案**：==通过一次旋转，将“三角形”扭转为“直线形”，从而转化为我们最终要处理的子情景3==。
    - 如果是 `左-右` 三角（LR），则对父节点 `p` 进行一次**左旋**。
    - 如果是 `右-左` 三角（RL），则对父节点 `p` 进行一次**右旋**。

- **图示 (以LR为例)**：
![[红黑树 2025-08-10 14.37.05.excalidraw]]
- **后续影响**：执行完旋转后，我们并未完成修复。但此时，树的结构已经变成了更易处理的“直线”形态。原先的`p`成了新的`z`，原先的`z`成了新的`p`，程序流程**直接进入子情景3**。
    

#### **子情景 3：直线（Line / Zig-Zig）—— “乾坤大挪移，一招定乾坤”**

- **成因**：新节点 `z`、父节点 `p` 和祖父节点 `g` 形成了一条直线。这要么是初始插入的状态，要么是由情况二转化而来。
    
- **解决方案**：这是修复的终点。通过一次**颜色翻转**和一次**旋转**即可一招制敌。
    1. 将父节点 `p` 变为**黑色**。
    2. 将祖父节点 `g` 变为**红色**。
    3. 对祖父节点 `g` 进行一次旋转（LL型进行**右旋**，RR型进行**左旋**）。

- **图示 (以LL为例)**：
![[红黑树 2025-08-10 14.48.43.excalidraw]]


- 原理剖析（为何能终止？）：
    旋转和变色后，新子树的根（原p）是黑色的，所以它不可能与它的新父节点（原g的父节点）产生新的“红-红冲突”。同时，可以证明，这个操作巧妙地保持了子树两侧的黑高不变。因此，==整个树的红黑属性都得到了满足，修复过程在此终止==。
    

### 四、 实战演练：跟随一次完整的插入之旅

让我们通过插入序列 `17, 18, 23, 27, 15 , 9 , 6 , 8 , 5 , 25` 来体验这“三板斧”的威力。
![[红黑树 2025-08-10 15.04.38.excalidraw]]


### 五、 结语

红黑树的插入操作，其逻辑看似复杂，但只要我们牢牢抓住**“叔叔节点的颜色”**这个决策点，就能将其分解为清晰的三种情况。

- **叔叔是红色 -> 颜色翻转，矛盾上传。**
    
- **叔叔是黑色 -> 旋转+颜色翻转，矛盾就地解决。**
    

> [!NEXT] 插入操作虽然精妙，但与红黑树的删除操作相比，可以说是“小巫见大巫”。在下一篇，也是本系列的终章**《红黑树深度解析（下）：挑战最复杂的删除操作》**中，我们将挑战红黑树最令人生畏的领域——删除操作及其平衡修复。



好的，同学。在深入探讨最复杂的“删除”操作之前，将我们刚刚学到的“插入”理论转化为一份可以运行、可以调试、可以亲自体验的完整代码，是巩固知识、建立深刻理解的最好方式。

下面的 C++ 代码完整地实现了红黑树的**插入操作**，包括了所有我们讨论过的核心逻辑。我为其添加了非常详尽的注释，并提供了一个直观的树状打印函数，希望能帮助你清晰地看到红黑树在每次插入后是如何通过旋转和颜色翻转来维持平衡的。



#### 代码运行与解读

当你编译并运行上述代码时，你将能清晰地看到我们中篇内容里“实战演练”的每一步：
1. **插入10, 20**: 简单的BST插入，颜色调整。
2. **插入30**: 触发**情况三(RR-直线)**，对`10`进行一次左旋，并伴随颜色翻转。
3. **插入15**: 触发**情况一(叔叔是红色)**，只进行颜色翻转，不旋转。
4. **插入12**: 先触发**情况二(RL-三角形)**，通过一次右旋转化为直线；紧接着进入**情况三(RR-直线)**，再进行一次左旋和颜色翻转，最终达到平衡。

这份代码是你理解红黑树插入操作动态过程的绝佳工具。你可以尝试插入不同的数字序列，观察并对照我们学过的三种情况，来检验你的理解是否深刻。




## 红黑树深度解析（下）：庖丁解牛，征服最复杂的删除操作

> [!SUMMARY] 前言
> 
> 欢迎来到红黑树深度解析系列的终章。在中篇里，我们已经彻底掌握了红黑树插入操作的“三板斧”，并理解了其背后“叔叔决定一切”的清晰逻辑。然而，正如许多数据结构课程中的“最终BOSS”一样，红黑树的删除操作（Deletion），其复杂度和情况之多，远超插入。
> 
> 本文的目标，就是以“庖丁解牛”的精神，将删除操作这个看似庞大而令人生畏的“猛兽”进行彻底的分解。我们将从删除引发问题的根源——“黑高失衡”谈起，引入“双重黑色”这一核心概念，并为你逐一拆解、图示所有修复情况。请相信，只要我们跟随清晰的逻辑，再复杂的算法也能被征服。

### 一、 删除的两个阶段：BST删除 与 平衡修复

红黑树的删除操作，可以清晰地划分为两个阶段：

==**阶段一：执行标准的二叉搜索树（BST）删除**==
我们首先按照我们熟悉的方式，找到目标节点并将其从树中移除。关键在于，我们要关心的是被“物理移除”的那个节点的颜色。

- **情况A（节点有0或1个孩子）**：直接删除该节点，用其唯一的孩子（或NIL）顶替。被物理移除的就是该节点本身。
    
- **情况B（节点有两个孩子）**：找到该节点的**中序后继**（右子树的最小值），用后继节点的值覆盖待删除节点，然后**转化为删除那个后-继节点**。此时，被物理移除的就变成了那个后继节点。


==**阶段二：判断是否需要修复**==
修复与否，完全取决于被物理移除的那个节点的颜色。

- **如果移除的是==红色==节点**：
    - **万事大吉，无需修复！** 因为红色节点不影响黑高（规则五），且其父节点必为黑色，删除它不会产生“红-红冲突”（规则四）。树的所有性质依然保持。
        
- **如果移除的是==黑色==节点**：
    - **灾难降临，必须修复！** 它所在的所有路径都失去了一个黑色节点，严重违反了**规则五（黑高相等）**。


因此，**红黑树的删除修复，本质上就是一场“黑高保卫战”**。

### 二、 核心问题：“双重黑色” (Double Black)

为了修复“黑高失衡”，我们引入一个核心的、逻辑上的概念——**“双重黑色”**。

- **定义**：当一个黑色节点被删除后，为了补偿它所“欠下”的1个黑高，我们将顶替它的那个节点（可能是它的孩子，也可能是逻辑上的NIL叶子节点）视为携带了**双倍的黑色**。这个节点被称为**“双重黑色”节点**。它自身的颜色，叠加上从被删除节点继承来的黑色，共同构成了“双重黑色”。
    
- **修复目标**：==整个修复流程的唯一目的，就是想尽办法消除这个“双重黑色”属性==，将多余的黑色要么吸收掉，要么通过颜色翻转和旋转，在维持整体黑高平衡的前提下，将其推向根节点，最终消除。
    

### 三、 修复策略：兄弟节点的“救赎”

在插入操作中，我们看的是“叔叔”的脸色。而在删除操作中，为我们力挽狂澜的“关键先生”，是那个“双重黑色”节点 `x` 的**兄弟节点 `w`**。

我们将围绕兄弟节点 `w` 及其子节点的颜色，展开四种情况的讨论。



### **情况一：兄弟节点 `w` 是红色**

这种情况本身不解决问题，它的唯一目的，是通过一次“乾坤大挪移”，将场景**转化为后续三种“兄弟是黑色”的情况之一**。

- **图示**:（`x` 是双重黑节点，`p` 是父节点）
![[红黑树 情况一.excalidraw]]
- **操作步骤**:
    1. 将兄弟 `w` 变为**黑色**。
    2. 将父节点 `p` 变为**红色**。
    3. 对父节点 `p` 进行一次**左旋**（假设`x`是左孩子）。
        
- **原理剖析**：
    - 这个操作并未改变任何路径的黑高。
    - 但它成功地让 `x` 的**新兄弟**（原`w`的孩子`c1`）**变成了黑色**。
    - “双重黑色”的问题依然存在于 `x` 身上，但我们现在可以套用下面更强的规则来处理它了。


### **情况二：兄弟 `w` 是黑，且 `w` 的两个孩子都是黑**

这是最简单的“兄弟是黑色”的情况，它通过将问题“甩锅”给父节点来解决局部问题。

- **图示**:
![[红黑树删除(情况二).excalidraw|429]]

- **操作步骤**:
    1. 将兄弟 `w` 变为**红色**。
- **原理剖析**：
    - `x` 路径的黑高亏1，`w` 路径的黑高正常。当 `w` 由黑变红后，`w` 路径的黑高也亏了1。现在 `x` 和 `w` 两条子路径相对于父节点 `p` 重新达到了平衡。
    - 但是，以 `p` 为根的整个子树，相对于整棵树而言，整体亏欠了一个黑色节点。
        
- **后续影响**：
    - 我们将“双重黑色”的属性**传递给父节点 `p`**。
    - 现在，`p` 成为了新的 `x`，我们将**从 `p` 开始，重新进行整个修复流程**。如果 `p` 是根，则它直接由“双重黑”变为“单重黑”，修复结束。
        

---

### **情况三：兄弟 `w` 是黑，`w` 的近孩子是红，远孩子是黑**

这个情况是一个“过渡态”，目的是通过一次局部调整，将场景转化为最终可解的“情况四”。
- **定义**：“近孩子”指 `w` 的孩子中，离 `x` 更近的那个。
- **图示**:
![[红黑树 2025-08-09 22.35.12.excalidraw|659]]

- **操作步骤**:
    1. 将 `w` 的近孩子 `c1` 变为**黑色**。
    2. 将兄弟 `w` 变为**红色**。
    3. 对 `w` 进行一次**右旋**（如果`w`是右孩子）。

- **后续影响**：
    - 此操作将场景**转化为了下面最终的“情况四”**。此时 `x` 的新兄弟是 `c1`，且 `c1` 有一个红色的远孩子（原`w`）。


---

### **情况四：兄弟 `w` 是黑，且 `w` 的远孩子是红**

这是所有修复流程的**终点**。它可以“无中生有”地创造一个黑色节点，彻底解决“双重黑色”问题。

- **图示**（`x`是左孩子，`c2`是远孩子）:
![[红黑树 2025-08-09 22.54.51.excalidraw]]
    
- **操作步骤**:
    1. 将兄弟 `w` 的颜色变得和父节点 `p` **一样**。
    2. 将父节点 `p` 变为**黑色**。
    3. 将 `w` 的远孩子 `c2` 变为**黑色**。
    4. 对父节点 `p` 进行一次**左旋**（如果`x`是左孩子）。

- **原理剖析**:
    - 这个操作极其精妙。它相当于从 `p` 和 `c2`“借调”了颜色，通过旋转重组结构，最终使得 `x` 所在的路径上，有效黑色节点数加一（新父节点`w`贡献了原`p`的颜色，而`p`自身变黑）。
        
- **后续影响**：
    - ==“双重黑色”被彻底消除，`x` 变成“单重黑色”==。树的所有性质恢复，修复过程到此终止。


### 删除例子

![[红黑树 2025-08-10 16.14.36.excalidraw]]


### 五、 总结与系列完结

红黑树的删除操作，其核心就是一套围绕“双重黑色”节点的消除规则。虽然情况比插入多，但逻辑依然清晰：

- **核心目标**：消除“双重黑色”。
    
- **核心手段**：观察“双重黑色”节点的兄弟 `w`。
    
- **决策路径**：
    - `w` 是红色？ -> **情况一** -> 转化为 `w` 是黑色的情况。
    - `w` 是黑色？
        - 孩子全黑？ -> **情况二** -> 将问题上传给父节点。
        - 近孩子是红？ -> **情况三** -> 转化为情况四。
        - 远孩子是红？ -> **情况四** -> 问题终结。


至此，我们已经完整地走过了红黑树从定义、插入到删除的全过程。它用一种看似更宽松、更复杂的规则，换来了在频繁写操作场景下更高的综合效率，这正是它在众多标准库中被广泛应用的原因。

恭喜你，同学！完成了对红黑树这座高山的攀登。希望这个系列能为你构建一个坚实的数据结构与算法知识体系，添上重要的一块基石。