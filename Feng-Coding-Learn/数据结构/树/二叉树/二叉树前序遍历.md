---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-05 21:55
Finish-date: 
Modified-date: 2025-08-05 22:09
Publish: false
---
好的，同学！在掌握了两种经典的排序算法后，我们进入数据结构的核心——**树**，并从其最基本、最重要的操作“遍历”开始。

今天我们的复习目标是**二叉树的前序遍历**，包括其递归与非递归两种实现。这不仅是树相关问题的基础，其非递归实现更是深刻体现了“栈”这一数据结构的妙用。

---

# 二叉树遍历之核心：前序遍历的递归与非-递归深度解析

> [!SUMMARY] 前言
> 
> 如果说数组和链表是线性世界的基石，那么树则开启了非线性世界的大门。想要探索树的每一个角落，就必须掌握其遍历方法。在所有遍历方式中，深度优先搜索（DFS）一系的前序、中序、后序遍历，构成了所有树相关算法的基石。
> 
> 本文将聚焦于三者中最直观、最基础的**前序遍历**。我们将从其定义出发，用最清晰的图解和类比，为你呈现其递归与非递归两种实现方式的编码细节与思想差异。理解了前序遍历，你对树的理解、对递归、乃至对栈的运用都将迈上一个新的台阶。

## 一、 什么是前序遍历？

前序遍历（Pre-order Traversal）是深度优先遍历的一种。它的访问顺序遵循一个极其简单且重要的规则。

**黄金法则：** **根 -> 左 -> 右**
这三个字就是前序遍历的全部精髓。具体来说，当遍历到任意一个节点时，我们都遵循以下三步：
1. **访问根节点**：首先处理当前节点本身（比如，打印它的值）。
2. **遍历左子树**：然后，递归地对当前节点的整个左子树进行前序遍历。
3. **遍历右子树**：最后，递归地对当前节点的整个右子树进行前序遍历。


### 图解与示例

让我们用一个具体的二叉树来看看前序遍历的路径：

```
      (F)
      / \
    (B) (G)
    / \   \
  (A) (D) (I)
      / \   /
    (C) (E) (H)
```

按照 **根 -> 左 -> 右** 的规则，遍历过程如下：

1. 从根节点 **F** 开始，访问 **F**。 `结果: [F]`
2. 去 **F** 的左子树（以B为根）。访问根节点 **B**。`结果: [F, B]`
3. 去 **B** 的左子树（以A为根）。访问根节点 **A**。`结果: [F, B, A]`
4. A没有左右子树，返回B。
5. 去 **B** 的右子树（以D为根）。访问根节点 **D**。`结果: [F, B, A, D]`
6. 去 **D** 的左子树（以C为根）。访问根节点 **C**。`结果: [F, B, A, D, C]`
7. C没有左右子树，返回D。
8. 去 **D** 的右子树（以E为根）。访问根节点 **E**。`结果: [F, B, A, D, C, E]`
9. E没有左右子树，返回D，返回B，返回F。
10. F的左子树全部遍历完毕。现在去 **F** 的右子树（以G为根）。访问根节点 **G**。`结果: [F, B, A, D, C, E, G]`
11. G没有左子树。去 **G** 的右子树（以I为根）。访问根节点 **I**。`结果: [F, B, A, D, C, E, G, I]`
12. 去 **I** 的左子树（以H为根）。访问根节点 **H**。`结果: [F, B, A, D, C, E, G, I, H]`
13. H没有左右子树，返回I。I没有右子树，遍历结束。


最终的前序遍历序列为：`F -> B -> A -> D -> C -> E -> G -> I -> H`

## 二、 递归实现：最直观的代码表达

递归的实现方式是前序遍历定义最直接、最优雅的翻译。代码的结构与“根->左->右”的规则完全对应。
### 代码实现与解析

首先，我们需要一个二叉树节点的定义。

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stack>

// 定义二叉树节点
struct TreeNode {
    std::string val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(std::string x) : val(x), left(nullptr), right(nullptr) {}
};
```

接下来是递归函数的实现。

```cpp
/**
 * @brief 前序遍历的递归辅助函数
 * @param root 当前子树的根节点
 * @param result 用于存储遍历结果的向量
 */
void preorderRecursive(TreeNode* root, std::vector<std::string>& result) {
    // 递归的终止条件：如果节点为空，则直接返回
    if (root == nullptr) {
        return;
    }

    // 1. 访问根节点 (根)
    result.push_back(root->val);

    // 2. 递归遍历左子树 (左)
    preorderRecursive(root->left, result);

    // 3. 递归遍历右子树 (右)
    preorderRecursive(root->right, result);
}

/**
 * @brief 前序遍历的主函数（递归版）
 * @param root 树的根节点
 * @return 包含前序遍历结果的向量
 */
std::vector<std::string> preorderTraversal_Recursive(TreeNode* root) {
    std::vector<std::string> result;
    preorderRecursive(root, result);
    return result;
}

// ---- 测试代码 ----
void printVector(const std::vector<std::string>& vec) {
    for (const auto& val : vec) {
        std::cout << val << " ";
    }
    std::cout << std::endl;
}

int main() {
    // 构建示例树
    TreeNode* root = new TreeNode("F");
    root->left = new TreeNode("B");
    root->right = new TreeNode("G");
    root->left->left = new TreeNode("A");
    root->left->right = new TreeNode("D");
    root->left->right->left = new TreeNode("C");
    root->left->right->right = new TreeNode("E");
    root->right->right = new TreeNode("I");
    root->right->right->left = new TreeNode("H");

    std::cout << "Recursive Pre-order Traversal:" << std::endl;
    std::vector<std::string> result_rec = preorderTraversal_Recursive(root);
    printVector(result_rec);

    // ... 非递归测试代码将放在下一节 ...
    return 0;
}
```

#### 代码解析
- **优雅简洁**：递归代码非常短，完美地反映了算法的定义。每一行都清晰地对应着“根”、“左”、“右”中的一步。
    
- **隐式栈**：函数调用栈在后台默默地为我们处理了所有事情。当我们从左子树返回时，调用栈会自动恢复到上一层节点的状态，让我们能接着去访问右子树。
    

## 三、 非递归实现：用栈模拟递归的艺术

虽然递归很美，但在处理极端情况（如树非常深或倾斜）时可能会导致栈溢出。非递归实现通过手动维护一个栈，提供了更强的健壮性，同时也能加深我们对遍历本质的理解。

### 核心思想：栈（Stack）的运用

递归的本质是“后进先出”（LIFO），一个函数调用了其子函数，必须等子函数执行完毕才能继续。这与数据结构**栈**的特性完全吻合。我们可以用一个栈来模拟函数调用栈的行为，手动管理“待访问”的节点。

### 算法步骤
1. 创建一个栈，并将根节点压入栈中。
2. 当栈不为空时，循环执行以下操作：
    a. 从栈顶弹出一个节点 node。
    b. 访问这个节点 node（将其值存入结果列表）。
    c. 关键一步：将 node 的子节点压入栈中，以便后续访问。为了实现“根->左->右”的顺序，我们必须==先访问左，再访问右==。由于栈是后进先出的，所以我们必须先把右孩子压入栈，再把左孩子压入栈。这样，下一轮循环从栈顶弹出的就自然是左孩子了。
    

### 代码实现与深度解析

```cpp
/**
 * @brief 前序遍历的非递归（迭代）实现
 * @param root 树的根节点
 * @return 包含前序遍历结果的向量
 */
std::vector<std::string> preorderTraversal_Iterative(TreeNode* root) {
    std::vector<std::string> result;
    if (root == nullptr) {
        return result;
    }

    // 1. 创建一个栈用于模拟递归过程
    std::stack<TreeNode*> node_stack;
    
    // 2. 将根节点作为起始任务压入栈中
    node_stack.push(root);

    // 3. 当栈不为空时，说明还有待处理的节点
    while (!node_stack.empty()) {
        // a. 从栈顶弹出一个节点
        TreeNode* current_node = node_stack.top();
        node_stack.pop();

        // b. 访问该节点
        result.push_back(current_node->val);

        // c. 将子节点压入栈中，注意顺序！
        // 因为栈是后进先出，要先访问左子树，所以要后压入左孩子
        
        // 如果有右孩子，先将右孩子压栈
        if (current_node->right != nullptr) {
            node_stack.push(current_node->right);
        }
        // 如果有左孩子，再将左孩子压栈
        if (current_node->left != nullptr) {
            node_stack.push(current_node->left);
        }
    }

    return result;
}

// 在 main 函数中添加测试
int main() {
    // ... 构建树的代码同上 ...
    TreeNode* root = new TreeNode("F");
    root->left = new TreeNode("B");
    root->right = new TreeNode("G");
    // ... (省略其他节点的创建，与递归部分相同)
    root->left->left = new TreeNode("A");
    root->left->right = new TreeNode("D");
    root->left->right->left = new TreeNode("C");
    root->left->right->right = new TreeNode("E");
    root->right->right = new TreeNode("I");
    root->right->right->left = new TreeNode("H");

    std::cout << "Recursive Pre-order Traversal:" << std::endl;
    std::vector<std::string> result_rec = preorderTraversal_Recursive(root);
    printVector(result_rec); // 输出: F B A D C E G I H 

    std::cout << "\nIterative Pre-order Traversal:" << std::endl;
    std::vector<std::string> result_iter = preorderTraversal_Iterative(root);
    printVector(result_iter); // 输出: F B A D C E G I H 

    return 0;
}
```

#### 深度解析与流程模拟

让我们模拟一下非递归版本是如何工作的：

1. **开始**: `stack: [F]`, `result: []`
    
2. **第1步**: 弹出 `F`。`result: [F]`。将 G(右) 和 B(左) 压栈。`stack: [G, B]`
    
3. **第2步**: 弹出 `B`。`result: [F, B]`。将 D(右) 和 A(左) 压栈。`stack: [G, D, A]`
    
4. **第3步**: 弹出 `A`。`result: [F, B, A]`。A无子节点。`stack: [G, D]`
    
5. **第4步**: 弹出 `D`。`result: [F, B, A, D]`。将 E(右) 和 C(左) 压栈。`stack: [G, E, C]`
    
6. **第5步**: 弹出 `C`。`result: [F, B, A, D, C]`。C无子节点。`stack: [G, E]`
    
7. **第6步**: 弹出 `E`。`result: [F, B, A, D, C, E]`。E无子节点。`stack: [G]`
    
8. **...** 这个过程会一直持续下去，其访问顺序与递归版本完全一致。
    

## 四、 结语

前序遍历是理解树结构和相关算法的第一把钥匙。

- **递归实现**以其极致的简洁和优雅，成为我们思考和白板编程时的首选。
    
- **非递归实现**则通过巧妙地使用栈，向我们展示了如何将一个递归过程转化为迭代过程，这不仅能解决栈溢出的工程问题，其思想更是许多复杂算法（如图的深度优先搜索）的基石。
    

掌握了前序遍历的两种形态，你就可以充满信心地去挑战中序和后序遍历了。