---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-05 22:22
Finish-date: 
Modified-date: 
Publish: false
---





# 二叉树遍历之核心：后序遍历的递归与非递归深度解析

> [!SUMMARY] 前言
> 
> 在深度优先遍历的三种主要方式中，后序遍历（Post-order Traversal）通常被认为是理解和实现起来最具挑战性的一种，尤其是其非递归版本。它的“左 -> 右 -> 根”的访问顺序，决定了它在许多实际场景中扮演着不可或缺的角色。
> 
> 最典型的应用就是**释放（或销毁）一棵树的节点**。我们必须先释放一个节点的左右孩子，然后才能安全地释放该节点本身，这与后序遍历的顺序完全吻合。本文将带你深入后序遍历的世界，不仅会展示其简洁的递归实现，更会详细剖析两种主流的、极具技巧性的非递归实现方法。

## 一、 什么是后序遍历？

后序遍历，即“最后访问根节点”。它要求在处理任何一个节点之前，必须先完整地处理完它的整个左子树和整个右子树。

**黄金法则：** **左 -> 右 -> 根**

具体来说，当遍历到任意一个节点时，我们都遵循以下三步：
1. **遍历左子树**：递归地对当前节点的整个左子树进行后序遍历。
2. **遍历右子树**：递归地对当前节点的整个右子树进行后序遍历。
3. **访问根节点**：当左右子树全部遍历完毕后，最后才处理当前节点本身。


### 类比与理解

后序遍历好比一个严谨的“项目签收”流程。一个项目经理（根节点）要最终签字确认项目完成，他必须：
1. 等待左边的技术部门完成所有开发和测试，并提交报告。
2. 再等待右边的市场部门完成所有推广和部署，并提交报告。
3. 只有当两个子部门都明确表示工作完成后，项目经理才能在总结报告上签下自己的名字（访问根节点）。


### 图解与示例

我们继续使用之前的二叉树作为示例：

```
      (F)
      / \
    (B) (G)
    / \   \
  (A) (D) (I)
      / \   /
    (C) (E) (H)
```

按照 **左 -> 右 -> 根** 的规则，遍历过程如下：

1. 从根 **F** 开始，需要先遍历其左子树（以B为根）。
2. 到达 **B**，需要先遍历其左子树（以A为根）。
3. 到达 **A**，A没有左、右子树。访问 **A**。`结果: [A]`
4. 返回B。B的左子树完成，现在遍历B的右子树（以D为根）。
5. 到达 **D**，先遍历其左子树（以C为根）。
6. 到达 **C**，C没有子树。访问 **C**。`结果: [A, C]`
7. 返回D。D的左子树完成，遍历D的右子树（以E为根）。
8. 到达 **E**，E没有子树。访问 **E**。`结果: [A, C, E]`
9. 返回D。D的左右子树均完成。访问 **D**。`结果: [A, C, E, D]`
10. 返回B。B的左右子树均完成。访问 **B**。`结果: [A, C, E, D, B]`
11. 返回F。F的左子树完成，遍历F的右子树（以G为根）。
12. ... 以此类推 ...
    

最终的后序遍历序列为：`A -> C -> E -> D -> B -> H -> I -> G -> F`

## 二、 递归实现：定义即代码

和前两种遍历一样，递归是后序遍历定义最直接的体现，代码风格与思想高度一致。

### 代码实现与解析

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <algorithm> // 用于 std::reverse

// 定义二叉树节点 (与上一篇相同)
struct TreeNode {
    std::string val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(std::string x) : val(x), left(nullptr), right(nullptr) {}
};

/**
 * @brief 后序遍历的递归辅助函数
 * @param root 当前子树的根节点
 * @param result 用于存储遍历结果的向量
 */
void postorderRecursive(TreeNode* root, std::vector<std::string>& result) {
    if (root == nullptr) {
        return;
    }

    // 1. 递归遍历左子树 (左)
    postorderRecursive(root->left, result);

    // 2. 递归遍历右子树 (右)
    postorderRecursive(root->right, result);

    // 3. 访问根节点 (根)
    result.push_back(root->val);
}

/**
 * @brief 后序遍历的主函数（递归版）
 */
std::vector<std::string> postorderTraversal_Recursive(TreeNode* root) {
    std::vector<std::string> result;
    postorderRecursive(root, result);
    return result;
}

// ... 测试用的 printVector 和 main 函数框架与前文相同 ...
```

## 三、 非递归实现：最具技巧的挑战

后序遍历的非递归实现是三者中最复杂的。根本的挑战在于：当一个节点位于栈顶时，我们无法立刻确定是否可以访问它。因为我们得知道它的右子树是否已经被访问过了。为了解决这个问题，主要有两种巧妙的思路。

### 方法一：前序遍历的“逆向思维”法（双栈或逆序法）

这是一种非常聪明的“作弊”方法，它将后序遍历问题转化为了一个我们已经解决过的前序遍历问题。

**核心思路：**
1. 我们知道，**前序**遍历是 `根 -> 左 -> 右`。
2. 如果我们稍微修改一下，得到一个 `根 -> 右 -> 左` 的遍历顺序，结果会是怎样？对于我们的示例树，结果是 `F -> G -> I -> H -> B -> D -> E -> C -> A`。
3. 现在，请把上面这个序列**完全逆序**！你会得到： `A -> C -> E -> D -> B -> H -> I -> G -> F`。
4. ==这正是后序遍历 `左 -> 右 -> 根` 的结果！==
    

所以，算法就变成了：
1. 写一个前序遍历的非递归版本，但是把“先压右再压左”的顺序，**换成“先压左再压右”**。
2. 将每次访问的节点值存起来。
3. 最后**将整个结果序列反转**。
    

#### 代码实现

```cpp
/**
 * @brief 后序遍历的非递归实现 - 方法1：修改前序 + 结果逆序
 */
std::vector<std::string> postorderTraversal_Iterative_Reverse(TreeNode* root) {
    std::vector<std::string> result;
    if (root == nullptr) {
        return result;
    }

    std::stack<TreeNode*> node_stack;
    node_stack.push(root);

    while (!node_stack.empty()) {
        TreeNode* current_node = node_stack.top();
        node_stack.pop();
        
        // 访问节点，存入结果
        result.push_back(current_node->val);

        // 与前序遍历相反，先压左孩子，再压右孩子
        if (current_node->left != nullptr) {
            node_stack.push(current_node->left);
        }
        if (current_node->right != nullptr) {
            node_stack.push(current_node->right);
        }
    }
    
    // 将最终结果反转
    std::reverse(result.begin(), result.end());
    
    return result;
}
```

#### 代码解析
- **优点**：代码逻辑非常清晰，几乎是前序遍历的翻版，容易理解和实现。
- **缺点**：需要额外的空间来存储中间结果，并且最后还有一个 `reverse` 操作的开销。但在大多数情况下，这是一种非常实用且高效的方法。
    

### 方法二：单栈法 + 标记指针
这是更“正统”也更复杂的实现，它只用一个栈，但需要引入一个额外的指针 `prev` 来记录上一个被访问的节点，以此来判断当前节点右子树的访问状态。

核心思想：
当栈顶的节点node被我们“看到”时，有三种情况：
1. 我们是从它的左子树一路探索过来的。此时，我们应该去探索它的右子树。
2. 我们是从它的右子树返回的。此时，它的左右子树都已访问完毕，轮到访问它自己了。
3. 它没有右子树。此时，它的左子树必然已经访问完毕，也轮到访问它自己了。

`prev` 指针就是用来区分情况1和情况2的。

#### 代码实现

```cpp
/**
 * @brief 后序遍历的非递归实现 - 方法2：单栈 + 标记指针
 */
std::vector<std::string> postorderTraversal_Iterative_OneStack(TreeNode* root) {
    std::vector<std::string> result;
    if (root == nullptr) {
        return result;
    }

    std::stack<TreeNode*> node_stack;
    TreeNode* current = root;
    TreeNode* prev = nullptr; // 记录上一个被访问的节点

    // 先将所有左节点压栈
    while (current != nullptr) {
        node_stack.push(current);
        current = current->left;
    }

    while (!node_stack.empty()) {
        // 查看栈顶节点，先不弹出
        current = node_stack.top();

        // 判断何时可以访问当前节点：
        // 1. 它的右孩子为空
        // 2. 它的右孩子刚刚被访问过 (prev == current->right)
        if (current->right == nullptr || current->right == prev) {
            // 如果满足条件，访问它
            result.push_back(current->val);
            // 弹出
            node_stack.pop();
            // 更新 prev 指针
            prev = current;
        } else {
            // 如果不满足，说明右子树还没被访问
            // 我们需要去处理右子树
            current = current->right;
            // 对右子树重复“一路向左”的过程
            while (current != nullptr) {
                node_stack.push(current);
                current = current->left;
            }
        }
    }
    return result;
}
```

#### 深度解析
- **`prev` 指针是关键**：`prev` 就像一个标记，告诉我们“回头路”是从哪里来的。`if (current->right == prev)` 这个判断，精准地识别出我们是从右子树返回的。
    
- **逻辑更复杂**：这个方法的控制流比前两种遍历都要复杂，需要仔细思考 `if/else` 分支的条件，但它没有使用额外的数据结构（除了栈），且没有最后的反转步骤。
    

## 四、 结语
至此，我们完成了二叉树深度优先遍历三剑客的全部复习。后序遍历以其独特的“根在最后”的特性，在特定场景下不可或缺。

- **递归实现**：依然是描述算法思想最清晰的方式。
- **非递归实现**：
    - **逆序法**：==巧妙、实用，易于编码==，是面试中快速写出正确代码的绝佳选择。
    - **单栈法**：==技巧性强，更能体现对算法的深入理解==，展现了用标记位解决复杂状态判断的能力。


恭喜你！完成了对二叉树三种核心遍历方式的学习。这为你后续深入学习更复杂的树算法，如构建二叉树、查找公共祖先、树的序列化等，打下了坚实的基础。