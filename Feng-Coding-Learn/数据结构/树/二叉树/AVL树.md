---
Type: Note
tags:
  - 数据结构
  - CPP
Status: writing
Start-date: 2025-08-07 21:51
Finish-date: 
Modified-date: 
Publish: false
---


## AVL树深度解析（上）：平衡的追求与核心法则

> [!SUMMARY] 前言
> 
> 在上一个时代，二叉搜索树（BST）以其 O(logn) 的平均查找效率，成为了数据检索领域的明星。然而，这位明星却有着一个不为人知的“性格缺陷”——它的性能极度依赖于“出场顺序”（数据的插入顺序）。在面对有序数据时，它的表现会灾难性地退化。
> 
> 本文是AVL树深度解析系列的第一部分。在这一部分，我们将首先直面BST的性能困境，理解为何“平衡”如此重要。然后，我们将详细介绍AVL树是如何定义“平衡”的——即其核心的**平衡因子**法则。只有深刻理解了“是什么”和“为什么”，我们才能在下一部分中更好地掌握“怎么办”（旋转操作）。

### 一、 AVL树的诞生：为何需要平衡？

让我们先来看一个直观的对比，理解“平衡”对于一棵搜索树意味着什么。

**场景一：理想情况**
我们向一棵空树中插入序列 [4, 2, 6, 1, 3, 5, 7]，会得到一棵形态优美、近乎完美的平衡二叉树：

```
      (4)
      / \
    (2) (6)
    / \   / \
  (1) (3) (5) (7)
```

这棵树的高度为2，查找任何一个元素，最多只需要比较3次。其查找效率是卓越的 O(logn)。


**场景二：最坏情况**
我们向一棵空树中插入一个有序序列 [1, 2, 3, 4, 5, 6, 7]，会得到一棵严重倾斜的“退化”树：

```
(1)
 \
  (2)
   \
    (3)
     \
      (4)
       \
        (5)
         \
          (6)
           \
            (7)
```

这棵所谓的“树”，其形态和性能已经与一个**链表**无异。它的高度为6，查找元素7需要比较7次。其查找效率已退化为糟糕的 O(n)。

这个性能上的巨大鸿沟是不可接受的。我们需要一种机制，让树在每次插入或删除后，都能**自动进行调整**，阻止其“变长”，时刻保持“矮胖”的平衡体型。于是，AVL树应运而生。

### 二、 AVL树的核心法则

AVL树通过强制遵守一个额外的、严格的平衡条件，来保证其高效性能。

法则一：它首先是一棵二叉搜索树（BST）
- 这保证了其基础的、可用于快速查找的序关系：左子节点 < 根节点 < 右子节点。

**法则二：它必须满足“AVL平衡条件”**

> 对于树中的**任意一个节点**，其**左子树**和**右子树**的**高度差**的绝对值**不能超过 1**。

- 为了精确地描述和检查这个条件，我们引入两个重要的概念：

#### 1. 高度 (Height)
- 一个**叶子节点**的高度为 **0**。
- 一个**空树 (nullptr)** 的高度规定为 **-1**。（这个规定是为了方便计算）
- 一个非叶子节点的高度 = `1 + max(其左子树的高度, 其右子树的高度)`。


#### 2. 平衡因子 (Balance Factor, BF)
每个节点的平衡因子被定义为：
平衡因子 = 左子树高度 - 右子树高度
根据AVL的平衡条件，树中所有节点的平衡因子只能是以下三种值之一：
- **BF = 1**：左子树比右子树高 1，我们称之为“左倾”（Left-heavy）。
- **BF = 0**：左右子树等高，完美平衡。
- **BF = -1**：右子树比左子树高 1，我们称之为“右倾”（Right-heavy）。
    

**当一个节点的平衡因子的绝对值变为2（即BF = +2 或 -2）时，我们就称该节点“失衡 (Unbalanced)”，AVL树的平衡被破坏，必须立即进行调整。**

让我们看一个实际的例子：
```
      (A) BF=0, H=2
      / \
(B) BF=1, H=1     (C) BF=0, H=0
    /
(D) BF=0, H=0
```

- **节点D, C**: 是叶子节点，高度 `H=0`。左右子树都是空（H=-1），所以 `BF = -1 - (-1) = 0`。
- **节点B**: 左子树是D（H=0），右子树为空（H=-1）。`H(B) = 1 + max(0, -1) = 1`。`BF(B) = 0 - (-1) = 1`。
- **节点A**: 左子树是B（H=1），右子树是C（H=0）。`H(A) = 1 + max(1, 0) = 2`。`BF(A) = 1 - 0 = 1`。
    
这棵树中所有节点的平衡因子都在 `{-1, 0, 1}` 的集合内，所以它是一棵合法的AVL树。

好的，同学！我们马上发布系列的第二部分，也是最核心、最激动人心的部分。

在上一篇文章中，我们已经学会了如何通过“平衡因子”来诊断一棵树是否“失衡”。现在，我们将深入学习如何通过精妙的“外科手术”——**旋转**，来治愈失衡，让AVL树永葆青春。

---


#### 1. 左旋 (Left Rotation)

- **时机**：当一个节点 `z` 的**右子树过高**，导致其平衡因子变为 `-2` 时使用。
    
- **目标**：将右子树“提上来”，让它成为新的根，从而降低右侧的高度，增加左侧的高度。
    
- **过程图解**：
    
    - `y` 是 `z` 的右孩子，`T2` 是 `y` 的左子树。
        
    - 旋转后，`y` 成为新的根。
        
    - `z` 成为 `y` 的左孩子。
        
    - `y` 原本的左子树 `T2`，现在成为了 `z` 的新右孩子。
        
- **代码实现**：
    

    ```cpp
    // 假设我们有AVLNode的定义，且每个节点包含height成员
    // struct AVLNode { int val; int height; AVLNode *left, *right; ... };
    
    // 获取节点高度的辅助函数
    int getHeight(AVLNode* node) {
        return (node == nullptr) ? -1 : node->height;
    }
    
    /**
     * @brief 对节点 z 进行左旋
     * @param z 失衡的节点
     * @return 旋转后该子树的新根节点 y
     */
    AVLNode* leftRotate(AVLNode* z) {
        AVLNode* y = z->right;
        AVLNode* T2 = y->left;
    
        // 开始旋转
        y->left = z;
        z->right = T2;
    
        // **关键**：更新受影响节点的高度
        // 必须先更新子节点 z 的高度，再更新新根 y 的高度
        z->height = 1 + std::max(getHeight(z->left), getHeight(z->right));
        y->height = 1 + std::max(getHeight(y->left), getHeight(y->right));
    
        // 返回旋转后子树的新根
        return y;
    }
    ```
    

#### 2. 右旋 (Right Rotation)

- **时机**：当一个节点 `z` 的**左子树过高**，导致其平衡因子变为 `+2` 时使用。
    
- **目标**：将左子树“提上来”，成为新的根。
    
- **过程图解**：
    
- **代码实现**：
    
    C++
    
    ```
    /**
     * @brief 对节点 z 进行右旋
     * @param z 失衡的节点
     * @return 旋转后该子树的新根节点 y
     */
    AVLNode* rightRotate(AVLNode* z) {
        AVLNode* y = z->left;
        AVLNode* T3 = y->right;
    
        // 开始旋转
        y->right = z;
        z->left = T3;
    
        // 更新高度
        z->height = 1 + std::max(getHeight(z->left), getHeight(z->right));
        y->height = 1 + std::max(getHeight(y->left), getHeight(y->right));
    
        return y;
    }
    ```
    

### 二、 四种失衡情况与应对策略

掌握了基础旋转后，我们就可以像拼装乐高一样，来解决所有四种失衡情况了。假设失衡的节点是 `z`，新插入的节点是 `x`。

---

#### 情况一：左-左 (LL) 失衡

- **成因**：新节点 `x` 插入到了失衡节点 `z` 的**左孩子 `y`** 的**左子树**中。
    
- **特征**：`BF(z) = +2`, `BF(y) = +1`。
    
- **图示**：
    
- **解决方案**：对失衡节点 `z` 进行一次**右旋**。
    
- **代码逻辑**（在`insert`函数递归返回的路径上）：
    
    C++
    
    ```
    // 检查平衡因子
    int balance = getBalanceFactor(node);
    
    // LL Case
    if (balance > 1 && getBalanceFactor(node->left) >= 0) { //  或者用新插入的key来判断
        return rightRotate(node);
    }
    ```
    

---

#### 情况二：右-右 (RR) 失衡

- **成因**：新节点 `x` 插入到了失衡节点 `z` 的**右孩子 `y`** 的**右子树**中。
    
- **特征**：`BF(z) = -2`, `BF(y) = -1`。
    
- **图示**：
    
- **解决方案**：对失衡节点 `z` 进行一次**左旋**。
    
- **代码逻辑**：
    
    C++
    
    ```
    // ...
    // RR Case
    if (balance < -1 && getBalanceFactor(node->right) <= 0) {
        return leftRotate(node);
    }
    ```
    

---

#### 情况三：左-右 (LR) 失衡

- **成因**：新节点 `x` 插入到了失衡节点 `z` 的**左孩子 `y`** 的**右子树**中。这是一个“拐弯”的情况。
    
- **特征**：`BF(z) = +2`, `BF(y) = -1`。
    
- **图示**：
    
- **解决方案**：==需要两次旋转==。直接对 `z` 右旋无法解决问题。
    
    1. **先对 `y` 进行一次左旋**，将树的形态调整为 LL 型。
        
    2. **再对 `z` 进行一次右旋**，完成最终的平衡。
        
- **代码逻辑**：
    
    C++
    
    ```
    // ...
    // LR Case
    if (balance > 1 && getBalanceFactor(node->left) < 0) {
        node->left = leftRotate(node->left); // 步骤1
        return rightRotate(node);            // 步骤2
    }
    ```
    

---

#### 情况四：右-左 (RL) 失衡

- **成因**：新节点 `x` 插入到了失衡节点 `z` 的**右孩子 `y`** 的**左子树**中。这是另一个“拐弯”的情况。
    
- **特征**：`BF(z) = -2`, `BF(y) = +1`。
    
- **图示**：
    
- **解决方案**：==同样需要两次旋转==。
    
    1. **先对 `y` 进行一次右旋**，将树的形态调整为 RR 型。
        
    2. **再对 `z` 进行一次左旋**，完成最终的平衡。
        
- **代码逻辑**：
    
    C++
    
    ```
    // ...
    // RL Case
    if (balance < -1 && getBalanceFactor(node->right) > 0) {
        node->right = rightRotate(node->right); // 步骤1
        return leftRotate(node);                // 步骤2
    }
    ```
    

### 三、 总结与展望

在本文（下篇）中，我们掌握了AVL树进行自我修复的全部“手术”技巧：

- **两个基础动作**：左旋和右旋。
    
- **四个应对处方**：LL、RR、LR、RL，它们分别由单次或两次基础旋转组合而成。


至此，AVL树的核心理论已经全部展现在你的面前。它通过在每次修改操作后，从被修改的节点向上回溯，检查路径上每个节点的平衡因子，一旦发现失衡，立即调用对应的旋转处方进行修复。正是这套严密的==“诊断-治疗”==机制，保证了AVL树永不“退化”，使其所有关键操作的性能都能稳定在高效的 O(logn)。

接下来，你可以尝试将这些碎片化的代码逻辑，整合到一个完整的AVL树类中，亲手实现它的 `insert` 和 `delete` 方法。这将是一次极具价值的编码实践。同时，你也可以开始了解另一种著名的自平衡树——**红黑树**，去探索它与AVL树在平衡策略和性能权衡上的不同之处。