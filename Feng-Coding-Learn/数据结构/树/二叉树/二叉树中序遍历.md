---
Type: Note
tags: 
Status: writing
Start-date: 2025-08-05 22:09
Finish-date: 
Modified-date: 2025-08-06 13:00
Publish: false
---


# 二叉树遍历之核心：中序遍历的递归与非递归深度解析

> [!SUMMARY] 前言
> 
> 在深度优先遍历的三剑客（前、中、后序）中，中序遍历（In-order Traversal）扮演着一个非常特殊的角色。它不仅是一种基础的节点访问方式，更因其一个神奇的特性而闻名遐迩：==对一个二叉搜索树（BST）进行中序遍历，得到的结果是一个严格递增的有序序列==。这个特性使得中序遍历成为验证和利用BST性质的关键工具。
> 
> 本文将带你深入中-序遍历的“左-根-右”黄金法则，并详细拆解其递归与非递归两种实现。特别是其非递归实现，比前序遍历要精妙和复杂，能极大地提升你对栈与指针组合运用的理解。

[94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

## 一、 什么是中序遍历？

中序遍历，顾名思义，即“中间访问根节点”。它的访问顺序同样遵循一个简单而深刻的规则。

**黄金法则：** **左 -> 根 -> 右**

这意味着，当遍历到任意一个节点时，我们必须遵循以下三步：
1. **遍历左子树**：递归地对当前节点的整个左子树进行中-序遍历。
2. **访问根节点**：当整个左子树遍历完毕后，才处理当前节点本身（比如，打印它的值）。
3. **遍历右子树**：最后，递归地对当前节点的整个右子树进行中-序遍历。


### 类比与理解

如果说前序遍历是“领导先发言”，那么中序遍历就是“等下属汇报完再总结”。领导到达一个部门（根节点）后，他会说：“我先不说话，让左边的子部门先完成他们的内部讨论并汇报。” 直到左边子部门所有人都汇报完毕，领导才发表自己的意见（访问根节点）。然后，他再让右边的子部门开始他们的汇报。

### 图解与示例

我们继续使用上一篇文章中的二叉树，以便清晰地对比不同遍历方式的结果。

```
      (F)
      / \
    (B) (G)
    / \   \
  (A) (D) (I)
      / \   /
    (C) (E) (H)
```

按照 **左 -> 根 -> 右** 的规则，遍历过程如下：

1. 从根 **F** 开始，需要先遍历其左子树（以B为根）。
2. 到达 **B**，需要先遍历其左子树（以A为根）。
3. 到达 **A**，A没有左子树。于是访问 **A**。`结果: [A]`
4. A没有右子树，返回B。B的左子树已完成，现在访问 **B**。`结果: [A, B]`
5. 现在遍历 **B** 的右子树（以D为根）。
6. 到达 **D**，需要先遍历其左子树（以C为根）。
7. 到达 **C**，C没有左子树。访问 **C**。`结果: [A, B, C]`
8. C没有右子树，返回D。D的左子树已完成，访问 **D**。`结果: [A, B, C, D]`
9. 遍历 **D** 的右子树（以E为根）。
10. 到达 **E**，E没有左子树。访问 **E**。`结果: [A, B, C, D, E]`
11. E没有右子树，返回D，返回B，返回F。
12. 至此，F的整个左子树已遍历完毕。现在访问根节点 **F**。`结果: [A, B, C, D, E, F]`
13. 最后遍历 **F** 的右子树（以G为根）。
14. ... 以此类推，最终完成整个遍历。

最终的中序遍历序列为：`A -> B -> C -> D -> E -> F -> G -> H -> I`

## 二、 递归实现：与定义完美契合

递归代码是对“左->根->右”规则最优雅、最直接的程序化翻译。

### 代码实现与解析

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <stack>

// 定义二叉树节点 (与上一篇相同)
struct TreeNode {
    std::string val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(std::string x) : val(x), left(nullptr), right(nullptr) {}
};

/**
 * @brief 中序遍历的递归辅助函数
 * @param root 当前子树的根节点
 * @param result 用于存储遍历结果的向量
 */
void inorderRecursive(TreeNode* root, std::vector<std::string>& result) {
    // 递归的终止条件
    if (root == nullptr) {
        return;
    }

    // 1. 递归遍历左子树 (左)
    inorderRecursive(root->left, result);

    // 2. 访问根节点 (根)
    result.push_back(root->val);

    // 3. 递归遍历右子树 (右)
    inorderRecursive(root->right, result);
}

/**
 * @brief 中序遍历的主函数（递归版）
 */
std::vector<std::string> inorderTraversal_Recursive(TreeNode* root) {
    std::vector<std::string> result;
    inorderRecursive(root, result);
    return result;
}

// ---- 测试代码 ----
// printVector 函数与上一篇相同

int main() {
    // 构建示例树 (与上一篇相同)
    TreeNode* root = new TreeNode("F");
    root->left = new TreeNode("B");
    root->right = new TreeNode("G");
    root->left->left = new TreeNode("A");
    root->left->right = new TreeNode("D");
    root->left->right->left = new TreeNode("C");
    root->left->right->right = new TreeNode("E");
    root->right->right = new TreeNode("I");
    root->right->right->left = new TreeNode("H");

    std::cout << "Recursive In-order Traversal:" << std::endl;
    std::vector<std::string> result_rec = inorderTraversal_Recursive(root);
    printVector(result_rec);

    // ... 非递归测试代码将放在下一节 ...
    return 0;
}
```

#### 代码解析

- **顺序即一切**：对比前序遍历的代码，你会发现三行核心代码完全一样，只是**顺序发生了变化**。这充分说明了三种遍历方式的同源性。
    
- **自然天成**：递归的调用和返回机制，天然地实现了“先深入左子树，再返回处理根，最后深入右子树”的流程。
    

## 三、 非递归实现：栈与指针的精妙共舞

中序遍历的非递归实现比前序遍历要复杂，因为它不能在第一次遇到节点时就访问它，必须**“忍一手”**，直到其左子树全部处理完毕。这就需要我们引入一个辅助指针。

### 核心思想与挑战

我们需要一个`while`循环来驱动整个过程，用一个栈`stack`来存放“待访问的父节点”，还需要一个指针`current`来作为“探索者”，负责深入左子树。

### 算法步骤
1. 初始化一个空栈 `stack` 和一个指针 `current` 指向 `root`。
2. 进入一个主循环，循环条件是 **`current` 不为空 或 `stack` 不为空**。==这个 `OR` 条件是算法能完整执行的关键==。
3. 第一阶段：深入探索左子树。在主循环内部，使用一个嵌套的 while 循环，只要 current 不为空，就不断地：
    a. 将 current 节点压入栈中（保存路径上的父节点）。
    b. 让 current 指向其左孩子 (current = current->left)。
4. 第二阶段：访问与转向。当上述内部循环结束时，意味着我们已经到达了最左边的节点（此时 current 为空）。现在：
    a. 从栈顶弹出一个节点，这个节点就是当前需要访问的“根”。
    b. 访问这个弹出的节点。
    c. 将 current 指针指向该节点的右孩子 (current = node->right)，为下一轮的“深入探索左子树”做准备。
    

### 代码实现与深度解析

```cpp
/**
 * @brief 中序遍历的非递归（迭代）实现
 */
std::vector<std::string> inorderTraversal_Iterative(TreeNode* root) {
    std::vector<std::string> result;
    std::stack<TreeNode*> node_stack;
    
    // “探索者”指针，从根节点开始
    TreeNode* current = root;

    // 只要“探索者”还在路上，或者“待办清单”(栈)里还有事，就继续工作
    while (current != nullptr || !node_stack.empty()) {
        
        // 第一阶段：一路向左，沿途将所有节点压栈
        // 这个循环会找到当前子树的最左边的节点
        while (current != nullptr) {
            node_stack.push(current); // 保存当前节点
            current = current->left;  // 继续向左探索
        }

        // 第二阶段：处理一个节点，并转向其右子树
        // 此时 current 必为 nullptr，我们从栈中取出最近保存的节点
        // 这个节点是当前应该被访问的“根”
        current = node_stack.top();
        node_stack.pop();
        
        // 访问这个节点
        result.push_back(current->val);
        
        // 现在，左边和根都处理完了，轮到右边了
        // 将“探索者”指针指向右孩子，下一轮主循环将对右子树重复以上过程
        current = current->right;
    }

    return result;
}

// 在 main 函数中添加测试
int main() {
    // ... 构建树的代码同上 ...
    TreeNode* root = new TreeNode("F");
    root->left = new TreeNode("B");
    root->right = new TreeNode("G");
    // ... (省略其他节点的创建，与递归部分相同)
    root->left->left = new TreeNode("A");
    root->left->right = new TreeNode("D");
    root->left->right->left = new TreeNode("C");
    root->left->right->right = new TreeNode("E");
    root->right->right = new TreeNode("I");
    root->right->right->left = new TreeNode("H");

    std::cout << "Recursive In-order Traversal:" << std::endl;
    std::vector<std::string> result_rec = inorderTraversal_Recursive(root);
    printVector(result_rec); // 输出: A B C D E F G H I 

    std::cout << "\nIterative In-order Traversal:" << std::endl;
    std::vector<std::string> result_iter = inorderTraversal_Iterative(root);
    printVector(result_iter); // 输出: A B C D E F G H I 

    return 0;
}
```

#### 深度解析与流程模拟

这个过程的精妙之处在于 `current` 指针和栈的配合：

- **`while(current != nullptr)` 循环**：负责==“一路向左”的深入==，并将沿途的所有“父辈”节点存入栈中，作为“路标”。
    
- **`pop()` 和访问操作**：当向左的路走到尽头，就开始==“回溯”并处理==。从栈中弹出的第一个节点，必然是整棵树或某个子树中“最左下”的那个，这符合中序遍历的访问时机。
    
- **`current = current->right`**：访问完一个节点后，算法的下一个目标就是这个节点的右子树。将 `current` 指向右孩子，主循环就会自然地对这个右子树启动新一轮的“一路向左”过程。
    

## 四、 结语

中序遍历是三种深度优先遍历中，非递归实现最具技巧性的一种，但其逻辑也最为优美。

- **递归实现**：依然是首选的、最符合人类直觉的思考方式。
    
- **非递归实现**：通过引入一个辅助指针，与栈形成了完美的“深入-回溯”配合，深刻揭示了遍历的本质。
    
- **核心应用**：==“中序遍历二叉搜索树得到有序序列”==是其最重要的特性，在算法题中被广泛应用。
    

彻底理解了中序遍历的两种实现，尤其是其非递归版本，意味着你对树的掌控力又精进了一大步。接下来，我们就可以挑战三者中最复杂的后序遍历了。