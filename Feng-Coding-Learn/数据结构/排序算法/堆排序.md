---
Type: Note
tags:
  - 数据结构
  - CPP
Status: writing
Start-date: 2025-08-06 20:57
Finish-date: 
Modified-date: 2025-08-06 22:03
Publish: false
---
好的，同学！在掌握了基于“分而治之”思想的快速排序和归并排序，以及树的深度优先遍历之后，我们来学习一个与数据结构紧密结合的、非常高效的排序算法——**堆排序 (Heap Sort)**。

堆排序的精妙之处在于它引入了一个强大的数据结构——**堆（Heap）**，并利用其特性来完成排序。因此，要彻底理解堆排序，我们必须先打好地基，弄清楚什么是堆。

---

# 深入解析堆排序：构建堆与原地排序的艺术

> [!SUMMARY] 前言
> 
> 在经典排序算法中，堆排序是一位“全能型选手”。它不像快速排序那样有 O(n2) 的最坏情况，也不像归并排序那样需要 O(n) 的额外空间。堆排序以其稳定的 O(nlogn) 时间复杂度和**O(1) 空间复杂度**（原地排序）的优异组合，在算法领域中占有重要的一席之地。
> 
> 本文将带你从堆排序的基石——“堆”这种数据结构开始，一步步拆解其核心操作 `heapify`，并完整地展示**“建堆”**和**“排序”**这两个阶段的全过程。掌握了堆排序，你不仅学会了一种高效的排序方法，更能深刻理解数据结构是如何驱动算法设计的。

## 一、 堆排序的基石：什么是堆 (Heap)？

在算法中，“堆”通常指**二叉堆（Binary Heap）**。它是一种特殊的树状数据结构，为了能够被称为“堆”，它必须满足两个核心属性：

**1. 结构属性：它必须是一棵==完全二叉树 (Complete Binary Tree)==。**

- 完全二叉树是指，除了最后一层外，其他各层节点数都达到最大，并且最后一层的节点都连续集中在最左边。
    
- 这个特性非常重要，因为它使得我们可以非常方便地用**数组**来紧凑地表示一个堆，而无需使用指针。
    

**2. 堆属性（序属性）：** 父节点的值与子节点的值之间必须满足特定的序关系。这又分为两种：

- **大顶堆 (Max-Heap)**：**任何一个父节点的值都大于或等于其所有子节点的值**。这意味着，堆顶（根节点）的元素是整个堆中最大的。
    
- **小顶堆 (Min-Heap)**：**任何一个父节点的值都小于或等于其所有子节点的值**。这意味着，堆顶（根节点）的元素是整个堆中最小的。
    

**==堆排序通常利用的是大顶堆==**。

### 用数组表示堆

这是实现堆排序的基石。我们将一个完全二叉树的节点，按层序遍历的顺序，依次存入一个数组中。这样，节点在树中的父子关系就可以通过数组下标的计算来获得：

- 假设父节点的索引是 `i`。
    
- 它的左孩子节点的索引是 `2 * i + 1`。
    
- 它的右孩子节点的索引是 `2 * i + 2`。
    
- 假设子节点的索引是 `i`。
    
- 它的父节点的索引是 `(i - 1) / 2`（整数除法）。
    

## 二、 核心操作：`heapify` (堆的调整)

`heapify`（意为“堆化”）是堆排序算法的核心操作。它的功能是：给定一个节点 `i`，假设它的左右子树都已经是合法的堆，`heapify` 操作可以**将以 `i` 为根的这棵子树调整成一个合法的堆**。

这个过程通常是 **“下沉 (Sift Down)”**：

1. 找出当前节点 `i`、左孩子、右孩子三者中的最大值。
2. 如果最大值不是当前节点 `i`，就将最大值的节点与当前节点 `i` **交换**。
3. 交换后，原来的父节点 `i` “下沉”到了新的位置，它可能又会破坏新位置的子堆。因此，需要**对这个新位置递归地进行 `heapify` 操作**，直到它满足堆属性，或者成为叶子节点为止。

## 三、 堆排序的完整流程

堆排序分为两个主要阶段：

### 阶段一：建立大顶堆 (Build Max-Heap)

目标：将一个无序的输入数组，原地转换成一个大顶堆。

方法：我们不需要从头开始，因为数组中的所有叶子节点天然就可以看作是合法的堆。因此，我们只需要从最后一个非叶子节点开始，向前逐个对每个节点执行 heapify 操作即可。

- 最后一个非叶子节点的索引是 `(n / 2) - 1`，其中 `n` 是数组的长度。
    
- 我们从这个节点开始，一直到根节点 `0`，依次调用 `heapify`。当对根节点 `0` 完成 `heapify` 后，整个数组就变成了一个大顶堆。
    

### 阶段二：排序 (The Sorting Phase)

目标：利用大顶堆的性质，将数组排序。

方法：此时，我们已经有了一个大顶堆，arr[0] 就是当前数组中的最大元素。

1. **交换**：将堆顶元素 `arr[0]` 与当前堆的**最后一个元素** `arr[i]` 进行交换。完成交换后，最大的元素就被放到了它最终应该在的正确位置 `arr[i]`。
    
2. **“缩堆”**：我们将已经排好序的 `arr[i]` 视为“出局”，逻辑上将堆的大小减一。
    
3. **恢复堆**：交换到堆顶的新元素 `arr[0]` 很可能破坏了大顶堆的性质。因此，我们需要对**根节点 `0`** 调用 `heapify`，将堆的大小限定为**新的、缩减后的大小**，以恢复大顶堆。
    
4. **重复**：不断重复上述“交换-缩堆-恢复”的过程，直到堆中只剩一个元素，此时整个数组就有序了。
    

## 四、 C++ 代码实现与解析

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

/**
 * @brief 核心操作：将以 i 为根的子树调整为大顶堆（下沉操作）
 * @param arr 待调整的数组（堆）
 * @param n 堆的大小（注意不是数组的总长度）
 * @param i 要调整的子树的根节点索引
 */
void heapify(std::vector<int>& arr, int n, int i) {
    // 1. 初始化 largest 为当前节点 i
    int largest = i;
    // 2. 计算左右孩子的索引
    int left_child = 2 * i + 1;
    int right_child = 2 * i + 2;

    // 3. 找出当前节点、左孩子、右孩子中的最大值
    // 如果左孩子存在且大于当前 largest 节点
    if (left_child < n && arr[left_child] > arr[largest]) {
        largest = left_child;
    }
    // 如果右孩子存在且大于当前 largest 节点
    if (right_child < n && arr[right_child] > arr[largest]) {
        largest = right_child;
    }

    // 4. 如果 largest 不是原来的根节点 i，说明需要调整
    if (largest != i) {
        // 将最大值的节点与 i 交换
        std::swap(arr[i], arr[largest]);
        // 5. 递归地调整被交换下去的节点，因为它可能破坏了下一层的堆结构
        heapify(arr, n, largest);
    }
}

/**
 * @brief 堆排序主函数
 * @param arr 待排序的数组
 */
void heapSort(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;

    // --- 阶段一：建立大顶堆 ---
    // 从最后一个非叶子节点开始，自底向上地对每个节点进行 heapify
    // 最后一个非叶子节点的索引为 (n/2) - 1
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // --- 阶段二：排序 ---
    // 不断地从堆顶取出最大元素，放到数组末尾
    for (int i = n - 1; i > 0; i--) {
        // 1. 将当前堆顶（最大元素）与堆的最后一个元素交换
        std::swap(arr[0], arr[i]);
        // 2. 堆的大小减一，并对新的堆顶（索引0）进行 heapify 以恢复大顶堆
        heapify(arr, i, 0);
    }
}

// ---- 测试代码 ----
void printVector(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    std::cout << "Original array: ";
    printVector(arr);

    heapSort(arr);

    std::cout << "Sorted array:   ";
    printVector(arr);
    return 0;
}
```

#### 代码解析

- **`heapify` 函数**：是所有操作的基础，它保证了任何一个子树都能被调整成合法的堆。
    
- **建堆循环**：`for (int i = n / 2 - 1; i >= 0; i--)` 是一个非常高效的建堆过程。通过从下到上、从右到左地调用`heapify`，它保证了当`heapify(i)`被调用时，`i`的所有子节点都已经是堆的根，满足`heapify`的前提条件。
    
- **排序循环**：`for (int i = n - 1; i > 0; i--)` 巧妙地利用了数组的末尾空间来存放已排序好的元素，实现了**原地排序**。每次循环，都将当前问题的“最优解”（最大值）找出来并放到最终位置，这是一个典型的减治思想。



**事实上，堆排序最标准、最常见的工业级实现版本，本身就是非递归的。**

在我们之前的讲解中，为了教学上的清晰，我为你展示的 `heapify` (堆调整) 函数是递归版本，因为它能非常直观地体现“下沉”这个概念。但这个递归非常容易，并且通常会被转换成迭代（循环）的形式，以消除函数调用的开销。

值得强调的是：**堆排序的主体框架（建堆循环和排序循环）本来就是循环，不是递归**。唯一存在递归可能性的，就是 `heapify` 这个核心辅助函数。

下面，我们就来详细讲解如何将 `heapify` 函数改写为非递归版本，并组成一个完全无递归的堆排序。



## 非递归 `heapify` 的核心思想

递归 `heapify` 的逻辑是：
> 比较父、左、右 -> 如果父不是最大，则交换 -> **对自己被换到的新位置，再次调用 `heapify`**。

非递归（迭代）`heapify` 的逻辑是：
> 用一个 `while` 循环，持续地比较 父、左、右 -> 如果父不是最大，则交换 -> **更新父节点的位置到它被换下去的新位置，继续下一轮循环**。

你看，它们做的是完全一样的事情，只是一个用函数调用来“继续”，一个用循环和索引更新来“继续”。

### 迭代版 `heapify` 的算法步骤

1. 用一个 `while` 循环来驱动整个“下沉”过程。循环的条件是，当前节点 `i` 至少有一个孩子（即它不是叶子节点）。
2. 在循环内部，和递归版一样，找出当前节点 `i`、左孩子、右孩子三者中的最大值，记录其索引为 `largest`。
3. **判断与决策**:
    - 如果 `largest` 的索引就是 `i` 本身，说明当前节点已经比它的两个孩子都大（或相等），它在这个子树里已经“就位”了。我们直接 **`break`** 退出循环即可。
    - 如果 `largest` 的索引是某个孩子的，说明需要调整。我们交换 `arr[i]` 和 `arr[largest]`。
        
4. **关键一步**：交换完成后，原来的父节点 `i` 被换到了 `largest` 的位置。为了让它继续“下沉”，我们必须更新 `i` 的值，令 `i = largest`，这样下一轮 `while` 循环就会从这个新位置开始，继续向下比较和调整。


### 完全非递归的堆排序 C++ 代码

注意看，下面的 `heapSort` 函数和我们之前讲的完全一样。**唯一的区别在于 `heapify` 函数的内部实现**。

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

/**
 * @brief 核心操作：将以 i 为根的子树调整为大顶堆（非递归/迭代版）
 * @param arr 待调整的数组（堆）
 * @param n 堆的大小
 * @param i 要调整的子树的根节点索引
 */
void heapify_Iterative(std::vector<int>& arr, int n, int i) {
    // 循环将驱动节点 i 不断“下沉”
    while (true) {
        // 1. 初始化 largest 为当前节点 i
        int largest = i;
        // 2. 计算左右孩子的索引
        int left_child = 2 * i + 1;
        int right_child = 2 * i + 2;

        // 3. 找出三者中的最大值
        if (left_child < n && arr[left_child] > arr[largest]) {
            largest = left_child;
        }
        if (right_child < n && arr[right_child] > arr[largest]) {
            largest = right_child;
        }

        // 4. 如果 largest 仍然是 i，说明 i 节点已满足堆属性，无需下沉
        if (largest == i) {
            break; // 调整完成，退出循环
        }

        // 5. 如果 i 不是最大值，则与最大值交换
        std::swap(arr[i], arr[largest]);

        // 6. 更新 i 的位置，为下一次循环做准备，让其在新位置继续下沉
        i = largest;
    }
}

/**
 * @brief 堆排序主函数（其本身就是迭代的）
 * @param arr 待排序的数组
 */
void heapSort_Iterative(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;

    // --- 阶段一：建立大顶堆 ---
    // 这个循环本身就是迭代的
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify_Iterative(arr, n, i);
    }

    // --- 阶段二：排序 ---
    // 这个循环本身也是迭代的
    for (int i = n - 1; i > 0; i--) {
        std::swap(arr[0], arr[i]);
        heapify_Iterative(arr, i, 0);
    }
}

// ---- 测试代码 ----
void printVector(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr = {12, 11, 13, 5, 6, 7};
    std::cout << "Original array: ";
    printVector(arr);

    heapSort_Iterative(arr);

    std::cout << "Sorted array:   ";
    printVector(arr);
    return 0;
}
```

### 递归 vs. 非递归 `heapify`，如何选择？

- **性能**：非递归版本通过消除函数调用开销，理论上会比递归版本快一点点。但在现代编译器优化下，这种差异通常微乎其微，可以忽略不计。
    
- **代码风格**：递归版本的代码通常被认为更简洁，更贴近算法思想的数学定义，可读性稍高。非递归版本则更接近底层机器的执行方式。
    
- **栈溢出风险**：这是我们之前讨论其他算法时，放弃递归的主要原因。**但在堆排序中，这几乎不是一个问题**。因为 `heapify` 的递归深度最多是树的高度，即 O(logn)。对于一个有几十亿个元素的数组，递归深度也才30多层，完全不足以导致栈溢出。


## 五、 性能与特性总结

|特性|描述|
|---|---|
|**时间复杂度**|**最好、最坏、平均情况均为 O(nlogn)**。建堆过程是 O(n)，排序过程是 n−1 次 O(logn) 的`heapify`操作。|
|**空间复杂度**|**O(1)**。==这是堆排序相比归并排序的最大优势==，它是一个**原地排序算法**。|
|**稳定性**|**不稳定**。在`heapify`或排序的交换过程中，相等元素的原始相对位置可能会改变。|

### 排序算法三巨头对比

| 算法       | 时间复杂度 (平均) | 时间复杂度 (最坏) | 空间复杂度    | 稳定性    |
| -------- | ---------- | ---------- | -------- | ------ |
| **快速排序** | O(nlogn)   | O(n2)      | O(logn)  | 不稳定    |
| **归并排序** | O(nlogn)   | O(nlogn)   | O(n)     | **稳定** |
| **堆排序**  | O(nlogn)   | O(nlogn)   | **O(1)** | 不稳定    |





## 六、 结语

堆排序是一种集众多优点于一身的排序算法。它没有快速排序最坏情况的隐患，也没有归并排序高昂的空间开销。虽然在实践中，由于其缓存局部性不如快速排序，导致平均速度稍慢，但其**原地排序**和**稳定的 O(nlogn) 性能**，使它在对空间和最坏情况有严格要求的场景下，成为一个非常理想的选择。

此外，堆这种数据结构本身，在“优先队列”等问题中有着更为广泛和直接的应用，掌握它对提升你的算法能力至关重要。 