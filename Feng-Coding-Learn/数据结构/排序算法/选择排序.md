---
Type: Note
tags:
  - 数据结构
  - 算法
  - CPP
Status: writing
Start-date: 2025-08-06 22:15
Finish-date: 
Modified-date: 2025-08-07 21:13
Publish: false
---
在学习了“将元素插入到有序区”的插入排序后，我们来看看另一位思想同样简洁的 O(n2) 家族成员——**选择排序 (Selection Sort)**。

它的思考方式与插入排序截然不同，展现了另一种解决问题的朴素智慧。

# 排序算法之美：深入解析选择排序（Selection Sort）的原理与特性

> [!SUMMARY] 前言
> 
> 在简单的排序算法中，如果说插入排序像整理手中的扑克牌，那么选择排序（Selection Sort）则更像是在队伍中挑选成员。它的每一步决策都非常“有远见”和“果断”：在当前所有待选者中，直接挑出最符合要求（最大或最小）的那一个，放到它最终应该在的位置。
> 
> 尽管同为 O(n^2) 算法，选择排序在性能上通常不如插入排序，但它以其**极简的交换次数**和**不受输入数据顺序影响**的稳定执行流程，为我们提供了一个独特的算法分析视角。理解它，能帮助我们更全面地看待不同排序策略的内在权衡。

## 一、 核心思想：每次都选“天选之子”

选择排序的逻辑非常清晰，可以比作体育老师在排队：
1. **划定范围**：首先，将整个队伍看作“待排序”区。
2. **选出最优**：从这个“待排序”区里，用眼睛扫一遍，找到**最矮**的那位同学。
3. **交换归位**：让这位最矮的同学，与“待排序”区的**第一位同学**交换位置。现在，队伍的最左边站的就是最矮的同学，他已经“归位”了，成为“已排序”区的一部分。
4. **缩小范围*：将“待排序”区的范围从第二位同学开始，重复上述过程，直到所有同学都“归位”。

这个过程不断地在剩余的未排序元素中，选择一个最小（或最大）的元素，并将其放置在已排序序列的末尾。

## 二、 详细步骤图解
我们依然用数组 `arr = [5, 2, 4, 6, 1, 3]` 来进行图解。`|` 左侧为“已排序”区，右侧为“未排序”区。

初始状态:
`[| 5, 2, 4, 6, 1, 3]`

**第一轮:**
- **扫描范围**: `[5, 2, 4, 6, 1, 3]`
- **找到最小**: `1` (在索引4的位置)
- **交换**: 将最小值 `1` 与未排序区的第一个元素 `5` 交换。
- **结果**: ==`[1 | 2, 4, 6, 5, 3]`==

**第二轮:**
- **扫描范围**: `[2, 4, 6, 5, 3]`
- **找到最小**: `2` (在索引1的位置)
- **交换**: 最小值 `2` 已经是未排序区的第一个元素，与自身交换（无变化）。
- **结果**: ==`[1, 2 | 4, 6, 5, 3]`==

**第三轮:**
- **扫描范围**: `[4, 6, 5, 3]`
- **找到最小**: `3` (在索引5的位置)
- **交换**: 将最小值 `3` 与未排序区的第一个元素 `4` 交换。
- **结果**: ==`[1, 2, 3 | 6, 5, 4]`==

**第四轮:**
- **扫描范围**: `[6, 5, 4]`
- **找到最小**: `4` (在索引5的位置)
- **交换**: 将最小值 `4` 与未排序区的第一个元素 `6` 交换。
- **结果**: ==`[1, 2, 3, 4 | 5, 6]`==

**第五轮:**
- **扫描范围**: `[5, 6]`
- **找到最小**: `5` (在索引4的位置)
- **交换**: 最小值 `5` 与自身交换（无变化）。
- **结果**: ==`[1, 2, 3, 4, 5 | 6]`==

当未排序区只剩一个元素时，它必然是最大的，排序自然完成。

## 三、 C++ 代码实现与解析

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::swap

/**
 * @brief 选择排序函数
 * @param arr 待排序的数组
 */
void selectionSort(std::vector<int>& arr) {
    int n = arr.size();
    // 外层循环控制“已排序”区的边界
    // i 代表每一轮中，待放置最小元素的目标位置
    for (int i = 0; i < n - 1; ++i) {
        
        // 1. 在未排序区域 arr[i...n-1] 中寻找最小元素的索引
        int min_index = i; // 先假定当前位置的元素是最小的
        
        // 内层循环负责在未排序区域中进行扫描
        for (int j = i + 1; j < n; ++j) {
            // 如果发现了更小的元素，就更新最小元素的索引
            if (arr[j] < arr[min_index]) {
                min_index = j;
            }
        }
        
        // 2. 将找到的最小元素与未排序区的第一个元素 arr[i] 进行交换
        // 如果 min_index 没有变，说明 arr[i] 本身就是最小的，可以避免不必要的自身交换
        if (min_index != i) {
            std::swap(arr[i], arr[min_index]);
        }
    }
}

void printVector(const std::vector<int>& arr) {
    for (int num : arr) {
        std::cout << num << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> data = {5, 2, 4, 6, 1, 3};
    std::cout << "Original array: ";
    printVector(data);

    selectionSort(data);

    std::cout << "Sorted array:   ";
    printVector(data);
    return 0;
}
```

#### 代码解析
- **外层循环 `for (int i = ...)`**：它的任务是填充 `arr[0]`, `arr[1]`, `arr[2]`... 这些位置。循环 `n-1` 次，因为当 `n-1` 个元素都归位后，最后一个元素也必然在正确的位置了。
    
- **内层循环 `for (int j = ...)`**：它的唯一目的就是在 `arr[i...n-1]` 这个未排序区间内**进行扫描**，找出值最小的那个元素的**索引 `min_index`**。它只负责“找”，不负责“换”。
    
- **`std::swap(arr[i], arr[min_index])`**：这是每一轮外层循环中**唯一的一次交换操作**。在内层循环完整地扫描完、确认了最小元素的位置之后，才执行这次精准的交换。
    

## 四、 性能与特性分析

|特性|描述|
|---|---|
|**时间复杂度**|**最好、最坏、平均情况均为 O(n2)**。因为无论数组初始状态如何，内外两层循环都必须完整地执行。比较次数始终是 n(n−1)/2。|
|**空间复杂度**|**O(1)**。它是一个**原地排序 (in-place)** 算法。|
|**稳定性**|**不稳定 (Unstable)**。==这是选择排序的一个重要特点==。在交换过程中，可能会打乱相等元素的原始相对顺序。<br> **例子**：对于数组 `[5a, 5b, 2]`，第一轮会找到 `2` 是最小的，然后将 `5a` 与 `2` 交换，数组变为 `[2, 5b, 5a]`。此时，`5a` 和 `5b` 的相对顺序就被改变了。|
|**交换次数**|**最多只有 `n-1` 次交换**。==这是选择排序相比冒泡排序等算法的一个理论优势==。|

### 选择排序 vs. 插入排序
- **数据移动（交换）**：**选择排序**的交换次数是固定的、非常少的 (O(n) 级别)。而**插入排序**在最坏情况下，数据移动/交换次数是 O(n2) 级别。因此，如果数据写入（交换）的成本远高于读取（比较）的成本，选择排序会有一点优势。
    
- **自适应性**：**插入排序是自适应的**，对于几乎有序的数组，其性能接近 O(n)。而**选择排序是“顽固”的**，它从不关心输入数据的初始状态，总是勤勤恳恳地执行完所有比较，性能恒定为 O(n2)。
    

## 五、 结语
选择排序以其无可比拟的逻辑简洁性，成为了许多人学习编程时接触的第一个排序算法。它“每次都选最好的”的贪心策略，为我们展示了一种简单而强大的问题解决方法。

尽管在综合性能上，它通常不如插入排序（尤其是在处理近乎有序数据时），但它**“最少的交换次数”**这一特性，让它在算法分析中具有独特的理论价值。学习选择排序，能让我们更深刻地理解不同算法策略在“比较”和“交换”这两种基础操作上的成本权衡。